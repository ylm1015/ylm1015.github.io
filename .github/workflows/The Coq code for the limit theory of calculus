(** MA_CH1 *)

(* 读入库文件 *)
Require Export Real_Axioms.

Parameter R_stru : Real_struct.
Parameter R_axio : Real_axioms R_stru.

Global Hint Resolve R_axio : core.

Declare Scope MA_R_scope.
Delimit Scope MA_R_scope with ma.
Open Scope MA_R_scope.

Definition ℝ := @R R_stru.
Definition ℕ := @N R_stru.
Definition ℤ := @Z R_stru.
Definition ℚ := @Q R_stru.
Definition fp := @fp R_stru.
Definition zeroR := @zeroR R_stru.
Definition fm := @fm R_stru.
Definition oneR := @oneR R_stru.
Definition Leq := @Leq R_stru.
Definition Abs := @Abs R_stru.

Notation "x + y" := fp[[x, y]] : MA_R_scope.
Notation "0" := zeroR : MA_R_scope.
Notation "x · y" := fm[[x, y]](at level 40) : MA_R_scope.
Notation "1" := oneR : MA_R_scope.
Notation "x ≤ y" := ([x, y] ∈ Leq)(at level 77) : MA_R_scope.
Notation "- a" := (∩(\{ λ u, u ∈ ℝ /\ u + a = 0 \})) : MA_R_scope.
Notation "x - y" := (x + (-y)) : MA_R_scope.
Notation "a ⁻" := (∩(\{ λ u, u ∈ (ℝ ~ [0]) /\ u · a = 1 \}))
  (at level 5) : MA_R_scope.
Notation "m / n" := (m · (n⁻)) : MA_R_scope.
Notation "｜ x ｜" := (Abs[x])(at level 5, x at level 0) : MA_R_scope.

Definition LT x y := x ≤ y /\ x <> y.
Notation "x < y" := (LT x y) : MA_R_scope.
Definition Ensemble_R := @Ensemble_R R_stru R_axio.
Definition PlusR := @PlusR R_stru R_axio.
Definition zero_in_R := @zero_in_R R_stru R_axio.
Definition Plus_P1 := @Plus_P1 R_stru R_axio.
Definition Plus_P2 := @Plus_P2 R_stru R_axio.
Definition Plus_P3 := @Plus_P3 R_stru R_axio.
Definition Plus_P4 := @Plus_P4 R_stru R_axio.
Definition MultR := @MultR R_stru R_axio.
Definition one_in_R := @one_in_R R_stru R_axio.
Definition Mult_P1 := @Mult_P1 R_stru R_axio.
Definition Mult_P2 := @Mult_P2 R_stru R_axio.
Definition Mult_P3 := @Mult_P3 R_stru R_axio.
Definition Mult_P4 := @Mult_P4 R_stru R_axio.
Definition Mult_P5 := @Mult_P5 R_stru R_axio.
Definition LeqR := @LeqR R_stru R_axio.
Definition Leq_P1 := @Leq_P1 R_stru R_axio.
Definition Leq_P2 := @Leq_P2 R_stru R_axio.
Definition Leq_P3 := @Leq_P3 R_stru R_axio.
Definition Leq_P4 := @Leq_P4 R_stru R_axio.
Definition Plus_Leq := @Plus_Leq R_stru R_axio.
Definition Mult_Leq := @Mult_Leq R_stru R_axio.
Definition Completeness := @Completeness R_stru R_axio.

Definition Plus_close := @Plus_close R_stru R_axio.
Definition Mult_close := @Mult_close R_stru R_axio.
Definition one_in_R_Co := @one_in_R_Co R_stru R_axio.
Definition Plus_Co1 := @Plus_Co1 R_stru R_axio.
Definition Plus_Co2 := @Plus_Co2 R_stru R_axio.
Definition Plus_neg1a := @Plus_neg1a R_stru R_axio.
Definition Plus_neg1b := @Plus_neg1b R_stru R_axio.
Definition Plus_neg2 := @Plus_neg2 R_stru R_axio.
Definition Minus_P1 := @Minus_P1 R_stru R_axio.
Definition Minus_P2 := @Minus_P2 R_stru R_axio.
Definition Plus_Co3 := @Plus_Co3 R_stru R_axio.
Definition Mult_Co1 := @Mult_Co1 R_stru R_axio.
Definition Mult_Co2 := @Mult_Co2 R_stru R_axio.
Definition Mult_inv1 := @Mult_inv1 R_stru R_axio.
Definition Mult_inv2 := @Mult_inv2 R_stru R_axio.
Definition Divide_P1 := @Divide_P1 R_stru R_axio.
Definition Divide_P2 := @Divide_P2 R_stru R_axio.
Definition Mult_Co3 := @Mult_Co3 R_stru R_axio.
Definition PlusMult_Co1 := @PlusMult_Co1 R_stru R_axio.
Definition PlusMult_Co2 := @PlusMult_Co2 R_stru R_axio.
Definition PlusMult_Co3 := @PlusMult_Co3 R_stru R_axio.
Definition PlusMult_Co4 := @PlusMult_Co4 R_stru R_axio.
Definition PlusMult_Co5 := @PlusMult_Co5 R_stru R_axio.
Definition PlusMult_Co6 := @PlusMult_Co6 R_stru R_axio.
Definition Order_Co1 := @Order_Co1 R_stru R_axio.
Definition Order_Co2 := @Order_Co2 R_stru R_axio.
Definition OrderPM_Co1 := @OrderPM_Co1 R_stru R_axio.
Definition OrderPM_Co2a := @OrderPM_Co2a R_stru R_axio.
Definition OrderPM_Co2b := @OrderPM_Co2b R_stru R_axio.
Definition OrderPM_Co3 := @OrderPM_Co3 R_stru R_axio.
Definition OrderPM_Co4 := @OrderPM_Co4 R_stru R_axio.
Definition OrderPM_Co5 := @OrderPM_Co5 R_stru R_axio.
Definition OrderPM_Co6 := @OrderPM_Co6 R_stru R_axio.
Definition OrderPM_Co7a := @OrderPM_Co7a R_stru R_axio.
Definition OrderPM_Co7b := @OrderPM_Co7b R_stru R_axio.
Definition OrderPM_Co8a := @OrderPM_Co8a R_stru R_axio.
Definition OrderPM_Co8b := @OrderPM_Co8b R_stru R_axio.
Definition OrderPM_Co9 := @OrderPM_Co9 R_stru R_axio.
Definition OrderPM_Co10 := @OrderPM_Co10 R_stru R_axio.
Definition OrderPM_Co11 := @OrderPM_Co11 R_stru R_axio.
Definition IndSet := @IndSet R_stru.
Definition IndSet_P1 := @IndSet_P1 R_stru.
Definition N_Subset_R := @N_Subset_R R_stru R_axio.
Definition one_in_N := @one_in_N R_stru R_axio.
Definition zero_not_in_N := @zero_not_in_N R_stru R_axio.
Definition IndSet_N := @IndSet_N R_stru R_axio.
Definition MathInd := @MathInd R_stru R_axio.
Definition Nat_P1a := @Nat_P1a R_stru R_axio.
Definition Nat_P2 := @Nat_P2 R_stru R_axio.
Definition Nat_P3 := @Nat_P3 R_stru R_axio.
Definition Nat_P4 := @Nat_P4 R_stru R_axio.
Definition Nat_P5 := @Nat_P5 R_stru R_axio.
Definition Nat_P6 := @Nat_P6 R_stru R_axio.
Definition Nat_P7 := @Nat_P7 R_stru R_axio.
Definition one_is_min_in_N := @one_is_min_in_N R_stru R_axio.
Definition N_Subset_Z := @N_Subset_Z R_stru.
Definition Z_Subset_R := @Z_Subset_R R_stru R_axio.
Definition Int_P1_Lemma := @Int_P1_Lemma R_stru R_axio.
Definition Int_P1a := @Int_P1a R_stru R_axio.
Definition Int_P1b := @Int_P1b R_stru R_axio.
Definition Int_P2 := @Int_P2 R_stru R_axio.
Definition Int_P3 := @Int_P3 R_stru R_axio.
Definition Int_P4 := @Int_P4 R_stru R_axio.
Definition Int_P5 := @Int_P5 R_stru R_axio.
Definition Z_Subset_Q := @Z_Subset_Q R_stru R_axio.
Definition Q_Subset_R := @Q_Subset_R R_stru R_axio.
Definition Frac_P1 := @Frac_P1 R_stru R_axio.
Definition Frac_P2 := @Frac_P2 R_stru R_axio.
Definition Rat_P1a := @Rat_P1a R_stru R_axio.
Definition Rat_P1b := @Rat_P1b R_stru R_axio.
Definition Rat_P2 := @Rat_P2 R_stru R_axio.
Definition Rat_P3 := @Rat_P3 R_stru R_axio.
Definition Rat_P4 := @Rat_P4 R_stru R_axio.
Definition Rat_P5 := @Rat_P5 R_stru R_axio.
Definition Rat_P6 := @Rat_P6 R_stru R_axio.
Definition Rat_P7 := @Rat_P7 R_stru R_axio.
Definition Rat_P8 := @Rat_P8 R_stru R_axio.
Definition Rat_P9 := @Rat_P9 R_stru R_axio.
Definition Rat_P10 := @Rat_P10 R_stru R_axio.
Definition Even := @Even R_stru.
Definition Odd := @Odd R_stru.
Definition Even_and_Odd_P1 := @Even_and_Odd_P1 R_stru R_axio.
Definition Even_and_Odd_P2_Lemma := @Even_and_Odd_P2_Lemma R_stru R_axio.
Definition Even_and_Odd_P2 := @Even_and_Odd_P2 R_stru R_axio.
Definition Even_and_Odd_P3 := @Even_and_Odd_P3 R_stru R_axio.
Definition Existence_of_irRational_Number :=
  @Existence_of_irRational_Number R_stru R_axio.
Definition Arch_P1 := @Arch_P1 R_stru R_axio.
Definition Arch_P2 := @Arch_P2 R_stru R_axio.
Definition Arch_P3_Lemma := @Arch_P3_Lemma R_stru R_axio.
Definition Arch_P3a := @Arch_P3a R_stru R_axio.
Definition Arch_P3b := @Arch_P3b R_stru R_axio.
Definition Arch_P4 := @Arch_P4 R_stru R_axio.
Definition Arch_P5 := @Arch_P5 R_stru R_axio.
Definition Arch_P6 := @Arch_P6 R_stru R_axio.
Definition Arch_P7 := @Arch_P7 R_stru R_axio.
Definition Arch_P8 := @Arch_P8 R_stru R_axio.
Definition Arch_P9 := @Arch_P9 R_stru R_axio.
Definition Arch_P10 := @Arch_P10 R_stru R_axio.
Definition Abs_is_Function := @Abs_is_Function R_stru R_axio.
Definition Abs_in_R := @Abs_in_R R_stru R_axio.
Definition Distance := @Distance R_stru.
Definition me_zero_Abs := @me_zero_Abs R_stru R_axio.
Definition le_zero_Abs := @le_zero_Abs R_stru R_axio.
Definition Abs_P1 := @Abs_P1 R_stru R_axio.
Definition Abs_P2 := @Abs_P2 R_stru R_axio.
Definition Abs_P3 := @Abs_P3 R_stru R_axio.
Definition Abs_P4 := @Abs_P4 R_stru R_axio.
Definition Abs_P5 := @Abs_P5 R_stru R_axio.
Definition Abs_P6 := @Abs_P6 R_stru R_axio.
Definition Abs_P7 := @Abs_P7 R_stru R_axio.
Definition Abs_P8 := @Abs_P8 R_stru R_axio.

Global Hint Resolve Plus_close zero_in_R Mult_close one_in_R one_in_R_Co
  Plus_neg1a Plus_neg1b Plus_neg2 Minus_P1 Minus_P2
  Mult_inv1 Mult_inv2 Divide_P1 Divide_P2 OrderPM_Co9
  N_Subset_R one_in_N Nat_P1a Nat_P1b
  N_Subset_Z Z_Subset_R Int_P1a Int_P1b
  Z_Subset_Q Q_Subset_R Rat_P1a Rat_P1b Abs_in_R: real.
  
(* 1.2 数集 确界原理 *)

(* 1.2.1 区间与邻域 *)

(* 有限区间 *) 
(* 开区间 *)
Notation "］ a , b ［" := (\{ λ x, x ∈ ℝ /\ a < x /\ x < b \})
  (at level 5, a at level 0, b at level 0) : MA_R_scope.

(* 闭区间 *)
Notation "［ a , b ］" := (\{ λ x, x ∈ ℝ /\ a ≤ x /\ x ≤ b \})
  (at level 5, a at level 0, b at level 0) : MA_R_scope.

(* 左开右闭 *)
Notation "］ a , b ］" := (\{ λ x, x ∈ ℝ /\ a < x /\ x ≤ b \})
  (at level 5, a at level 0, b at level 0) : MA_R_scope.

(* 左闭右开 *)
Notation "［ a , b ［" := (\{ λ x, x ∈ ℝ /\ a ≤ x /\ x < b \})
  (at level 5, a at level 0, b at level 0) : MA_R_scope.

(* 无限区间 *)
Notation "］ a , +∞［" := (\{ λ x, x ∈ ℝ /\ a < x \})
  (at level 5, a at level 0) : MA_R_scope.

Notation "［ a , +∞［" := (\{ λ x, x ∈ ℝ /\ a ≤ x \})
  (at level 5, a at level 0) : MA_R_scope.

Notation "］-∞ , b ］" := (\{ λ x, x ∈ ℝ /\ x ≤ b \})
  (at level 5, b at level 0) : MA_R_scope.

Notation "］-∞ , b ［" := (\{ λ x, x ∈ ℝ /\ x < b \})
  (at level 5, b at level 0) : MA_R_scope.

Notation "]-∞ , +∞[" := ℝ (at level 0) : MA_R_scope.

(* 邻域 *)
Notation "U( a ; δ )" := \{ λ x, x ∈ ℝ /\ ｜ (x - a) ｜ < δ \}
  (a at level 0, δ at level 0, at level 4) : MA_R_scope.

(* 左邻域 *)
Notation "U-( a ; δ )" := ］a-δ, a］
  (a at level 0, δ at level 0, at level 4) : MA_R_scope.

(* 右邻域 *)
Notation "U+( a ; δ )" := ［a, (a+δ)［
  (a at level 0, δ at level 0, at level 4) : MA_R_scope.

(* 去心邻域 *)
Notation "Uº( a ; δ )" := \{ λ x, x ∈ ℝ /\ 0 < ｜(x-a)｜ /\ ｜(x-a)｜ < δ \}
  (a at level 0, δ at level 0, at level 4) : MA_R_scope.

(* 左去心邻域 *)
Notation "U-º( a ; δ )" := ］a-δ, a［
  (a at level 0, δ at level 0, at level 4) : MA_R_scope.

(* 右去心邻域 *)
Notation "U+º( a ; δ )" := ］a, (a+δ)［
  (a at level 0, δ at level 0, at level 4) : MA_R_scope.

(* 无穷邻域 *)
Notation "U(∞) M" := \{ λ x, x ∈ ℝ /\ M ∈ ℝ /\ 0 < M /\ M < ｜x｜ \}
  (at level 5) : MA_R_scope.

(* 正无穷邻域 *)
Notation "U(+∞) M" := \{ λ x, x ∈ ℝ /\ M ∈ ℝ /\ M < x \}
 (at level 5) : MA_R_scope.

(* 负无穷邻域 *)
Notation "U(-∞) M" := \{ λ x, x ∈ ℝ /\ M ∈ ℝ /\ x < M \}
  (at level 5) : MA_R_scope.

(* 1.2.2 有界集 确界原理 *)

(* 上界 *)
Definition UpperBound S M := S ⊂ ℝ /\ M ∈ ℝ /\ (∀ x, x ∈ S -> x ≤ M).

(* 下界 *)
Definition LowerBound S L := S ⊂ ℝ /\ L ∈ ℝ /\ (∀ x, x ∈ S -> L ≤ x).

(* 有界集 *)
Definition Bounded S := ∃ M L, UpperBound S M /\ LowerBound S L.

(* 无界集 *)
Definition Unbounded S := ~ (Bounded S).

(* 上确界 *)
Definition Sup S η := UpperBound S η /\ (∀ α, α ∈ ℝ -> α < η
  -> (∃ x0, x0 ∈ S /\ α < x0)).

(* 下确界 *)
Definition Inf S ξ := LowerBound S ξ /\ (∀ β, β ∈ ℝ -> ξ < β
  -> (∃ x0, x0 ∈ S /\ x0 < β)).
  
Definition Max S c := S ⊂ ℝ /\ c ∈ S /\ (∀ x, x ∈ S -> x ≤ c).

Definition Min S c := S ⊂ ℝ /\ c ∈ S /\ (∀ x, x ∈ S -> c ≤ x).

Corollary Max_Corollary : ∀ S c1 c2, Max S c1 -> Max S c2 -> c1 = c2.
Proof.
  intros. unfold Max in *. destruct H as [H []], H0 as [H0 []].
  pose proof H1. pose proof H3. apply H2 in H6. apply H4 in H5.
  apply Leq_P2; auto.
Qed.
  
Corollary Min_Corollary : ∀ S c1 c2, Min S c1 -> Min S c2 -> c1 = c2. 
Proof.
  intros. unfold Min in *. destruct H as [H []], H0 as [H0 []].
  pose proof H1. pose proof H3. apply H2 in H6. apply H4 in H5.
  apply Leq_P2; auto.
Qed.

Definition Sup_Equal S η := Min \{ λ u, UpperBound S u \} η.

Corollary Sup_Corollary : ∀ S η, Sup S η <-> Sup_Equal S η.
Proof.
  intros. split; intro.
  - red in H; red. destruct H, H as [H []]. repeat split. 
    unfold Included; intros. apply AxiomII in H3 as [_[_[]]]; auto.
    apply AxiomII; split. unfold Ensemble; exists ℝ; auto. split; auto.
    intros. apply AxiomII in H3 as [H3 [H4 []]]. pose proof H5.
    apply (Order_Co1 x η) in H7 as [H7 | [|]]; auto.
    + apply H0 in H7 as [x0 []]; auto. pose proof H7. apply H6 in H9.
      destruct H8. elim H10. apply Leq_P2; auto.
    + destruct H7. auto.
    + rewrite H7. apply Leq_P1; auto.
  - red in H; red. destruct H as [H []]. apply AxiomII in H0 as [_[H0 []]].
    repeat split; auto. intros. apply NNPP; intro.
    assert (∀ x1, x1 ∈ S -> x1 ≤ α).
    { intros. apply NNPP; intro. elim H6. exists x1. split; auto.  
      pose proof H4. apply (@ Order_Co1 x1 α) in H9
      as [H9 | [|]]; auto. elim H8. destruct H9. auto. 
      rewrite H9 in H8. elim H8. apply Leq_P1; auto. }
    assert (α ∈ \{ λ u, UpperBound S u \}).
    { apply AxiomII. split. exists ℝ; auto. split; auto. }
    apply H1 in H8. destruct H5. elim H9. 
    apply Leq_P2; auto.
Qed.

Definition Inf_Equal S ξ := Max \{ λ u, LowerBound S u \} ξ.

Corollary Inf_Corollary : ∀ S ξ, Inf S ξ <-> Inf_Equal S ξ.
Proof.
  intros. split; intro.
  - red in H; red. destruct H, H as [H []]. repeat split.
    unfold Included; intros. apply AxiomII in H3 as [_[_[]]]; auto.
    apply AxiomII; split. exists ℝ; auto. repeat split; auto.
    intros. apply AxiomII in H3 as [H3 [H4 []]]. pose proof H5.
    apply (@ Order_Co1 x ξ) in H7 as [H7 | [|]]; auto.
    + destruct H7. auto.
    + apply H0 in H7 as [x0 []]; auto. pose proof H7. apply H6 in H9.
      destruct H8. elim H10. apply Leq_P2; auto.
    + rewrite H7. apply Leq_P1; auto.
  - red in H; red. destruct H as [H []]. apply AxiomII in H0 as [_[H2 []]].
    repeat split; auto. intros. apply NNPP; intro.
    assert (∀x1, x1 ∈ S -> β ≤ x1).
    { intros. apply NNPP; intro. elim H6. exists x1. split; auto.
      pose proof H4. apply (Order_Co1 x1 β) in H9 
      as [H9 | [|]]; auto. elim H8. destruct H9. auto.
      rewrite H9 in H8. elim H8. apply Leq_P1; auto. }
    assert (β ∈ \{ λ u, LowerBound S u \}).
    { apply AxiomII; split. exists ℝ; auto. repeat split; auto. }
    apply H1 in H8. destruct H5. elim H9.
    apply Leq_P2; auto.
Qed.

(* 确界原理 *)

(* Theorem SupL' : ∀ S, S ⊂ ℝ -> S <> Φ -> (∃ M, UpperBound S M)
  -> exists η, Sup S η.
Proof.
  intros. destruct H1 as [M].
  set (Y := \{ λ u, UpperBound S u \}).
  assert (Y <> Φ).
  { apply NEexE. exists M. apply AxiomII; split; auto. 
    red in H1. destruct H1 as [_[]]. eauto. }
  assert (Y ⊂ ℝ).
  { unfold Included. intros. apply AxiomII in H3. 
    destruct H3 as [_[_[]]]. auto. }
  assert (∃ c, c ∈ ℝ /\ (∀ x y, x ∈ S -> y ∈ Y -> (x ≤ c /\ c ≤ y))).
  { apply (@ Completeness R_stru); auto. intros. apply AxiomII in H5
    as [_[_[]]]. auto. }
  destruct H4 as [c[]]. unfold Sup. exists c. split.
  - unfold UpperBound. repeat split; auto; intros.
    apply NEexE in H2 as [y]. apply (H5 x y); auto.
  - intros. apply NNPP. intro.
    assert (∀ x0, x0 ∈ S -> x0 ≤ α).
    { intros. apply NNPP; intro. apply H8. exists x0.
      split; auto. apply (@ Order_Co1 R_stru R_axio α x0) in H6 
      as [H6|[]]; auto. destruct H6. contradiction. rewrite H6 in H10.
      elim H10. apply (@ Leq_P1 R_stru); auto. }
    assert (α ∈ Y).
    { apply AxiomII; split; eauto. repeat split; intros; auto. }
    apply NEexE in H0 as []. apply (H5 x α) in H10 as []; auto.
    destruct H7. apply H12. apply (@ Leq_P2 R_stru); auto.
Qed. *)

(* 上确界引理 *)
Lemma SupLemma : ∀ X, X ⊂ ℝ -> X <> Φ -> (∃ c, UpperBound X c) 
  -> exists ! η, Sup X η.
Proof.
  intros. set (Y:=\{ λ u, UpperBound X u \}).
  assert (Y <> Φ).
  { apply NEexE. destruct H1 as [x]. exists x. apply AxiomII;
    split; auto. destruct H1 as [_[]]. unfold Ensemble. exists ℝ; auto. }
  assert (Y ⊂ ℝ).
  { unfold Included; intros. apply AxiomII in H3 as [_].
    destruct H3 as [_[]]. auto. }
  assert (∃ c, c ∈ ℝ /\ (∀ x y, x ∈ X -> y ∈ Y 
    -> (x ≤ c /\ c ≤ y))) as [c[]].
  { apply Completeness; auto. intros. apply AxiomII in H5 as [_].
    destruct H5 as [_[]]. apply H6 in H4; auto. }
  assert (c ∈ Y).
  { apply AxiomII; repeat split; eauto. intros.
    apply NEexE in H2 as [y]. pose proof H5 _ _ H6 H2; tauto. }
  assert (Min \{ λ u, UpperBound X u \} c).
  { red. repeat split; auto. intros y H7. apply NEexE in H0 as [x].
    pose proof H5 _ _ H0 H7. tauto. }
  exists c. split. apply Sup_Corollary. auto. intros.
  apply Sup_Corollary in H8. apply (Min_Corollary Y); auto.
Qed.

(* 下确界引理 *)
Lemma InfLemma : ∀ X, X ⊂ ℝ -> X <> Φ -> (∃ c, LowerBound X c)
  -> exists ! ξ, Inf X ξ.
Proof.
  intros. set(Y:=\{ λ u, LowerBound X u \}).
  assert (Y <> Φ).
  { apply NEexE. destruct H1 as [x]. exists x. apply AxiomII;
    split; auto. destruct H1 as [_[]]. exists ℝ; auto. }
  assert (Y ⊂ ℝ).
  { unfold Included. intros. apply AxiomII in H3 as [].
    destruct H4 as [_[]]; auto. }
  assert (∃ c, c ∈ ℝ /\ (∀ y x, y ∈ Y -> x ∈ X 
    -> y ≤ c /\ c ≤ x)) as [c[]].
  { apply Completeness; auto. intros.
    apply AxiomII in H4 as [_[_[]]]. apply H6 in H5; auto. }
  assert (c ∈ Y).
  { apply AxiomII. repeat split; eauto. intros. 
    apply NEexE in H2 as [y]. pose proof H5 _ _ H2 H6; tauto. }
  assert (Max \{ λ u, LowerBound X u \} c).
  { red. repeat split; auto. intros y H7. apply NEexE in H0 as [x].
    pose proof H5 _ _ H7 H0; tauto. }
  exists c. split. apply Inf_Corollary; auto. intros.
  apply Inf_Corollary in H8. apply (Max_Corollary Y); auto.
Qed.

(* 确界原理 *)
Theorem Sup_Inf_Principle : ∀ X, X ⊂ ℝ -> X <> Φ
  -> ((∃ c, UpperBound X c) -> exists ! η, Sup X η)
  /\ ((∃ c, LowerBound X c) -> exists ! ξ, Inf X ξ).
Proof.
  intros. split; intros.
  - apply SupLemma; auto.
  - apply InfLemma; auto.
Qed.


(* 1.3 函数概念 *)

(* 1.3.1 函数的定义 *)
(* Note ：MK中已经给出 *)

(* 有序数对 *)
(* Definition Ordered x y := [ [x] | [x|y] ].
Notation "[ x , y ]" := (Ordered x y) (at level 0) : MA_R_scope. *)

(* 以有序数对的第一个元为第一坐标 *)
(* Definition First z := ∩∩z. *)

(* 以有序数对的第二个元为第二坐标 *)
(* Definition Second z := (∩∪z)∪(∪∪z) ~ (∪∩z). *)

(* 有序数对相等，对应坐标相等 *)
(* Theorem ProdEqual : ∀ x y u v, Ensemble x -> Ensemble y
  -> ([x, y] = [u, v] <-> x = u /\ y = v).
Proof.
  split; intros; [|destruct H1; subst; auto].
  assert (Ensemble ([x,y])); auto. rewrite H1 in H2.
  apply MKT49b in H2 as [].
  rewrite <-(MKT54a x y), H1,
  <-(MKT54b x y),H1,MKT54a,MKT54b; auto.
Qed. *)

(* 关系 *)
(* Definition Relation r := ∀ z, z ∈ r -> (∃ x y, z = [x, y]). *)

(* 关系的复合及关系的逆 *)
(* Definition Composition r s := \{\ λ x z, ∃ y, [x,y] ∈ s /\ [y,z] ∈ r \}\.
Notation "r ∘ s" := (Composition r s) (at level 50).

Definition Inverse r := \{\ λ x y, [y, x] ∈ r \}\.
Notation "r ⁻¹" := (Inverse r) (at level 5). *)

(* 满足性质P的有序数对构成的集合: { (x,y) : ... } *)
(* Notation "\{\ P \}\" :=
  (\{ λ z, ∃ x y, z = [x,y] /\ P x y \}) (at level 0). *)

(* 分类公理图示II关于有序数对的适应性事实 *)
(* Fact AxiomII' : ∀ a b P,
  [a,b] ∈ \{\ P \}\ <-> Ensemble ([a,b]) /\ (P a b).
Proof.
  split; intros.
  - PP H x y. apply MKT55 in H0 as []; subst; auto; ope.
  - destruct H. appA2G.
Qed. *)

(* 函数 *)
(* Definition Function f := 
  Relation f /\ (∀ x y z, [x,y] ∈ f -> [x,z] ∈ f -> y = z). *)

(* 定义域 *)
(* Definition Domain f := \{ λ x, ∃ y, [x,y] ∈ f \}.
Notation "dom( f )" := (Domain f) (at level 5). *)

(* 值域 *)
(* Definition Range f := \{ λ y, ∃ x, [x,y] ∈ f \}.
Notation "ran( f )" := (Range f) (at level 5). *)

(* f在点x的函数值 *)
(* Definition Value f x := ∩\{ λ y, [x,y] ∈ f \}.
Notation "f [ x ]" := (Value f x) (at level 5). *)

(* 声明函数的定义域和值域都是实数ℝ类型 *)
(* Definition Function f : Prop := dom(f) = ℝ /\ ran(f) ⊂ ℝ. *)

(* 1.3.2 函数的四则运算 *)
Notation "f \+ g" := \{\ λ x y, x ∈ dom(f) /\ x ∈ dom(g) /\ y = f[x] + g[x] \}\
 (at level 45, left associativity).
Notation "f \- g" := \{\ λ x y, x ∈ dom(f) /\ x ∈ dom(g) /\ y = f[x] - g[x] \}\
 (at level 45, left associativity).
Notation "f \· g" := \{\ λ x y, x ∈ dom(f) /\ x ∈ dom(g) /\ y = f[x] · g[x] \}\
 (at level 40, left associativity).
Notation "f \\· n" := \{\ λ x y, x ∈ dom(f) /\ y = f[x] · n \}\
 (at level 40, left associativity).
Notation "f // g" := 
  \{\ λ x y, x ∈ dom(f) /\ x ∈ dom(g) /\ g[x] ≠ 0 /\ y = f[x] / g[x] \}\
  (at level 40, left associativity).
Notation "n /// f" :=
  \{\ λ x y, x ∈ dom(f) /\ f[x] ≠ 0 /\ y = n / f[x] \}\
  (at level 40, left associativity).

(* 1.3.3 复合函数 *)

Definition Comp : ∀ f g, Function f -> Function g -> Function (f ∘ g).
Proof.
  split; intros; unfold Composition. auto.
  appoA2H H1. appoA2H H2. rdeHex. destruct H0.
  apply H with x0; auto. rewrite (H7 x x0 x1); auto.
Qed.

(* 复合函数完整条件定义 *)
(* Definition Comp f g := ∀ f g x u, Function f -> Function g
  -> x ∈ dom(g) /\ g[x] ∈ dom(f)
  /\ u = g[x] /\ (f ∘ g)[x] = f[u] /\ dom(f ∘ g) = 
  (\{ λ x, g[x] ∈ dom(f) \} ∩ dom(g)) /\ dom(f ∘ g) <> Φ. *)

(* Definition Comp (f g : Fun) := ∀(f g : Fun) (x u : R), x ∈ dom[g] /\
g[x] ∈ dom[f] /\ u = g[x] /\ (f ∘ g) [x] = f[u]/\ dom[(f ∘ g)] =
(\{ λ x : R, (g [x] ∈ dom[f]) \} ∩ dom[g]) /\ NotEmpty dom[(f ∘ g)]. *)

(* 1.3.4 反函数 *)

Definition Inverse_Fun f g := Function1_1 f /\ g = f⁻¹.

Corollary Inverse_Co1 : ∀ f u, Function f -> Function f⁻¹ -> u ∈ dom(f)
  -> (f⁻¹)[f[u]] = u.
Proof.
  intros. apply Property_Value,invp1,Property_Fun in H1; auto.
Qed.

Corollary Inverse_Co2: ∀ f u, Function f -> Function f⁻¹ -> u ∈ ran(f)
  -> f[(f⁻¹)[u]] = u.
Proof.
  intros. rewrite reqdi in H1. apply Property_Value in H1; auto.
  apply ->invp1 in H1; auto. apply Property_Fun in H1; auto.
Qed.

(* 1.4 具有某些特性的函数 *)

(* 1.4.1 有界函数 *)

Definition BoundedUp_Fun f D :=
  Function f /\ D = dom(f) /\ (∃ M, M ∈ ℝ /\ ∀ x, x ∈ D -> f[x] ≤ M).

Definition BoundedLow_Fun f D :=
  Function f /\ D = dom(f) /\ (∃ L, L ∈ ℝ /\ ∀ x, x ∈ D -> L ≤ f[x]).

(* D上的有界函数 *)
Definition DBoundedFun f D := Function f /\ D ⊂ dom(f)
  /\ (∃ M, M ∈ ℝ /\ 0 < M /\ (∀ x, x ∈ D -> ｜(f[x])｜ ≤ M)).

(* 1.4.2 单调函数 *)

(* 单调函数 *)
Definition MonoInc_Fun f := Function f
  /\ (∀ x1 x2, x1 ∈ dom(f) -> x2 ∈ dom(f) -> x1 < x2 -> f[x1] ≤ f[x2]).
Definition StrictMonoInc_Fun f := Function f
  /\ (∀ x1 x2, x1 ∈ dom(f) -> x2 ∈ dom(f) -> x1 < x2 -> f[x1] < f[x2]).
Definition MonoDec_Fun f := Function f
  /\ (∀ x1 x2, x1 ∈ dom(f) -> x2 ∈ dom(f) -> x1 < x2 -> f[x2] ≤ f[x2]).
Definition StrictMonoDec_Fun f := Function f
  /\ (∀ x1 x2, x1 ∈ dom(f) -> x2 ∈ dom(f) -> x1 < x2 -> f[x2] < f[x1]).

(* D上的单调函数 *)
Definition DMonoInc_Fun f D := Function f /\ D ⊂ dom(f)
  /\ (∀ x1 x2, x1 ∈ D -> x2 ∈ D -> x1 < x2 -> f[x1] ≤ f[x2]).
Definition DStrictMonoInc_Fun f D := Function f /\ D ⊂ dom(f)
  /\ (∀ x1 x2, x1 ∈ D -> x2 ∈ D -> x1 < x2 -> f[x1] < f[x2]).
Definition DMonoDec_Fun f D := Function f /\ D ⊂ dom(f)
  /\ (∀ x1 x2, x1 ∈ D -> x2 ∈ D -> x1 < x2 -> f[x2] ≤ f[x1]).
Definition DStrictMonoDec_Fun f D := Function f /\ D ⊂ dom(f)
  /\ (∀ x1 x2, x1 ∈ D -> x2 ∈ D -> x1 < x2 -> f[x2] < f[x1]).
Definition DMonotonicFun f D := DMonoInc_Fun f D \/ DMonoDec_Fun f D.

Theorem Theorem1_2a : ∀ f, Function f -> dom(f) ⊂ ℝ -> ran(f) ⊂ ℝ
  -> StrictMonoInc_Fun f -> StrictMonoInc_Fun f⁻¹.
Proof.
  intros; unfold StrictMonoInc_Fun in *. destruct H2 as [H2 H3].
  assert (Function f⁻¹).
  { unfold Function in *. unfold Relation in *. destruct H as []; split.
    - intros. apply AxiomII in H5 as [H5 [x[y]]]. exists x, y; tauto.
    - intros. apply AxiomII' in H5 as []; apply AxiomII' in H6 as [].
      assert (y ∈ ℝ).
      { unfold Included in H0. apply H0. apply AxiomII; split.
        apply MKT49c2 in H5; auto. exists x; auto. }
      assert (z ∈ ℝ).
      { apply H0. apply Property_dom in H8; auto. }
      New H7. New H8. apply Property_dom in H11, H12; auto.
      destruct (Order_Co1 y z) as [H13 | [|]]; auto.
      + apply H3 in H13; auto.
        assert (x = f[y] /\ x = f[z]) as [].
        { split; [apply (H4 y)|apply (H4 z)]; auto;
          apply Property_Value; auto. }
        rewrite <-H14, <-H15 in H13. destruct H13. elim H16. auto.
      + apply H3 in H13; auto.
        assert (x = f[y] /\ x = f[z]) as [].
        { split; [apply (H4 y)|apply (H4 z)]; auto;
          apply Property_Value; auto. }
        rewrite <-H14, <-H15 in H13. destruct H13. elim H16. auto. }
  split; auto; intros.
  - New H5; New H6. apply Property_Value,Property_ran in H8, H9; auto.
    rewrite <-deqri in H8, H9.
    destruct (Order_Co1 (f⁻¹)[x1] (f⁻¹)[x2])
    as [H10 | [|]]; auto.
    + apply H3 in H10; auto. rewrite f11vi in H10, H10; auto;
      try rewrite reqdi; auto. destruct H7, H10. elim H12.
      rewrite <-reqdi in H5, H6. apply Leq_P2; auto.
    + assert (f[(f ⁻¹)[x1]] = f[(f ⁻¹)[x2]]). { rewrite H10. auto. }
      rewrite <-reqdi in H5, H6. rewrite f11vi in H11, H11; auto.
      destruct H7. elim H12; auto.
Qed.

Theorem Theorem1_2b : ∀ f, Function f -> dom(f) ⊂ ℝ -> ran(f) ⊂ ℝ 
  -> StrictMonoDec_Fun f -> StrictMonoDec_Fun f⁻¹.
Proof.
  intros. unfold StrictMonoDec_Fun in *. destruct H2 as [].
  assert (Function f⁻¹).
  { unfold Function in *. unfold Relation in *. destruct H as []; split.
    + intros. apply AxiomII in H5 as [H5 [x[y]]]. exists x, y; tauto.
    + intros. apply AxiomII' in H5 as [], H6 as [].
      New H7; New H8. apply Property_dom in H9, H10.
      destruct (Order_Co1 y z) as [H11 | [|]]; auto.
      * apply H3 in H11; auto.
        assert (x = f[z] /\ x = f[y]) as [].
        { split; [apply (H4 z)|apply (H4 y)]; auto;
          apply Property_Value; auto. }
        rewrite <-H12, <-H13 in H11. destruct H11. elim H14. auto.
      * apply H3 in H11; auto.
        assert (x = f[z] /\ x = f[y]) as [].
        { split; [apply (H4 z)|apply (H4 y)]; auto;
          apply Property_Value; auto. }
        rewrite <-H12, <-H13 in H11. destruct H11. elim H14. auto. }
  split; auto; intros.
  - New H5; New H6. apply Property_Value,Property_ran in H8, H9; auto.
    rewrite <-deqri in H8, H9.
    destruct (Order_Co1 (f⁻¹)[x2] (f⁻¹)[x1]) 
    as [H10 | [|]]; auto.
    + apply H3 in H10; auto. rewrite f11vi in H10, H10; auto;
      rewrite <-reqdi in H5, H6; auto. destruct H7, H10. elim H11.
      apply Leq_P2; auto.
    + assert (f[(f ⁻¹)[x2]] = f[(f ⁻¹)[x1]]). { rewrite H10. auto. }
      rewrite <-reqdi in H5, H6. rewrite f11vi in H11, H11; auto.
      destruct H7. elim H12; auto.
Qed.

(* 1.4.3 奇函数和偶函数 *)

(* 奇函数 *)
Definition OddFun f := Function f /\ dom(f) ⊂ ℝ /\ ran(f) ⊂ ℝ
  /\ (∀ x, x ∈ dom(f) -> f[-x] = -f[x]).

(* 偶函数 *)
Definition EvenFun f := Function f /\ dom(f) ⊂ ℝ /\ ran(f) ⊂ ℝ
  /\ (∀ x, x ∈ dom(f) -> f[-x] = f[x]).

(* 1.4.4 周期函数 *)
Definition PeriodicFun f := Function f /\ (∃ σ, σ ∈ ℝ /\ 0 < σ 
  /\ (∀ x, x ∈ dom(f) -> (x + σ ∈ dom(f) -> f[x + σ] = f[x])
    /\ (x - σ ∈ dom(f) -> f[x - σ] = f[x]))).

(* ℂ ℕ ℝ ℚ ℤ *)
(* 2 数列极限 *)

(* 2.1 数列极限 *)

(* 定义：数列 *)
Definition Seq f := Function f /\ dom(f) = ℕ /\ ran(f) ⊂ ℝ.

(* 定义1：数列极限 *)
Definition Limit_Seq x a := Seq x /\ (∀ ε, ε ∈ ℝ /\ 0 < ε
  -> (∃ N, N ∈ ℕ /\ (∀ n, n ∈ ℕ -> N < n -> ｜(x[n] - a)｜ < ε))).

(* 定义1' 数列极限的邻域刻画 *)
Definition Limit_Seq' x a := Seq x /\ (∀ ε, ε ∈ ℝ /\ 0 < ε
  -> Finite \{ λ u, u ∈ ℕ /\ x[u] ∉ U(a; ε) \}).

Theorem MathInd_Ma : ∀ E, E ⊂ ℕ -> 1 ∈ E
  -> (∀ x, x ∈ E -> (x + 1) ∈ E) -> E = ℕ.
Proof.
  intros. assert (IndSet E).
  { split; auto. unfold Included; intros. apply N_Subset_R; auto. }
  apply MKT27; split; auto. unfold Included; intros.
  apply AxiomII in H3 as []. apply H4. apply AxiomII; split; auto.
  apply (MKT33 ℕ); auto. apply (MKT33 ℝ).
  apply Ensemble_R; auto. apply N_Subset_R; auto.
Qed.

Corollary N_NLe_Gt : ∀ n m, n ∈ ℕ -> m ∈ ℕ -> ~ (n ≤ m) <-> (m < n).
Proof.
  intros. apply N_Subset_R in H, H0. split; intros.
  - apply NNPP; intro. destruct (Leq_P4 m n); auto.
    destruct (classic (m = n)).
    + elim H1. rewrite H4. apply Leq_P1; auto.
    + elim H2. split; auto.
  - destruct H1. intro. elim H2. apply Leq_P2; auto.
Qed.

Fact N_NLt_Ge : ∀ n m, n ∈ ℕ -> m ∈ ℕ -> ~ (m < n) <-> n ≤ m.
Proof.
  intros. apply N_Subset_R in H, H0. split; intros.
  - apply NNPP; intro. destruct (Leq_P4 m n); auto.
    destruct (classic (m = n)).
    + elim H2; rewrite H4; apply Leq_P1; auto.
    + elim H1; split; auto.
  - intro. destruct H2. elim H3. apply Leq_P2; auto.
Qed.

Corollary Nat_P4a: ∀ m n, m ∈ ℕ -> n ∈ ℕ -> (n + 1) ≤ m -> n < m.
Proof.
  intros. apply N_Subset_R in H as Ha, H0 as Hb.
  assert (n < n + 1).
  { apply (Leq_P1 n) in Hb as Hc. destruct OrderPM_Co9.
    apply (OrderPM_Co3 _ _ 0 1) in Hc; auto with real.
    rewrite Plus_P1 in Hc; auto. split; auto. intro.
    assert (n - n = n + 1 - n). { rewrite <-H4; auto. }
    rewrite Minus_P1, (Plus_P4 n), <-Plus_P3, Plus_neg2, Plus_P1 in H5;
    auto with real. }
  destruct H2. split.
  - apply (Leq_P3 _ (n + 1) _); auto with real.
  - intro. rewrite <-H4 in H1. elim H3. apply Leq_P2; auto with real.
Qed.

Corollary Nat_P4b : ∀ m n, m ∈ ℕ -> n ∈ ℕ -> n ≤ m -> n < m + 1.
Proof.
  intros. apply N_Subset_R in H as Ha, H0 as Hb.
  assert (m < m + 1).
  { apply (Leq_P1 m) in Ha as Hc. destruct OrderPM_Co9.
    apply (OrderPM_Co3 _ _ 0 1) in Hc; auto with real.
    rewrite Plus_P1 in Hc; auto. split; auto. intro.
    assert (m - m = m + 1 - m). { rewrite <-H4; auto. }
    rewrite Minus_P1, (Plus_P4 m), <-Plus_P3, Plus_neg2, Plus_P1 in H5;
    auto with real. }
  destruct H2. split.
  - apply (Leq_P3 _ m _); auto with real.
  - intro. rewrite H4 in H1. elim H3. apply Leq_P2; auto with real.
Qed.

(* 小于等于某个数的自然数集为非空有限集 *)
Theorem NatFinite : ∀ n, n ∈ ℕ -> Finite \{ λ u, u ∈ ℕ /\ u ≤ n \}
  /\ \{ λ u, u ∈ ℕ /\ u ≤ n \} <> Φ.
Proof.
  intros. split.
  - set (F := \{ λ u, u ∈ ℕ /\ Finite \{ λ v, v ∈ ℕ /\ v ≤ u \} \}).
    assert (F = ℕ).
    { apply MathInd_Ma; auto; unfold Included; intros.
      apply AxiomII in H0 as [_[]]; auto.
      - apply AxiomII; repeat split; eauto with real.
        assert (\{ λ v, v ∈ ℕ /\ v ≤ 1 \} = [1]).
        { apply AxiomI; split; intros.
          - apply AxiomII in H0 as [H0 []]. apply MKT41; eauto with real.
            apply Leq_P2; auto with real.
            apply NNPP; intro. destruct (classic (z = 1)).
            + elim H3. rewrite H4. apply Leq_P1; auto with real.
            + destruct one_is_min_in_N as [H5 []]. pose proof H1.
              apply H7 in H8. elim H4. apply Leq_P2; auto with real.
          - apply MKT41 in H0; eauto with real. rewrite H0.
            apply AxiomII; repeat split; eauto with real. 
            apply Leq_P1; apply one_in_R_Co. }
        rewrite H0. apply finsin; eauto with real.
      - apply AxiomII in H0 as [H0 []]. pose proof IndSet_N as Ha. 
        apply AxiomII; repeat split; eauto with real.
        assert (\{ λ v, v ∈ ℕ /\ v ≤ x + 1 \} 
          = \{ λ v, v ∈ ℕ /\ v ≤ x \} ∪ [x + 1]).
          { apply AxiomI; split; intros.
            - apply AxiomII in H3 as [H3 []]. apply MKT4.
              destruct (classic (z = x + 1)).
              + right. apply MKT41; eauto with real.
              + left. apply AxiomII; repeat split; auto.
                assert (z < x + 1). split; auto.
                apply Nat_P4 in H7; auto with real.
                apply Plus_Leq with (z:=-(1)) in H7; auto with real.
                rewrite <-Plus_P3, <-Plus_P3 in H7; auto with real.
                rewrite Minus_P1, Minus_P1 in H7; auto with real.
                rewrite Plus_P1, Plus_P1 in H7; auto with real.
            - apply MKT4 in H3 as [].
              + apply AxiomII in H3 as [H3 []].
                apply AxiomII; repeat split; auto.
                assert (z + 0 ≤ x + 1).
                { apply OrderPM_Co3; try apply OrderPM_Co9; auto with real. }
                rewrite Plus_P1 in H6; auto with real.
              + apply MKT41 in H3; eauto with real. rewrite H3.
                apply AxiomII; repeat split; eauto with real.
                apply Leq_P1; auto with real. }
          rewrite H3. apply MKT168; auto. apply finsin; eauto with real. }
    rewrite <-H0 in H. apply AxiomII in H as [H []]; auto.
  - apply NEexE. exists 1. apply AxiomII; repeat split; eauto with real.
    pose proof one_is_min_in_N. destruct H0 as [H0 []]. apply H2; auto.
Qed.

 (* 非空有限的实数集有最大值 (非空有限的自然数集有最大值易证: 自然数集是实数集的子集) *)
Theorem finite_maxR : ∀ A, A <> Φ -> Finite A -> A ⊂ ℝ
  -> (∃ r, Max A r).
Proof.
  set (p := fun m => ∀ A, P[A] = m -> A ≠ Φ -> A ⊂ ℝ
    -> ∃ r, Max A r).
  assert (∀ m, m ∈ ω -> p m).
  { apply Mathematical_Induction; unfold p; intros.
    - apply carE in H. contradiction.
    - destruct (classic (∃ a, A = [a])).
      + destruct H4 as [a]. New H3; rewrite H4 in H5.
        assert (Ensemble a).
        { apply MKT42'. apply MKT33 in H5; auto. apply Ensemble_R. }
        exists a; repeat split; auto.
        * rewrite H4. apply MKT41; auto.
        * intros. New H7; rewrite H4 in H8. apply MKT41 in H8; auto.
          rewrite H8. apply Leq_P1; auto.
      + New H2; apply NEexE in H5 as [a].
        assert (A = (A ~ [a]) ∪ [a]).
        { apply AxiomI; split; intros.
          * destruct (classic (z = a)).
            - apply AxiomII; split; eauto. right. rewrite <-H7.
              apply MKT41; eauto.
            - apply AxiomII; split; eauto. left.
              apply AxiomII; repeat split; eauto. apply AxiomII; split; eauto.
              intro. apply MKT41 in H8; eauto.
          * apply MKT4 in H6 as [H6|H6].
            - apply AxiomII in H6; tauto.
            - apply MKT41 in H6; eauto. rewrite H6; auto. }
        (* assert ((A ~ [a]) <> Φ).
        { (* intro. assert (~(∃ x, x ∈ A /\ x ∉ [a])).
          { assert (∀ x, ~ (x ∈ A /\ x ∉ [a])). apply not }
        
         
          { intro. apply notandor. destruct (classic (x ∈ A)); auto.
            right. intro. elim H9.  }
         elim H4. apply MKT27 in H6. exists a. apply AxiomI; split; intros.
           apply MKT41; eauto. *) admit.  }
        destruct H6.
        assert (Finite (A ~ [a])). admit.
        (* assert (P[A ~ [a]] = k). *) Search (Finite).
        Search (PlusOne).
        assert (P[(A ~ [a]) ∪ [a]] = PlusOne P[A ~ [a]]).
        { apply finue; eauto. intro. apply AxiomII in H9 as [_[_]].
          apply AxiomII in H9 as []. elim H10. apply MKT41; eauto. }
        rewrite <-H6, H1 in H9. apply MKT136 in H9; auto.
        assert (A ~ [a] ⊂ ℝ).
        { red; intros. apply AxiomII in H10 as [_[H10 _]]; auto. }
        symmetry in H9. apply H0 in H9; auto.
        destruct H9 as [b [H9 []]]. (* 比较a和b *)
        assert (b ≤ a \/ a ≤ b) as [|].
        { apply Leq_P4; auto. }
        * exists a. repeat split; auto. intros. rewrite H6 in H14.
          apply MKT4 in H14 as [|].
          -- New H14. apply H12 in H15. 
             apply Leq_P3 with b; auto.
          -- apply MKT41 in H14; eauto. rewrite H14.
             apply Leq_P1; eauto.
        * exists b. pose proof H11; apply MKT4' in H14 as [].
          repeat split; auto; intros. rewrite H6 in H16.
          apply MKT4 in H16 as [|]; auto.
          apply MKT41 in H16; eauto. rewrite H16; auto. }
  intros. red in H1. apply H in H1; auto.
  assert () *)
Admitted. 

(* 非空有限的自然数集有最大值 *)
Theorem finite_maxN : ∀ A, A <> Φ -> Finite A -> A ⊂ ℕ
  -> (∃ r, Max A r).
Proof.
  intros. assert (A ⊂ ℝ).
  { unfold Included; intros; apply N_Subset_R; auto. }
  apply finite_maxR; auto.
Qed.

(* 两种极限定义等价 *)
Theorem Limit_Equal : ∀ x a, Seq x -> a ∈ ℝ 
  -> Limit_Seq x a <-> Limit_Seq' x a.
Proof.
  intros. unfold Limit_Seq; unfold Limit_Seq'. split; intros.
  - destruct H1 as [Ha H1]. split; auto. intros.
    apply H1 in H2 as H3. destruct H3 as [N []].
    (* set写法 *)
    assert (∀ n, n ∈ ℕ -> ∃ A, A = \{ λ u, u ∈ ℕ /\ u ≤ n \}).
    { intros. exists \{ λ u, u ∈ ℕ /\ u ≤ n \}. auto. }
    New H3. apply H5 in H3. destruct H3 as [A].
    assert (\{ λ u, u ∈ ℕ /\ x[u] ∉ U(a; ε) \} ⊂ A).
    { intros z H7. apply AxiomII in H7 as [H8 []]. rewrite H3.
      apply AxiomII; repeat split; auto. apply NNPP; intro.
      apply N_NLe_Gt in H10; auto. apply H4 in H10; auto.
      elim H9. destruct Ha as [Ha []].
      assert (x[z] ∈ ran(x)).
      { apply Property_dm; auto. rewrite H11; auto. }
      destruct H10. apply AxiomII; repeat split; eauto. }
    apply @ finsub with (A:= A); auto. rewrite H3. apply NatFinite; auto.
  - destruct H1 as [Ha H1]. split; auto.
    intros ε H2. pose proof H2 as Hb. 
    apply H1 in H2. apply finite_maxN in H2.
    destruct H2 as [N [H2 []]]. apply AxiomII in H3 as [H3 []].
    exists N; split; auto. intros. apply NNPP; intro.
    assert (n ∈ \{ λ u, u ∈ ℕ /\ x[u] ∉ U(a;ε) \}).
    { apply AxiomII; repeat split; eauto. 
      intro. apply AxiomII in H10 as [H10 []]. contradiction. }
    apply H4 in H10. apply N_NLt_Ge in H10; auto.
    * apply NEexE. admit.
Admitted.

(* Theorem finite_maxN : ∀ A, A <> Φ -> Finite A -> A ⊂ ℕ
  -> (∃ r, maxR A r). *)
(* Definition Seq f := Function f /\ dom(f) = ℕ /\ ran(f) ⊂ ℝ. *)

(* 收敛数列 *)
Definition Conv_Seq x := ∃ a, a ∈ ℝ /\ Limit_Seq x a.

(* 发散数列 *)
Definition Div_Seq x := Seq x /\ (∀ a, a ∈ ℝ -> ~ Limit_Seq x a).

(* 定义2：无穷小数列 *)
Definition InfSmall_Seq x := Limit_Seq x 0.  

(* 定理2.1 *)
Theorem Theorem2_1 : ∀ x a, a ∈ ℝ -> Seq x -> Limit_Seq x a  
  <-> InfSmall_Seq \{\ λ u v, u ∈ ℕ /\ v ∈ ℝ /\ v = x[u] - a \}\.
Proof.
  split; intros.
  - unfold InfSmall_Seq. unfold Limit_Seq in *. destruct H1 as [H1 H2].
    assert (Seq \{\ λ u v, u ∈ ℕ /\ v ∈ ℝ /\ v = x[u] - a \}\).
    { unfold Seq in *. destruct H1 as [H1 []]. repeat split.
      - unfold Relation. intros. apply AxiomII in H5 as [].
        destruct H6 as [x0 [y []]]. exists x0,y. auto.
      - intros. apply AxiomII' in H5 as [], H6 as [].
        destruct H7 as [H7 []], H8 as [H8 []]. subst; auto.
      - apply AxiomI; split; intros.
        + apply AxiomII in H5 as [H5 [y]].
          apply AxiomII' in H6 as [H6 [H7 []]]; auto.
        + assert ((x[z] - a) ∈ ℝ).
          { apply Plus_close; auto. apply H4.
            apply (@ Property_ran z), Property_Value; auto. rewrite H3; auto.
            apply Plus_neg1a; auto. }
          apply AxiomII; split; eauto. exists (x[z] - a).
          apply AxiomII'; repeat split; auto; apply MKT49a; eauto.
      - unfold Included; intros. apply AxiomII in H5 as [H5 [x0]].
        apply AxiomII' in H6 as [H6 [H7 []]]; auto. }
    split; auto.
    intros. pose proof H4. destruct H5. apply H2 in H4. destruct H4 as [N []]. 
    exists N. split; auto. intros. apply H7 in H9; auto.
    destruct H1 as [H1 []]; destruct H3 as [H3 []].
    assert ((x[n] - a) ∈ ℝ).
    { apply Plus_close; auto. apply H11.
      apply (@ Property_ran n),Property_Value; auto. rewrite H10; auto.
      apply Plus_neg1a; auto. }
    assert (x[n] - a = \{\ λ u v, u ∈ ℕ /\ v ∈ ℝ /\ v = x[u] - a \}\ [n]).
    { apply Property_Fun; auto. apply AxiomII'; repeat split; auto.
      apply MKT49a; eauto. }
    assert (\{\ λ u v, u ∈ ℕ /\ v ∈ ℝ /\ v = x[u] - a \}\ [n] ∈ ℝ).
    { apply H13. apply (@ Property_ran n), Property_Value; auto.
      rewrite H12; auto. }
    rewrite Minus_P2; auto. rewrite <-H15; auto.
  - unfold InfSmall_Seq in H1; unfold Limit_Seq in *; split; auto.
    destruct H1. destruct H1 as [H1 []]. intros. apply H2 in H5.
    destruct H5 as [N []]. exists N; split; auto. intros.
    assert ((x[n] - a) ∈ ℝ).
    { apply Plus_close; auto. destruct H0 as [H0 []]. apply H10.
      apply (@ Property_ran n), Property_Value; auto.
      rewrite H9; auto. apply Plus_neg1a; auto. }
    apply H6 in H8; auto. rewrite Minus_P2 in H8.
    assert (x[n] - a = \{\ λ u v, u ∈ ℕ /\ v ∈ ℝ /\ v = x[u] - a \}\ [n]).
    { apply Property_Fun; auto. apply AxiomII'; repeat split; auto.
      apply MKT49a; eauto. }
    rewrite <-H10 in H8; auto. apply H4. apply (@ Property_ran n),
    Property_Value; auto. rewrite H3; auto.
Qed.

(* 定义3：无穷大数列 *)
Definition InfBig_Seq x := Seq x /\ (∀ M, M ∈ ℝ /\ 0 < M
  -> (∃ N, N ∈ ℕ /\ (∀ n, n ∈ ℕ -> N < n -> M < ｜(x[n])｜))).

(* 定义4：正无穷大数列 *)
Definition PosInf_Seq x := Seq x /\ (∀ M, M ∈ ℝ /\ 0 < M
  -> (∃ N, N ∈ ℕ /\ (∀ n, n ∈ ℕ -> N < n -> M < x[n]))).

(* 定义5：负无穷大数列 *)
Definition NegInf_Seq x := Seq x /\ (∀ M, M ∈ ℝ /\ 0 < M
  -> (∃ N, N ∈ ℕ /\ (∀ n, n ∈ ℕ -> N < n -> x[n] < -M))).
  
(* 2.2 收敛数列性质 *)

Corollary Minus_P3 : ∀ x y, x ∈ ℝ -> y ∈ ℝ -> - (x + y) = (- x) + (- y).
Proof.
  intros. assert ((- (1)) ∈ ℝ). 
  { apply Plus_neg1a; auto. apply one_in_R_Co; auto. }
  assert ((- (1)) · x ∈ ℝ).
  { rewrite <-PlusMult_Co3; auto. apply Plus_neg1a; auto. }
  assert (y · (-(1)) ∈ ℝ); auto with real.
  (* { rewrite Mult_P4, <-PlusMult_Co3; auto. apply Plus_neg1a; auto. }  *)
  rewrite PlusMult_Co3, Mult_P4; auto with real.
  rewrite Mult_P5, Mult_P4, Plus_P4, Mult_P4; auto. symmetry.
  rewrite PlusMult_Co3, Plus_P4, PlusMult_Co3; auto with real.
Qed.

Corollary Minus_P4 : ∀ x, x ∈ ℝ -> - - x = x.
Proof.
  intros. rewrite PlusMult_Co3; auto with real.
  apply PlusMult_Co4; auto.
Qed.

Corollary RMult_Eq : ∀ x y z, x ∈ ℝ -> y ∈ ℝ -> z ∈ ℝ -> 
  x = y -> x · z = y · z.
Proof.
  intros. rewrite H2; auto.
Qed.

Corollary RMult_Eq' : ∀ x y z, x ∈ ℝ -> y ∈ ℝ -> z ∈ (ℝ ~ [0]) ->
  x · z = y · z -> x = y.
Proof.
  intros. New H1; apply MKT4' in H1 as [].
  assert (z⁻ ∈ (ℝ ~ [0])). { apply Mult_inv1; auto. }
  apply MKT4' in H5 as [].
  apply RMult_Eq with (z:= z⁻) in H2; auto with real.
  do 2 rewrite <-Mult_P3 in H2; auto.
  rewrite Divide_P1 in H2; auto. do 2 rewrite Mult_P1 in H2; auto.
Qed. 

(* 定理2.2: 唯一性 *)
Theorem Theorem2_2 : ∀ x a b, Seq x -> a ∈ ℝ -> b ∈ ℝ
  -> Limit_Seq x a -> Limit_Seq x b -> a = b.
Proof.
  intros. apply NNPP; intro. apply Limit_Equal in H2 as Ha; auto. 
  assert (((Abs[b-a])/ (1 + 1)) ∈ ℝ  /\ 0 < ((Abs[b-a])/ (1 + 1))).
  { assert (0 < (1 + 1)) as Hb.
    { apply (Order_Co2 _ 1); auto with real.
      left; split; pose proof OrderPM_Co9; auto.
      apply (OrderPM_Co1 _ _ 1) in H5; auto with real.
      rewrite Plus_P4, Plus_P1 in H5; auto with real. destruct H5; auto. }
    assert ((1 + 1) ⁻ ∈ (ℝ ~ [0])) as Hc.
    { apply Mult_inv1. apply MKT4'; split; auto with real.
      apply AxiomII; split; eauto with real.
      intro. apply MKT41 in H5; eauto with real.
      rewrite H5 in Hb. destruct Hb. contradiction. }
    split.
    - apply Mult_close; auto with real. apply MKT4' in Hc; tauto.
    - assert (a ≤ b \/ b ≤ a). { destruct (Leq_P4 a b); auto. }
      destruct H5 as [|].
      + apply Plus_Leq with (z:=(-a)) in H5 as H6; auto with real. 
        rewrite Minus_P1 in H6; auto.
        assert (｜(b - a)｜ = (b - a)). { apply me_zero_Abs; auto with real. }
        rewrite H7. apply OrderPM_Co5; auto with real. apply MKT4' in Hc; tauto.
        left; split.
        * assert (a < b). { split; auto. }
          apply (OrderPM_Co1 _ _ (-a)) in H8; auto with real.
          rewrite Minus_P1 in H8; auto.
        * apply OrderPM_Co10; auto with real.
      + apply Plus_Leq with (z:=(-a)) in H5 as H6; auto with real.
        rewrite Minus_P1 in H6; auto; New H6. 
        apply le_zero_Abs in H7; auto with real.
        assert (｜(b - a)｜ = (- (b - a))). 
        { apply le_zero_Abs; auto with real. }
        assert ((- (b - a)) = (- b + a)).
        { rewrite Minus_P3; auto with real. rewrite Minus_P4; auto. }
        assert ((- b) + a = a + (- b)). { rewrite Plus_P4; auto with real. }
        rewrite H10 in H9. rewrite H9 in H8. rewrite H8.
        apply MKT4' in Hc as []. apply OrderPM_Co5; auto with real.
        left; split; New H5.
        * apply (Plus_Leq _ _ (-b)) in H13; auto with real.
          rewrite Minus_P1 in H13; auto.
          assert (b < a). { split; auto. }
          apply (OrderPM_Co1 _ _ (-b)) in H14; auto with real.
          rewrite Minus_P1 in H14; auto.
        * apply OrderPM_Co10; auto with real. } 
  destruct Ha as []. pose proof H5; destruct H5 as [].
  pose proof H8 as Hz; apply H7 in H8.
  assert (\{ λ u, u ∈ ℕ /\ x[u] ∈ U(b; (｜(b - a)｜ / (1 + 1))) \} ⊂ 
    \{ λ u, u ∈ ℕ /\ x[u] ∉ U(a; (｜(b - a)｜ / (1 + 1)))\} ).
  { unfold Included; intros. apply AxiomII in H10 as [_[]]. 
    apply AxiomII; repeat split; eauto.
    intro. apply AxiomII in H11 as [H11 []];
    apply AxiomII in H12 as [_[_]]. destruct H9, H14, H12.
    apply Abs_P4 in H14 as [], H12 as []; auto with real.
    assert (0 ≤ (b - a) \/ (b - a) ≤ 0).
    { destruct (Leq_P4 (b-a) 0) as [|]; auto with real. }
    assert (｜(b - a)｜ = b - a \/ ｜(b - a)｜ = a - b).
    { destruct H20 as [|].
      - left. apply me_zero_Abs; auto with real.
      - right. assert (｜(b - a)｜ = (- (b - a))). 
        { apply le_zero_Abs; auto with real. }
        assert ((- (b - a)) = (- b + a)).
        { rewrite Minus_P3, Minus_P4; auto with real. }
        rewrite H21; rewrite H22; apply Plus_P4; auto with real. }
    assert (0 < (1 + 1)) as Ha.
    { apply (Order_Co2 _ 1); auto with real.
      left; split; New OrderPM_Co9; auto.
      apply (OrderPM_Co1 _ _ 1) in H22; auto with real.
      rewrite Plus_P4, Plus_P1 in H22; auto with real. destruct H22; auto. } 
    assert ((1 + 1) ⁻ ∈ (ℝ ~ [0])) as Hb.
    { apply Mult_inv1. apply MKT4'; split; auto with real.
      apply AxiomII; split; eauto with real.
      intro. apply MKT41 in H22; eauto with real.
      rewrite H22 in Ha. destruct Ha; contradiction. }
    pose proof Hb as Hc; apply MKT4' in Hc as [Hd He].
    assert (a = ((1 + 1) · a) / (1 + 1)) as Hf.
    { assert (a · (1 + 1) = (1 + 1) · a).
      { rewrite Mult_P4; auto with real. }
      apply RMult_Eq with (z:=(1 + 1)⁻) in H22; auto with real.
      rewrite <-Mult_P3, Divide_P1, Mult_P1 in H22; auto with real.
      apply MKT4'; split; auto with real.
      apply AxiomII; split; eauto with real. 
      intro. apply MKT41 in H23; eauto with real.
      rewrite H23 in Ha; destruct Ha; eauto. }
    assert (b = ((1 + 1) · b) / (1 + 1)) as Hg.
    { assert (b · (1 + 1) = (1 + 1) · b).
      { apply Mult_P4; auto with real. }
      apply RMult_Eq with (z:=(1 + 1)⁻) in H22; auto with real.
      rewrite <-Mult_P3, Divide_P1, Mult_P1 in H22; auto with real.
      apply MKT4'; split; auto with real.
      apply AxiomII; split; eauto with real.
      intro. apply MKT41 in H23; eauto with real.
      rewrite H23 in Ha; destruct Ha; contradiction. }
    assert ((1 + 1) · a = a + a) as Hh.
    { rewrite Mult_P5, Mult_P4, Mult_P1; auto with real. }
    assert ((1 + 1) · b = b + b) as Hi.
    { rewrite Mult_P5, Mult_P4, Mult_P1; auto with real. }
    destruct H21 as [|].
    - rewrite H21 in *.
      (* b - ε *)
      apply (Plus_Leq _ _ b) in H14; auto with real;
      rewrite <-Plus_P3, (Plus_P4 (- b)), Minus_P1, Plus_P1 in H14; 
      auto with real.
      pattern b at 2 in H14; rewrite Hg in H14.
      rewrite PlusMult_Co3, Mult_P3, <-Mult_P5 in H14; auto with real.
      rewrite <-PlusMult_Co3, Minus_P3, Minus_P4 in H14; auto with real.
      rewrite Hi, Plus_P4, <-Plus_P3, Plus_P4 in H14; auto with real.
      rewrite Plus_P3, Plus_neg2, (Plus_P4 0), Plus_P1 in H14; auto with real.
      (* a + ε *) 
      apply (Plus_Leq _ _ a) in H19; auto with real; 
      rewrite <-Plus_P3, (Plus_P4 (-a)), Minus_P1, Plus_P1 in H19;
      auto with real.
      pattern a at 2 in H19; rewrite Hf in H19.
      rewrite <-Mult_P5, Hh in H19; auto with real.
      rewrite Plus_P4, (Plus_P4 b), Plus_P3 in H19; auto with real.
      rewrite <-(Plus_P3 a), Plus_neg2, Plus_P1 in H19; auto with real.
      (* elim *)
      assert (x [z] = (a + b) · ((1 + 1) ⁻)).
      { apply Leq_P2; auto with real. }
      elim H17. rewrite H22. pattern a at 2; rewrite Hf.
      rewrite PlusMult_Co3, Mult_P3, <-Mult_P5; auto with real.
      rewrite <-PlusMult_Co3, Hh, Minus_P3; auto with real.
      rewrite (Plus_P4 a), <-Plus_P3, (Plus_P3 a); auto with real.
      rewrite Plus_neg2, (Plus_P4 0), Plus_P1; auto with real.
      apply me_zero_Abs; auto.
    - rewrite H21 in *.
      (* a - ε *)
      apply (Plus_Leq _ _ a) in H12; auto with real;
      rewrite <-Plus_P3, (Plus_P4 ((- a))), Plus_neg2, (Plus_P1) in H12; 
      auto with real.
      pattern a at 2 in H12; rewrite Hf in H12.
      rewrite PlusMult_Co3, Mult_P3, <-PlusMult_Co3 in H12; auto with real.
      rewrite <-Mult_P5, Hh in H12; auto with real.
      rewrite Minus_P3, Minus_P4, (Plus_P4 (-a)) in H12; auto with real.
      rewrite <-Plus_P3,(Plus_P3 (-a)),(Plus_P4 (-a)) in H12; auto with real. 
      rewrite Plus_neg2, (Plus_P4 0), Plus_P1 in H12; auto with real.
      (* b + ε *)
      apply (Plus_Leq _ _ b) in H18; auto with real;
      rewrite <-Plus_P3, (Plus_P4 (- b)), Plus_neg2, Plus_P1 in H18;
      auto with real.
      pattern b at 2 in H18; rewrite Hg in H18.
      rewrite <-Mult_P5, Hi in H18; auto with real.
      rewrite <-Plus_P3, (Plus_P4 (- b)), <-Plus_P3 in H18; auto with real.
      rewrite Plus_neg2, Plus_P1, Plus_P4 in H18; auto with real.
      (* elim *)
      assert (x[z] = (b + a) · ((1 + 1)⁻)).
      { apply Leq_P2; auto with real. }
      elim H16. rewrite H22. pattern b at 2; rewrite Hg.
      rewrite PlusMult_Co3, Mult_P3, <-Mult_P5; auto with real.
      rewrite Hi, <-PlusMult_Co3, Minus_P3; auto with real.
      rewrite (Plus_P4 b), <-Plus_P3, (Plus_P3 b); auto with real.
      rewrite Plus_neg2, (Plus_P4 0), Plus_P1; auto with real.
      apply me_zero_Abs; auto. }
  apply finsub in H10; auto. unfold Limit_Seq in H3; destruct H3 as [].
  apply H11 in Hz as H12. destruct H12 as [N2 []]. apply finite_maxN in H10.
  destruct H10 as [N1]; unfold Max in H10; destruct H10 as [H10 []].
  destruct (Leq_P4 N1 N2) as [Ha | Ha]; auto with real.
  - assert (N2 < (N2 + 1)).
    { pose proof H12; apply N_Subset_R in H16; apply Leq_P1 in H16.
      destruct OrderPM_Co9. apply (OrderPM_Co3 _ _ 0 1) in H16; auto with real.
      rewrite Plus_P1 in H16; auto with real. split; auto.
      intro. assert (N2 - N2 = N2 + 1 - N2). { rewrite <-H19; auto. }
      rewrite Plus_neg2, (Plus_P4 N2), <-Plus_P3, Plus_neg2, Plus_P1 in H20;
      auto with real. }
      apply H13 in H16; auto with real.
    assert (N2 + 1 ∈ \{ λ u, u ∈ ℕ /\ x[u] ∈ U(b; (｜(b - a)｜/(1 + 1))) \}).
    { destruct H6 as [H6 []]; destruct H16.
      assert (x[N2 + 1] ∈ ℝ).
      { apply H18. apply (@ Property_ran (N2 + 1)), Property_Value; auto.
        rewrite H17; auto with real. }
      apply AxiomII; repeat split; eauto with real.
      apply AxiomII; repeat split; eauto. }
    apply H15 in H17. apply AxiomII in H14 as [_[]].
    assert (N1 < N2 + 1). { apply Nat_P4b; auto. }
    destruct H19. elim H20. apply Leq_P2; auto with real.
  - apply AxiomII in H14 as [_[]].
    assert (N2 < N1 + 1). { apply Nat_P4b; auto. }
    pose proof H16. apply H13 in H17; auto with real.
    assert (N1 + 1 ∈ \{ λ u, u ∈ ℕ /\ x[u] ∈ U(b; (｜(b - a)｜/(1 + 1))) \}).
    { destruct H17; auto. destruct H6 as [H6 []].
      assert (x[N1 + 1] ∈ ℝ).
      { apply H21, (@ Property_ran (N1 + 1)), Property_Value; auto. 
        rewrite H20; auto with real. }
      apply AxiomII; repeat split; eauto with real.
      apply AxiomII; repeat split; eauto with real. }
    assert (N1 < N1 + 1).
    { apply Nat_P4b; auto; apply Leq_P1; auto with real. }
    apply H15 in H19. destruct H20. elim H21. apply Leq_P2; auto with real.
  - assert (N2 < N2 + 1).
    { apply Nat_P4b; auto; apply Leq_P1; auto with real. }
    apply H13 in H14; auto with real. apply NEexE; exists (N2 + 1).
    destruct H6 as [H6 []]; destruct H14.
    assert (x[N2 + 1] ∈ ℝ).
    { apply H16. apply (@ Property_ran (N2 + 1)), Property_Value; auto.
      rewrite H15; auto with real. }
    apply AxiomII; repeat split; eauto with real.
    apply AxiomII; repeat split; eauto with real.
  - unfold Included; intros. apply AxiomII in H14; tauto.
Qed.

Definition lim x := ∩(\{ λ a, a ∈ ℝ /\ Limit_Seq x a \}).

Corollary Lim_getValue : ∀ x a, Seq x -> a ∈ ℝ -> Limit_Seq x a -> lim x = a.
Proof.
  intros. apply AxiomI; split; intros.
  - apply AxiomII in H2 as []. apply H3. apply AxiomII; split; eauto.
  - apply AxiomII; split; eauto. intros. apply AxiomII in H3 as [H3 []].
    assert (a = y). { apply Theorem2_2 with x; auto. }
    rewrite <-H6; auto.
Qed.

(* Definition Conv_Seq x := Seq x -> ∃ a, a ∈ ℝ /\ Limit_Seq x a. *)

Corollary RMult_Eq_Sub1 : ∀ x, x ∈ ℝ -> x / (-(1)) = (-(1)) · x.
Proof.
  intros. pose proof OrderPM_Co9 as H0; destruct H0.
  assert ((-(1)) ∈ (ℝ ~ [0])).
  { apply MKT4'; split; auto with real.
    apply AxiomII; split; eauto with real. intro. apply MKT41 in H2;
    eauto with real. apply (RMult_Eq _ _ (-(1))) in H2; auto with real.
    rewrite <-PlusMult_Co3, Minus_P4, Mult_P4, PlusMult_Co1 in H2;
    auto with real. }
  assert ((-(1))⁻ ∈ (ℝ ~ [0])). { auto with real. }
  apply MKT4' in H3 as []. apply (RMult_Eq' _ _ (-(1))); auto with real. 
  rewrite Mult_P4, (Mult_P4 x), Mult_P3, Divide_P1, Mult_P4, Mult_P1,
  Mult_P4, <-PlusMult_Co3, <-PlusMult_Co3; auto with real.
  symmetry; apply Minus_P4; auto.
Qed.

(* 定理2.3: 有界性 *)
Theorem Theorem2_3' : ∀ x, Seq x -> Conv_Seq x 
  -> (∃ M, M ∈ ℝ /\ (∀ n, n ∈ ℕ -> ｜(x[n])｜ ≤ M)).
Proof.
  intros. destruct H0 as [a [H0]]. destruct H1 as [].
  destruct H1 as [H1 []]; New OrderPM_Co9.
  assert (1 ∈ ℝ /\ 0 < 1). { split; auto with real. }
  apply H2 in H6 as H7; destruct H7 as [N []]. destruct H5.
  set (F := \{ λ N1, N1 ∈ ℕ 
    /\ (∃ M, M ∈ ℝ /\ ∀ n, n ∈ ℕ -> n ≤ N1 -> ｜(x[n])｜ ≤ M) \}).
  assert (F = ℕ).
  { apply MathInd_Ma. unfold Included; intros.
    - apply AxiomII in H10 as [_[]]; auto.
    - assert (｜(x [1])｜ ∈ ℝ) as Ha.
      { apply Abs_in_R, H4, (@ Property_ran 1), Property_Value; auto.
        rewrite H3; auto with real. }
      apply AxiomII; repeat split; eauto with real.
      exists (｜(x [1])｜).
      { split; auto; intros.
        assert (n = 1).
        { pose proof one_is_min_in_N as H12; destruct H12 as [H12 []].
          apply H14 in H10 as H15. apply Leq_P2; auto. }
        rewrite H12. apply Leq_P1; auto. }
    - intros. apply AxiomII in H10 as [_[]]; destruct H11 as [M []].
      apply AxiomII; repeat split; eauto with real.
      assert (｜(x [x0 + 1])｜ ∈ ℝ).
      { apply Abs_in_R, H4, (@ Property_ran (x0 + 1)), Property_Value; auto.
        rewrite H3; auto with real. }
      destruct (Leq_P4 ｜(x[x0 + 1])｜ M) as [H14 | H14]; auto.
      + exists M; split; auto. intros. destruct (classic (n = x0 + 1)).
        * rewrite H17; auto.
        * assert (n < x0 + 1). { split; auto. }
          apply Nat_P4 in H18; auto with real.
          apply (Plus_Leq _ _ (-(1))) in H18; auto with real.
          do 2 rewrite <-Plus_P3 in H18; auto with real.
          do 2 rewrite Plus_neg2 in H18; auto with real.
          do 2 rewrite Plus_P1 in H18; auto with real.
      + exists ｜(x [x0 + 1])｜; split; auto. intros.
        assert (｜(x[n])｜ ∈ ℝ).
        { apply Abs_in_R, H4, (@ Property_ran n), Property_Value; auto.
          rewrite H3; auto. }
        destruct (classic (n = x0 + 1)).
        * rewrite H18; apply (Leq_P1); auto.
        * assert (n < x0 + 1). { split; auto. }
          assert (｜(x [n])｜ ≤ M).
          { apply Nat_P4 in H19; auto with real.
            apply (Plus_Leq _ _ (-(1))) in H19; auto with real.
            do 2 rewrite <-Plus_P3 in H19; auto with real.
            do 2 rewrite Plus_neg2 in H19; auto with real.
            do 2 rewrite Plus_P1 in H19; auto with real. }
          apply (Leq_P3 _ M _); auto. }
  rewrite <-H10 in H7; apply AxiomII in H7 as [_[]].
  assert ((-(1)) ∈ (ℝ ~ [0])) as Ha.
  { apply MKT4'; split; auto with real.
    apply AxiomII; split; eauto with real. intro. apply MKT41 in H12;
    eauto with real. apply (RMult_Eq _ _ (-(1))) in H12; auto with real.
    rewrite <-PlusMult_Co3, Minus_P4, Mult_P4, PlusMult_Co1 in H12;
    auto with real. }
  assert ((-(1))⁻ ∈ (ℝ ~ [0])) as Hb. { auto with real. }
  apply MKT4' in Hb as [Hb Hc].
  destruct H11 as [M [H11]]. destruct (Leq_P4 a 0); auto with real.
  - assert (∀ n, n ∈ ℕ -> N < n -> ｜(x [n])｜ < 1 - a).
    { intros. assert (x[n] ∈ ℝ).
      { apply H4, (@ Property_ran n), Property_Value; auto; rewrite H3; auto. }
      assert (0 ≤ (- a)).
      { apply (Plus_Leq _ _ (- a)) in H13 as H17; auto with real.
        rewrite Plus_neg2, Plus_P4, Plus_P1 in H17; auto with real. }
      assert (0 ≤ 1 - a).
      { assert (0 + 0 ≤ 1 + (- a)).
        { apply OrderPM_Co3; auto with real. }
        rewrite Plus_P1 in H18; auto with real. }
      apply H8 in H15; auto. destruct H15. 
      apply Abs_P4 in H15 as [];
      auto with real. split. apply Abs_P4; auto with real.
      apply (Plus_Leq _ _ a) in H15; auto with real.
      rewrite <-Plus_P3, (Plus_P4 (- a)), Plus_neg2, Plus_P1 in H15; 
      auto with real.
      apply (Plus_Leq _ _ a) in H20; auto with real.
      rewrite <-Plus_P3, (Plus_P4 (- a)), Plus_neg2, Plus_P1 in H20;
      auto with real.
      split. rewrite Minus_P3, Minus_P4; auto with real.
      assert (1 + a ≤ 1 - a).
      { apply OrderPM_Co3; auto with real. apply Leq_P1; auto with real.
        apply (Leq_P3 _ 0 _); auto with real. }
      apply (Leq_P3 _ (1 + a) _); auto with real.
      intro. elim H19.
      destruct (Leq_P4 (x[n]) 0) as [H22 | H22]; auto with real.
      -- assert (｜(x [n])｜ = - x[n]). { apply le_zero_Abs; auto. }
         rewrite H23, PlusMult_Co3, Mult_P4 in H21; auto with real.
         apply (RMult_Eq _ _ ((-(1))⁻)) in H21; auto with real.
         rewrite <-Mult_P3, Divide_P1, Mult_P1 in H21; auto with real.
         rewrite H21. assert ((1 - a) / - (1) = (- (1)) + a).
         { assert ((1 - a) / - (1) = (-(1)) · (1 - a)).
           { apply RMult_Eq_Sub1; auto with real. }
           rewrite H24, <-PlusMult_Co3, Minus_P3, Minus_P4; auto with real. }
         rewrite H24. rewrite <-Plus_P3, Plus_neg2, Plus_P1; auto with real.
         assert (｜1｜ = ｜(-(1))｜). { apply Abs_P2; auto with real. }
         rewrite <-H25; apply me_zero_Abs; auto with real.
      -- (* ▲ *)
         assert (｜(x[n])｜ = x[n]). { apply me_zero_Abs; auto. }
         rewrite H23 in H21. rewrite H21, <-Plus_P3 in H20; auto with real.
         assert (- a - a = (- a) · (1 + 1)).
         { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1, PlusMult_Co3;
           auto with real. }
         (* ****** rewrite H24 in H20. ****** *)
         assert (1 + ((- a)+ (- a)) ≤ 1); auto. rewrite H24 in H25.
         assert (0 ≤ (- a)· (1 + 1)).
         { apply (OrderPM_Co7b _ _ (1 + 1)) in H17; auto with real.
           rewrite Mult_P4, PlusMult_Co1 in H17; auto with real.
           assert (0 + 0 ≤ 1 + 1). { apply OrderPM_Co3; auto with real. }
           rewrite Plus_P1 in H26; auto with real. }
         assert (1 ≤ 1 + ((- a)· (1 + 1))).
         { assert (1 + 0 ≤ 1 + ((- a)· (1 + 1))).
           { apply OrderPM_Co3; auto with real. apply Leq_P1; auto with real. }
           rewrite Plus_P1 in H27; auto with real. }
         assert (1 = 1 + (- a) · (1 + 1)). { apply Leq_P2; auto with real. }
         rewrite H28, H21. assert ((1 - a) - a = 1 + (- a - a)). (* * *)
         { rewrite <-Plus_P3; auto with real. }
         rewrite H29, H24. apply me_zero_Abs; auto with real.
         assert (0 + 0 ≤ 1 + ((- a)· (1 + 1))).
         { apply OrderPM_Co3; auto with real. }
         rewrite Plus_P1 in H30; auto with real. }
    destruct (Leq_P4 (1 - a) M) as [H15 | H15]; auto with real.
    + exists M; split; auto. intros.
      destruct (Order_Co1 n N) as [H17 | [|]]; auto with real.
      * destruct H17. apply H12 in H17; auto.
      * apply H14 in H17; auto. destruct H17.
        apply (Leq_P3 _ (1 - a) _); auto with real.
        apply Abs_in_R, H4, (@ Property_ran n), Property_Value; auto.
        rewrite H3; auto.
      * apply H12; auto. rewrite H17. apply Leq_P1; auto with real.
    + exists (1 - a); split; auto with real. intros.
      destruct (Order_Co1 n N) as [H17 | [|]]; auto with real.
      * destruct H17. apply H12 in H17; auto.
        apply (Leq_P3 _ M _); auto with real.
        apply Abs_in_R, H4, (@ Property_ran n), Property_Value; auto.
        rewrite H3; auto.
      * apply H14 in H17; destruct H17; auto.
      * assert (｜(x[N])｜ ≤ M).
        { rewrite <-H17. apply H12; auto. rewrite H17.
          apply Leq_P1; auto with real. }
        rewrite H17. apply (Leq_P3 _ M _); auto with real.
        apply Abs_in_R, H4, (@ Property_ran N), Property_Value; auto.
        rewrite H3; auto.
  - assert (∀ n, n ∈ ℕ -> N < n -> ｜(x [n])｜ < 1 + a).
    { intros. assert (x[n] ∈ ℝ).
      { apply H4, (@ Property_ran n), Property_Value; auto; rewrite H3; auto. }
      assert (- a ≤ 0).
      { apply (Plus_Leq _ _ (- a)) in H13; auto with real.
        rewrite Plus_neg2, (Plus_P4 0), Plus_P1 in H13; auto with real. }
      assert (0 ≤ 1 + a).
      { assert (0 + 0 ≤ 1 + a).
        { apply OrderPM_Co3; auto with real. }
        rewrite Plus_P1 in H18; auto with real. }
      apply H8 in H15; auto. destruct H15; apply Abs_P4 in H15 as [];
      auto with real. split. apply Abs_P4; auto with real.
      apply (Plus_Leq _ _ a) in H20; auto with real.
      rewrite <-Plus_P3, (Plus_P4 (- a)), Plus_neg2, Plus_P1 in H20;
      auto with real.
      apply (Plus_Leq _ _ a) in H15; auto with real.
      rewrite <-Plus_P3, (Plus_P4 (- a)), Plus_neg2, Plus_P1 in H15;
      auto with real. split; auto.
      assert ((-(1)) - a ≤ (-(1)) + a).
      { apply OrderPM_Co3; auto with real. apply Leq_P1; auto with real.
        apply (Leq_P3 _ 0 _); auto with real. }
      rewrite Minus_P3; auto with real. apply (Leq_P3 _ ((-(1)) + a) _);
      auto with real. intro. elim H19.
      destruct (Leq_P4 (x [n]) 0) as [H22 | H22]; auto with real.
      (* ▲ *)
      -- assert (｜(x[n])｜ = - x[n]). { apply le_zero_Abs; auto. }
         assert (-(1) < 0) as [Hz Hy].
         { pose proof OrderPM_Co9. apply OrderPM_Co2a in H24; auto with real. }
         rewrite H23, PlusMult_Co3, Mult_P4 in H21; auto with real.
         apply (RMult_Eq _ _ ((-(1))⁻)) in H21; auto with real.
         rewrite <-Mult_P3, Divide_P1, Mult_P1 in H21; auto with real.
         rewrite RMult_Eq_Sub1 in H21; auto with real.
         assert (a + a = a · (1 + 1)).
         { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
         assert (0 ≤ a · (1 + 1)).
         { apply (OrderPM_Co7b _ _ (1 + 1)) in H13; auto with real.
           rewrite Mult_P4, PlusMult_Co1 in H13; auto with real.
           assert (0 + 0 ≤ 1 + 1). { apply OrderPM_Co3; auto with real. }
           rewrite Plus_P1 in H25; auto with real. }
         assert (1 ≤ 1 + a · (1 + 1)).
         { assert (1 + 0 ≤ 1 + a · (1 + 1)).
           { apply OrderPM_Co3; auto with real; apply Leq_P1; auto with real. }
           rewrite Plus_P1 in H26; auto with real. }
         rewrite H21 in H15.
         assert (- (a) = (- (1)) · a). { rewrite PlusMult_Co3; auto. }
         rewrite H27, Mult_P4, (Mult_P4 (-(1))), <-Mult_P5, <-Plus_P3,
         Mult_P4, <-PlusMult_Co3 in H15; auto with real.
         apply (OrderPM_Co8b _ _ (-(1))) in H15; auto with real.
         rewrite Mult_P4, PlusMult_Co4, PlusMult_Co4 in H15; auto with real.
         (* ****** rewrite H24 in H15 ****** *)
         assert (1 + (a + a) ≤ 1); auto. rewrite H24 in H28.
         assert (1 = 1 + a · (1 + 1)). { apply Leq_P2; auto with real. }
         rewrite H29, H21. rewrite H27, Mult_P4, (Mult_P4 (-(1))), <-Mult_P5,
         Mult_P4, <-PlusMult_Co3, <-Plus_P3; auto with real.
         assert (｜(- (1 + (a + a)))｜ = 1 + a · (1 + 1)).
         { assert (0 ≤ (1 + a · (1 + 1))).
           { apply (Leq_P3 _ 1 _); auto with real. }
           assert (｜(1 + a · (1 + 1))｜ = ｜(- (1 + a · (1 + 1)))｜).
           { pose proof (Abs_P2 (1 + a · (1 + 1))) as [Hx _]; auto with real. }
           rewrite H24, <-H31. apply me_zero_Abs; auto with real. } auto.
      -- assert (｜(x[n])｜ = x[n]). { apply me_zero_Abs; auto. }
         rewrite H23 in H21. rewrite H21, <-Plus_P3, Plus_neg2, Plus_P1;
         auto with real. apply me_zero_Abs; auto with real. }
    destruct (Leq_P4 (1 + a) M) as [H15 | H15]; auto with real.
    + exists M; split; auto. intros.
      destruct (Order_Co1 n N) as [H17 | [|]]; auto with real.
      * destruct H17; apply H12 in H17; auto.
      * apply H14 in H17; destruct H17; auto.
        apply (Leq_P3 _ (1 + a) _); auto with real.
        apply Abs_in_R, H4, (@ Property_ran n), Property_Value; auto.
        rewrite H3; auto.
      * apply H12; auto. rewrite H17; apply Leq_P1; auto with real.
    + exists (1 + a); split; auto with real. intros.
      destruct (Order_Co1 n N) as [H17 | [|]]; auto with real.
      * destruct H17; apply H12 in H17; auto.
        apply (Leq_P3 _ M _); auto with real.
        apply Abs_in_R, H4, (@ Property_ran n), Property_Value; auto.
        rewrite H3; auto.
      * apply H14 in H17; destruct H17; auto.
      * assert (｜(x[N])｜ ≤ M).
        { rewrite <-H17. apply H12; auto. rewrite H17; apply Leq_P1;
          auto with real. }
        apply (Leq_P3 _ M _); auto with real.
        apply Abs_in_R, H4, (@ Property_ran n), Property_Value; auto.
        rewrite H3; auto. rewrite H17; auto.
Qed.

Theorem Theorem2_3 : ∀ x, Seq x -> Conv_Seq x
  -> (∃ M, M ∈ ℝ /\ 0 < M /\ (∀ n, n ∈ ℕ -> ｜(x[n])｜ ≤ M)).
Proof.
  intros. apply Theorem2_3' in H0; auto.
  destruct H0 as [M []], H as [H []].
  assert (0 ≤ M).
  { pose proof one_in_N; apply (H1 1) in H4 as H5.
    apply (Leq_P3 _ ｜(x [1])｜ _); auto with real. apply Abs_in_R,
    H3, (@ Property_ran 1), Property_Value; auto; rewrite H2; auto.
    apply Abs_P1. apply H3, (@ Property_ran 1), Property_Value; auto.
    rewrite H2; auto. }
  destruct (classic (M = 0)).
  - exists (M + 1); split; auto with real; pose proof OrderPM_Co9.
    split. rewrite H5, Plus_P4, Plus_P1; auto with real.
    intros; apply (Leq_P3 _ M _); auto with real. apply Abs_in_R, H3,
    (@ Property_ran n), Property_Value; auto; rewrite H2; auto.
    destruct H6; rewrite H5, Plus_P4, Plus_P1; auto with real.
  - exists M; repeat split; auto.
Qed.
    
Corollary RPlus_Eq : ∀ x y z, x ∈ ℝ -> y ∈ ℝ -> z ∈ ℝ -> x = y -> x + z = y + z.
Proof.
  intros. rewrite H2; auto.
Qed.

Corollary RPlus_Eq' : ∀ x y z, x ∈ ℝ -> y ∈ ℝ -> z ∈ ℝ -> x + z = y + z -> x = y.
Proof.
  intros. apply (RPlus_Eq _ _ (- z)) in H2; auto with real.
  rewrite <-Plus_P3, <-Plus_P3, Plus_neg2, Plus_P1, Plus_P1 in H2;
  auto with real.
Qed.

(* 定理2.4 保号性*)
Theorem Theorem2_4a : ∀ x a, Seq x -> a ∈ ℝ -> Limit_Seq x a -> 0 < a
  -> (∀ a', a' ∈ ℝ /\ a' ∈ ］0,a［ 
    -> (∃ N, N ∈ ℕ /\ (∀ n, n ∈ ℕ -> N < n -> a' < x[n]))).
Proof.
  intros. destruct H1 as [Ha Hb], H3 as [Hc Hd], Ha as [He [Hf Hg]].
  apply AxiomII in Hd as [_[_[]]].
  assert (a - a' ∈ ℝ /\ 0 < a - a').
  { split; auto with real. destruct H3; split.
    apply (Plus_Leq _ _ (- a')) in H3; auto with real.
    rewrite Plus_neg2 in H3; auto. intro. elim H4.
    apply (RPlus_Eq' _ _ (- a')); auto with real. rewrite Plus_neg2; auto. }
  apply Hb in H4 as [N []]. exists N; split; auto; intros.
  assert (x[n] ∈ ℝ) as Hh.
  { apply Hg, (@ Property_ran n), Property_Value; auto. rewrite Hf; auto. }
  assert (0 ≤ (a - a')) as Hi.
  { destruct H3. apply (Plus_Leq _ _ (- a')) in H3; auto with real.
    rewrite Plus_neg2 in H3; auto. }
  assert (a' - a ≤ 0) as Hj.
  { destruct H3. apply (Plus_Leq _ _ (- a)) in H3; auto with real.
    rewrite Plus_neg2 in H3; auto. }
  apply H5 in H7; auto. destruct H7.
  apply Abs_P4 in H7 as []; auto with real.
  rewrite Minus_P3, Minus_P4 in H7; auto with real.
  apply (Plus_Leq _ _ a) in H7; auto with real.
  rewrite Plus_P4,Plus_P3,Plus_neg2,(Plus_P4 0),Plus_P1 in H7; auto with real.
  rewrite <-Plus_P3, (Plus_P4 (- a)), Plus_neg2, Plus_P1 in H7; auto with real.
  split; auto. intro. elim H8. rewrite <-H10. 
  assert (a - a' = - (a' - a)).
  { rewrite Minus_P3, Minus_P4, Plus_P4; auto with real. }
  rewrite H11. apply le_zero_Abs; auto with real.
Qed.

Theorem Theorem2_4b : ∀ x a, Seq x -> a ∈ ℝ -> Limit_Seq x a -> a < 0
  -> (∀ a', a' ∈ ℝ /\ a' ∈ ］a,0［
    -> (∃ N, N ∈ ℕ /\ (∀ n, n ∈ ℕ -> N < n -> x[n] < a'))).
Proof.
  intros. destruct H1 as [Ha Hb], Ha as [Hc [Hd He]], H3 as [Hf Hg].
  apply AxiomII in Hg as [_[_[]]].
  assert ((a' - a) ∈ ℝ /\ 0 < (a' - a)).
  { split; auto with real. destruct H1. apply (Plus_Leq _ _ (- a)) in H1; 
    auto with real; rewrite Plus_neg2 in H1; auto. split; auto. intro. elim H4.
    apply (RPlus_Eq' _ _ (- a)); auto with real; rewrite Plus_neg2; auto. }
  apply Hb in H4. destruct H4 as [N []]. exists N; split; auto. intros.
  assert (x[n] ∈ ℝ).
  { apply He, (@ Property_ran n), Property_Value; auto. rewrite Hd; auto. }
  assert (0 ≤ a' - a).
  { destruct H1. apply (Plus_Leq _ _ (- a)) in H1; auto with real.
    rewrite Plus_neg2 in H1; auto. }
  apply H5 in H7; auto. destruct H7. apply Abs_P4 in H7 as []; auto with real.
  apply (Plus_Leq _ _ a) in H11; auto with real.
  rewrite <-Plus_P3, <-Plus_P3, (Plus_P4 (-(a))) in H11; auto with real.
  rewrite Plus_neg2, Plus_P1, Plus_P1 in H11; auto. split; auto.
  intro. elim H10. rewrite H12. apply me_zero_Abs; auto with real.
Qed.

Corollary Max_nat_3 : ∀ N0 N1 N2, N0 ∈ ℕ -> N1 ∈ ℕ -> N2 ∈ ℕ
  -> (∃ N, N ∈ ℕ /\ N0 < N /\ N1 < N /\ N2 < N).
Proof.
  intros. destruct (Leq_P4 N0 N1) as [Ha | Ha]; auto with real.
  - destruct (Leq_P4 N1 N2) as [Hb | Hb]; auto with real.
    + exists (N2 + 1).
      assert (N0 < N2 + 1) as []. 
      { apply Nat_P4b; auto; apply (Leq_P3 _ N1 _); auto with real. }
      assert (N1 < N2 + 1) as []. { apply Nat_P4b; auto. }
      assert (N2 < N2 + 1) as [].
      { apply Nat_P4b; auto; apply Leq_P1; auto with real. }
      repeat split; auto with real.
    + exists (N1 + 1).
      assert (N0 < N1 + 1) as []. { apply Nat_P4b; auto. }
      assert (N1 < N1 + 1) as []. 
      { apply Nat_P4b; auto; apply Leq_P1; auto with real. }
      assert (N2 < N1 + 1) as []. { apply Nat_P4b; auto. }
      repeat split; auto with real.
  - destruct (Leq_P4 N0 N2) as [Hb | Hb]; auto with real.
    + exists (N2 + 1).
      assert (N0 < N2 + 1) as []. { apply Nat_P4b; auto. }
      assert (N1 < N2 + 1) as [].
      { apply Nat_P4b; auto. apply (Leq_P3 _ N0 _); auto with real. }
      assert (N2 < N2 + 1) as [].
      { apply Nat_P4b; auto; apply Leq_P1; auto with real. }
      repeat split; auto with real.
    + exists (N0 + 1).
      assert (N0 < N0 + 1) as [].
      { apply Nat_P4b; auto; apply Leq_P1; auto with real. }
      assert (N1 < N0 + 1) as []. { apply Nat_P4b; auto. }
      assert (N2 < N0 + 1) as []. { apply Nat_P4b; auto. }
      repeat split; auto with real.
Qed.

Corollary Max_nat_2 : ∀ N0 N1, N0 ∈ ℕ -> N1 ∈ ℕ -> 
  (∃ N, N ∈ ℕ /\ N0 < N /\ N1 < N).
Proof.
  intros. pose proof (Max_nat_3 _ _ _ H H0 H0).
  destruct H1 as [N [H1 [H2 [_]]]]. exists N; split; auto.
Qed.

Corollary RNot_Le_Gt : ∀ r1 r2, r1 ∈ ℝ -> r2 ∈ ℝ -> ~ (r1 ≤ r2) <-> (r2 < r1).
Proof.
  split; intros.
  - apply NNPP; intro. destruct (Leq_P4 r1 r2); auto.
    destruct (classic (r1 = r2)).
    + rewrite H4 in H1. elim H1. apply Leq_P1; auto.
    + elim H2; auto. split; auto.
  - intro. destruct H1. elim H3. apply Leq_P2; auto.
Qed.

Corollary RNot_Lt_Ge : ∀ r1 r2, r1 ∈ ℝ -> r2 ∈ ℝ -> ~ (r1 < r2) <-> r2 ≤ r1.
Proof.
  split; intros.
  - apply NNPP; intro. destruct (Leq_P4 r1 r2); auto.
    destruct (classic (r1 = r2)).
    + rewrite H4 in H2. elim H2. apply Leq_P1; auto.
    + elim H1. split; auto.
  - intro. destruct H2. elim H3; apply Leq_P2; auto.
Qed.

(* 定理2.5 保不等式性 *)
Theorem Theorem2_5 : ∀ x y, 
  Seq x -> Seq y -> Conv_Seq x -> Conv_Seq y 
  -> (∃ N0, N0 ∈ ℕ /\ (∀ n, n ∈ ℕ -> N0 < n -> x[n] ≤ y[n])) -> lim x ≤ lim y.
Proof.
  intros. destruct H1 as [a [Ha]], H2 as [b [Hb]].
  destruct H as [H []], H0 as [H0 []].
  assert (∀ε, ε ∈ ℝ /\ 0 < ε -> a < b + (ε + ε)).
  { intros. pose proof H8 as []; destruct H10. destruct H3 as [N0 [Hc Hd]].
    apply H1 in H8 as He; destruct He as [N1 [He Hf]].
    apply H2 in H8 as Hg; destruct Hg as [N2 [Hg Hh]].
    destruct (Max_nat_3 N0 N1 N2) as [N [Hi [Hj [Hk Hl]]]]; auto.
    assert (x[N] ∈ ℝ).
    { apply H5, (@ Property_ran N), Property_Value; auto. rewrite H4; auto. }
    assert (y[N] ∈ ℝ).
    { apply H7, (@ Property_ran N), Property_Value; auto; rewrite H6; auto. }
    apply Hd in Hj; apply Hf in Hk; apply Hh in Hl; auto.
    destruct Hk, Hl. apply Abs_P4 in H13 as [], H15 as []; auto with real.
    apply (Plus_Leq _ _ a) in H13; auto with real.
    rewrite <-Plus_P3, (Plus_P4 (-(a))), Plus_neg2, Plus_P1, Plus_P4 in H13;
    auto with real.
    apply (Plus_Leq _ _ b) in H18; auto with real.
    rewrite <-Plus_P3, (Plus_P4 (-(b))), Plus_neg2, Plus_P1, Plus_P4 in H18; 
    auto with real.
    assert (a - ε < b + ε).
    { split. apply (Leq_P3 _ x[N] _); auto with real; 
      apply (Leq_P3 _ y[N] _); auto with real. intro.
      assert (a - ε ≤ x[N]); auto. rewrite H19 in H20.
      assert (b + ε ≤ y[N]). { apply (Leq_P3 _ x[N] _); auto with real. }
      assert (y[N] = b + ε). { apply Leq_P2; auto with real. }
      rewrite H22 in H16. rewrite (Plus_P4 b), <-Plus_P3, 
      Plus_neg2, Plus_P1 in H16; auto with real. elim H16.
      apply me_zero_Abs; auto. }
    destruct H19. apply (Plus_Leq _ _ ε) in H19; auto with real.
    rewrite <-Plus_P3, (Plus_P4 (-(ε))), Plus_neg2, Plus_P1, <-Plus_P3 in H19;
    auto with real. split; auto; intro. rewrite H21 in H20.
    elim H20. apply (RPlus_Eq' _ _ ε); auto with real.
    rewrite <-Plus_P3, (Plus_P4 (-(ε))), Plus_neg2, Plus_P1; auto with real.
    rewrite Plus_P3; auto. }
  pose proof H1; pose proof H2; destruct H1; destruct H2.
  apply Lim_getValue in H9; auto; apply Lim_getValue in H10; auto.
  rewrite H9; rewrite H10. apply NNPP; intro. apply RNot_Le_Gt in H13; auto.
  destruct H13. apply (Plus_Leq _ _ a) in H13 as H15; auto.
  assert (b + a ≤ a + a); auto.
  assert (0 < (1 + 1)) as Hm.
  { apply (Order_Co2 _ 1); auto with real.
    left; split; New OrderPM_Co9; auto.
    apply (OrderPM_Co1 _ _ 1) in H17; auto with real.
    rewrite Plus_P4, Plus_P1 in H17; auto with real. destruct H17; auto. }
  assert (0 < ((1 + 1)⁻)) as Hn. { apply OrderPM_Co10; auto with real. }
  assert ((1 + 1) ∈ (ℝ ~ [0])) as Ho.
  { apply MKT4'; split; auto with real.
    apply AxiomII; split; eauto with real.
    intro. apply MKT41 in H17; eauto with real.
    rewrite H17 in Hm; destruct Hm; contradiction. }
  assert ((1 + 1) ⁻ ∈ (ℝ ~ [0])) as Hp. { apply Mult_inv1; auto. }
  assert (a · (1 + 1) = a + a).
  { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. } 
  assert (b = b · (1 + 1) - b).
  { assert (b · (1 + 1) = b + b).
    { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
    rewrite H18. rewrite <-Plus_P3, Plus_neg2, Plus_P1; auto with real. }
  assert (0 < (a - b)) as Hq.
  { apply (Plus_Leq _ _ (-(b))) in H13; auto with real.
    rewrite Plus_neg2 in H13; auto. split; auto; intro. elim H14.
    apply (RPlus_Eq' _ _ (-(b))); auto with real. rewrite Plus_neg2; auto. }
  pose proof Hp. apply MKT4' in H19 as [H19 H20]. pose proof Hn; destruct H21.
  rewrite <-H17, H18, <-Plus_P3, (Plus_P4 (-(b))) in H16; auto with real.
  apply (OrderPM_Co7b _ _ ((1 + 1)⁻)) in H16; auto with real. 
  rewrite <-Mult_P3, Divide_P1, Mult_P1 in H16; auto with real. 
  rewrite Mult_P5, <-Mult_P3, Divide_P1, Mult_P1 in H16; auto with real.
  assert (((a - b)· (1 + 1)⁻)· (1 + 1)⁻ ∈ ℝ 
    /\ 0 < ((a - b)· (1 + 1)⁻) · ((1 + 1)⁻)).
  { split.
    - apply Mult_close; auto. apply Mult_close; auto with real.
    - apply OrderPM_Co5; auto with real. left; split; auto.
      apply OrderPM_Co5; auto with real. }
  apply H8 in H23. rewrite <-Mult_P5, <-Mult_P5 in H23; auto with real.
  assert (a < b + ((((a - b) + (a - b)) · ((1 + 1)⁻)) · ((1 + 1)⁻))); auto.
  assert ((a - b) + (a - b) = (a - b) · (1 + 1)).
  { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
  assert ((a - b) · (1 + 1) /  (1 + 1) = a - b).
  { rewrite <-Mult_P3, Divide_P1, Mult_P1; auto with real. }
  assert (b + (a - b) / (1 + 1) ∈ ℝ). { apply Plus_close; auto with real. }
  rewrite H25, H26 in H24. apply RNot_Lt_Ge in H24; auto.
Qed.

Corollary Corollary2_5a : ∀ x x0 a, Seq x -> x0 ∈ ℝ -> a ∈ ℝ 
  -> Limit_Seq x x0 -> (∃ N0, N0 ∈ ℕ /\ (∀ n, n ∈ ℕ -> N0 < n -> a ≤ x[n]))
  -> a ≤ x0.
Proof.
  intros. destruct H3 as [N0 []].
  assert (∃ y, y = \{\ λ u v, u ∈ ℕ /\ v ∈ ℝ /\ v = a \}\) as [y].
  { exists \{\ λ u v, u ∈ ℕ /\ v ∈ ℝ /\ v = a \}\; auto. }
  assert (Seq y).
  { repeat split.
    - unfold Relation; intros. rewrite H5 in H6.
      apply AxiomII in H6 as [_[u [v]]]. exists u, v; tauto.
    - intros. rewrite H5 in H6, H7. apply AxiomII' in H6 as [_[H6 []]].
      apply AxiomII' in H7 as [_[_[]]]. rewrite H10; auto.
    - apply AxiomI; split; intros.
      + apply AxiomII in H6 as [H6 []]. rewrite H5 in H7.
        apply AxiomII' in H7; tauto.
      + apply AxiomII; split; eauto. exists a. rewrite H5.
        apply AxiomII'; split; auto. apply MKT49a; eauto.
    - unfold Included; intros. apply AxiomII in H6 as [_[]].
      rewrite H5 in H6. apply AxiomII' in H6; tauto. }
  assert (∀ n, n ∈ ℕ -> a = y[n]).
  { intros. destruct H6 as [H6 []]. apply Property_Fun; auto.
    rewrite H5. apply AxiomII'; split; auto. apply MKT49a; eauto. }
  assert (Limit_Seq y a).
  { unfold Limit_Seq; split; auto. intros. destruct H8.
    exists 1; split; auto with real. intros. apply H7 in H10 as H12.
    rewrite <-H12, Plus_neg2, me_zero_Abs; auto with real.
    apply Leq_P1; auto with real. }
  apply Lim_getValue in H2 as Ha; apply Lim_getValue in H8 as Hb; auto.
  rewrite <-Ha, <-Hb. apply Theorem2_5; auto; try intro.
  - exists a; split; auto.
  - exists x0; split; auto.
  - exists N0; split; auto; intros. apply H4 in H10; auto. rewrite <-H7; auto.
Qed.

Corollary Corollary2_5b : ∀ x x0 a, Seq x -> x0 ∈ ℝ -> a ∈ ℝ
  -> Limit_Seq x x0 -> (∃ N0, N0 ∈ ℕ /\ (∀ n, n ∈ ℕ -> N0 < n -> x[n] ≤ a))
  -> x0 ≤ a.
Proof.
  intros. destruct H3 as [N0 []].
  assert (∃ y, y = \{\ λ u v, u ∈ ℕ /\ v ∈ ℝ /\ v = a \}\) as [y].
  { exists \{\ λ u v, u ∈ ℕ /\ v ∈ ℝ /\ v = a \}\; auto. }
  assert (Seq y).
  { repeat split.
    - unfold Relation; intros. rewrite H5 in H6.
      apply AxiomII in H6 as [_[u [v]]]; exists u, v; tauto.
    - intros. rewrite H5 in H6, H7. apply AxiomII' in H6 as [_[H6 []]];
      apply AxiomII' in H7 as [_[_[]]]. rewrite H10; auto.
    - apply AxiomI; split; intros.
      + apply AxiomII in H6 as [_[]]. rewrite H5 in H6.
        apply AxiomII' in H6; tauto.
      + apply AxiomII; split; eauto. exists a; rewrite H5.
        apply AxiomII'; split; auto. apply MKT49a; eauto.
    - unfold Included; intros. apply AxiomII in H6 as [_[]].
      rewrite H5 in H6; apply AxiomII' in H6; tauto. }
  assert (∀ n, n ∈ ℕ -> a = y[n]).
  { intros. destruct H6 as [H6 []]. apply Property_Fun; auto. rewrite H5.
    apply AxiomII'; split; auto. apply MKT49a; eauto. }
  assert (Limit_Seq y a).
  { split; auto; intros. destruct H8. exists 1; split; auto with real.
    intros. apply H7 in H10 as H12. rewrite <-H12, Plus_neg2; auto.
    rewrite me_zero_Abs; auto with real. apply Leq_P1; auto with real. }
  apply Lim_getValue in H2 as Ha; apply Lim_getValue in H8 as Hb; auto.
  rewrite <-Ha, <-Hb. apply Theorem2_5; auto; try intro.
  - exists x0; split; auto.
  - exists a; split; auto.
  - exists N0; split; auto. intros. apply H4 in H10; auto. rewrite <-H7; auto.
Qed.

Corollary NTrans_Lt : ∀ x y z, x ∈ ℕ -> y ∈ ℕ -> z ∈ ℕ -> x < y -> y < z -> x < z.
Proof.
  intros. apply Nat_P4 in H2, H3; auto with real.
  assert (y ≤ y + 1).
  { apply Nat_P4b; auto. apply Leq_P1; auto with real. }
  assert (x + 1 ≤ z).
  { apply (Leq_P3 _ y _); auto with real.
    apply (Leq_P3 _ (y + 1) _); auto with real. }
  apply Nat_P4a in H5; auto.
Qed.

(* 定理2.6 迫敛性 *)
Theorem Theorem2_6 : ∀ x y z a, Seq x -> Seq y -> a ∈ ℝ
  -> Limit_Seq x a -> Limit_Seq y a -> Seq z
  -> (∃ N0, N0 ∈ ℕ /\ ∀ n, n ∈ ℕ -> N0 < n -> (x[n] ≤ z[n] /\ z[n] ≤ y[n]))
  -> Limit_Seq z a.
Proof.
  split; auto; intros. destruct H2 as [Ha Hb], H3 as [Hc Hd].
  destruct Ha as [Ha []], Hc as [Hc []]. pose proof H6 as [He Hf]; destruct Hf.
  apply Hb in H6 as Hg; apply Hd in H6 as Hh.
  destruct H5 as [N0 [H5]], Hg as [N1 [Hg]], Hh as [N2 [Hh]].
  pose proof (Max_nat_3 _ _ _ H5 Hg Hh) as [N [Hi [Hj [Hk Hl]]]].
  exists N; split; auto; intros. apply (NTrans_Lt _ _ n) in Hj; auto;
  apply (NTrans_Lt _ _ n) in Hk; auto; apply (NTrans_Lt _ _ n) in Hl; auto.
  assert (x[n] ∈ ℝ) as Hm.
  { apply H3, (@ Property_ran n), Property_Value; auto. rewrite H2; auto. } 
  assert (y[n] ∈ ℝ) as Hn.
  { apply H8, (@ Property_ran n), Property_Value; auto. rewrite H7; auto. }
  assert (z[n] ∈ ℝ) as Ho.
  { destruct H4. destruct H16 as [].
    apply H17, (@ Property_ran n), Property_Value; auto. rewrite H16; auto. }
  apply H11 in Hj as []; apply H12 in Hk; apply H13 in Hl; auto.
  destruct Hk, Hl. apply Abs_P4 in H18 as [], H20 as []; auto with real.
  apply (Plus_Leq _ _ a) in H18; auto with real.
  rewrite <-Plus_P3,(Plus_P4 (-(a))),Plus_neg2,Plus_P1 in H18; auto with real.
  apply (Plus_Leq _ _ a) in H23; auto with real.
  rewrite <-Plus_P3,(Plus_P4 (-(a))),Plus_neg2,Plus_P1 in H23; auto with real.
  split. apply Abs_P4; auto with real. split.
  - apply (Leq_P3 _ _ (z[n])) in H18; auto with real.
    apply (Plus_Leq _ _ (-(a))) in H18; auto with real.
    rewrite <-Plus_P3, Minus_P1, Plus_P1 in H18; auto with real.
  - apply (Leq_P3 (z[n]) _ _) in H23; auto with real.
    apply (Plus_Leq _ _ (-(a))) in H23; auto with real.
    rewrite <-Plus_P3, Minus_P1, Plus_P1 in H23; auto with real.
  - intro. destruct (Leq_P4 (z[n] - a) 0); auto with real.
    + rewrite le_zero_Abs, Minus_P3, Minus_P4 in H24; auto with real.
      rewrite <-H24, Minus_P3, Minus_P4, <-Plus_P3, (Plus_P4 (-(a))),
      Plus_neg2, Plus_P1 in H18; auto with real. 
      assert (x[n] = z[n]). { apply Leq_P2; auto. }
      elim H19. rewrite H26, <-H24.
      assert (- z[n] + a = - (z[n] - a)).
      { rewrite Minus_P3, Minus_P4; auto with real. }
      rewrite H27; apply le_zero_Abs; auto with real.
    + rewrite me_zero_Abs in H24; auto with real.
      rewrite <-H24, <-Plus_P3, (Plus_P4 (-(a))), Plus_neg2, Plus_P1 in H23;
      auto with real. assert (y[n] = z[n]). { apply Leq_P2; auto. }
      elim H21. rewrite H26, <-H24. apply me_zero_Abs; auto with real.
Qed.

(* 定理2.7 四则运算法则 *)
(* x,y是收敛数列,则 x+y 收敛,且有 lim(x+y) = lim x + lim y *)
Theorem Theorem2_7a : ∀ x y, Seq x -> Seq y 
  -> Conv_Seq x -> Conv_Seq y
  -> Conv_Seq (\{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] + y[n] \}\)
    /\ lim \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] + y[n] \}\ = lim x + lim y.
Proof.
  intros. destruct H1 as [a [Ha]], H2 as [b [Hb]].
  assert (∀ ε, ε ∈ ℝ /\ 0 < ε -> (∃ N, N ∈ ℕ /\ ∀ n, n ∈ ℕ -> N < n
    -> ｜((x[n] + y[n]) - (a + b))｜ < ε + ε)).
  { intros. destruct H1 as [], H2 as []. apply H4 in H3 as Hc;
    apply H5 in H3 as Hd. destruct Hc as [N1 []], Hd as [N2 []].
    pose proof (Max_nat_2 _ _ H6 H8) as [N [H12 []]]. exists N; split; auto.
    intros. apply (NTrans_Lt _ _ n) in H10; apply (NTrans_Lt _ _ n) in H11; auto.
    apply H7 in H10; apply H9 in H11; auto. pose proof H3 as [He []]. 
    assert (x[n] ∈ ℝ /\ y[n] ∈ ℝ) as [].
    { destruct H as [H []], H0 as [H0 []]. split;
      [apply H18, (@ Property_ran n), Property_Value; auto; rewrite H17; auto|
      apply H20, (@ Property_ran n), Property_Value; auto; rewrite H19; auto]. }
    assert (｜(x[n] - a)｜ + ｜(y[n] - b)｜ < ε + ε).
    { destruct H10. apply OrderPM_Co4; auto with real. }
    assert ((x[n] + y[n]) - (a + b) = x[n] - a + (y[n] - b)).
    { rewrite Minus_P3, (Plus_P4 (- a)), <-Plus_P3, (Plus_P3 y[n]),
      (Plus_P4 _ (- a)), Plus_P3; auto with real. }
    rewrite H20. assert ((x[n] - a) ∈ ℝ /\ (y[n] - b) ∈ ℝ) as [].
    { split; auto with real. }
    pose proof (Abs_P5 (x[n] - a) (y[n] - b) H21 H22) as [Hf [_ _]].
    apply (Order_Co2 _ (｜(x[n] - a)｜ + ｜(y[n] - b)｜) _); auto with real. }
  assert (Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] + y[n] \}\ (a + b)).
  { assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] + y[n] \}\).
    { repeat split.
      - unfold Relation; intros. apply AxiomII in H4 as [_[x0 [y0]]].
        exists x0, y0; tauto.
      - intros. apply AxiomII' in H4 as [_[H4 []]]; 
        apply AxiomII' in H5 as [_[_[]]]. rewrite H8; auto.
      - apply AxiomI; split; intros.
        + apply AxiomII in H4 as [H4 [y0]]. apply AxiomII' in H5; tauto.
        + destruct H as [H []], H0 as [H0 []].
          assert ((x[z] + y[z]) ∈ ℝ).
          { apply Plus_close; [apply H6, (@ Property_ran z), Property_Value;
            auto; rewrite H5; auto|apply H8, (@ Property_ran z),
            Property_Value; auto; rewrite H7; auto]. }
          apply AxiomII; split; eauto. exists (x[z] + y[z]).
          apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
      - unfold Included; intros. apply AxiomII in H4 as [_[]].
        apply AxiomII' in H4; tauto. }
    split; auto; intros. pose proof H5 as [].
    pose proof OrderPM_Co9; pose proof H8 as [].
    assert (0 < 1 + 1).
    { apply (Order_Co2 _ 1 _); auto with real. left; split; auto. 
      apply (Plus_Leq _ _ 1) in H9; auto with real. rewrite Plus_P4,
      Plus_P1 in H9; auto with real. }
    assert (0 < ((1 + 1)⁻)). { apply OrderPM_Co10; auto with real. }
    assert ((1 + 1) ∈ (ℝ ~ [0])). 
    { assert ((1 + 1) ∈ ℝ). { auto with real. }
      apply AxiomII; repeat split; eauto. apply AxiomII; split; eauto.
      intro. apply MKT41 in H14; eauto with real. rewrite H14 in H11.
      destruct H11; eauto. }
    apply Mult_inv1 in H13 as Hg. apply AxiomII in Hg as [_[Hh]].
    assert (ε + ε = ε · (1 + 1)).
    { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
    assert (0 < (ε / (1 + 1))).
    { apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H7; auto with real.
      rewrite Mult_P4, PlusMult_Co1 in H7; auto with real. }
    assert ((ε / (1 + 1)) ∈ ℝ /\ 0 < (ε / (1 + 1))).
    { split; auto. apply Mult_close; auto. }
    apply H3 in H17. destruct H17 as [N []]. exists N; split; auto.
    intros. apply H18 in H20; auto. rewrite <-Mult_P5 in H20; auto.
    (* ****** rewrite H15 in H20. ****** *)
    assert (｜(x[n] + y[n] - (a + b))｜ < ((ε + ε) · ((1 + 1)⁻))); auto.
    rewrite H15, <-Mult_P3, Divide_P1, Mult_P1 in H21; auto with real.
    assert (x[n] + y[n] ∈ ℝ).
    { destruct H as [H []], H0 as [H0 []]. apply Plus_close;
      [apply H23, (@ Property_ran n), Property_Value; auto; rewrite H22; auto|
      apply H25, (@ Property_ran n), Property_Value; auto; rewrite H24; auto]. }
    assert (x[n] + y[n] = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] + y[n] \}\[n]).
    { destruct H4 as [H4 []]. apply Property_Fun; auto.
      apply AxiomII'; repeat split; auto. apply MKT49a; eauto with real. }
    rewrite <-H23; auto. }
  pose proof H4; destruct H5. split.
  - exists (a + b); split; auto with real.
  - apply Lim_getValue in H1, H2, H4; auto with real. rewrite H1, H2, H4; auto.
Qed.

Corollary Corollary2_7a : ∀ x y a b, Seq x -> Seq y -> a ∈ ℝ -> b ∈ ℝ
  -> Limit_Seq x a -> Limit_Seq y b 
  -> Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] + y[n] \}\ (a + b).
Proof.
  intros. apply Lim_getValue in H3 as Ha, H4 as Hb; auto with real.
  assert (Conv_Seq x /\ Conv_Seq y) as [].
  { split; [exists a; split; auto|exists b; split; auto]. }
  pose proof (Theorem2_7a _ _ H H0 H5 H6) as [].
  rewrite Ha, Hb in H8. unfold lim in H8.
  assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] + y[n] \}\).
  { destruct H as [H []], H0 as [H0 []]. repeat split.
    - unfold Relation; intros. apply AxiomII in H13 as [_[x0 [y0]]].
      exists x0, y0; tauto.
    - intros. apply AxiomII' in H13 as [_[H13 []]]; 
      apply AxiomII' in H14 as [_[_[]]]. rewrite H17; auto.
    - apply AxiomI; split; intros.
      + apply AxiomII in H13 as [_[]]. apply AxiomII' in H13 as []; tauto.
      + assert ((x[z] + y[z]) ∈ ℝ).
        { apply Plus_close; [apply H10, (@ Property_ran z), Property_Value;
          auto; rewrite H9; auto|apply H12, (@ Property_ran z), Property_Value;
          auto; rewrite H11; auto]. }
        apply AxiomII; split; eauto. exists (x[z] + y[z]).
        apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
    - unfold Included; intros. apply AxiomII in H13 as [_[]].
      apply AxiomII' in H13; tauto. }
  assert ( ∩\{ λ z, z ∈ ℝ /\ 
    Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] + y[n] \}\ z \} ≠ Φ).
  { apply NEexE. destruct H7 as [v []]. exists v.
    apply AxiomII; split; eauto with real.
Admitted.

(* x,y是收敛数列,则 x-y 收敛,且有 lim(x-y) = limx-limy *)
Theorem Theorem2_7b : ∀ x y, Seq x -> Seq y 
  -> Conv_Seq x -> Conv_Seq y
  -> Conv_Seq (\{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] - y[n] \}\)
    /\ lim \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] - y[n] \}\ = lim x - lim y.
Proof.
  intros. pose proof H1 as Hz. 
  set (y' := \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = - y[n] \}\).
  assert (Function y') as Ha.
  { split; intros.
    - unfold Relation; intros. apply AxiomII in H3 as [_[x0 [y0]]].
      exists x0, y0; tauto.
    - apply AxiomII' in H3 as [_[H3 [H5]]], H4 as [_[_ [H4]]].
      rewrite H7; auto. }
  assert (∀ n, n ∈ ℕ -> - y[n] = y'[n]) as Hb.
  { destruct H0 as [H0 []]; intros. assert (- y[n] ∈ ℝ).
    { apply Plus_neg1a, H4, (@ Property_ran n), Property_Value; auto;
      rewrite H3; auto. }
    apply Property_Fun; auto. apply AxiomII'; repeat split; auto.
    apply MKT49a; eauto. }
  assert (Seq y') as Hc.
  { split; auto; split.
    - apply AxiomI; split; intros.
      + apply AxiomII in H3 as []. destruct H4 as [y0].
        apply AxiomII' in H4; tauto.
      + apply Hb in H3 as H4. assert (y'[z] ∈ ℝ).
        { destruct H0 as [H0 []]. rewrite <-H4. apply Plus_neg1a, H6, 
          (@ Property_ran z), Property_Value; auto; rewrite H5; auto. }
        apply AxiomII; split; eauto. exists y'[z].
        apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
    - unfold Included; intros. apply AxiomII in H3 as [_[x0]].
      apply AxiomII' in H3; tauto. }
  assert (\{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] - y[n] \}\
    = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] + y'[n] \}\) as Hd.
  { apply AxiomI; split; intros.
    - apply AxiomII in H3 as [H3 [x0 [y0 [H4 [H5 []]]]]];
      apply AxiomII; split; auto. exists x0, y0; repeat split; auto.
      apply Hb in H5. rewrite <-H5; auto.
    - apply AxiomII in H3 as [H3 [x0 [y0 [H4 [H5 []]]]]];
      apply AxiomII; split; auto. exists x0, y0; repeat split; auto.
      apply Hb in H5. rewrite H5; auto. }
  destruct H1 as [a [Hf Hg]]; apply Lim_getValue in Hg as Hh; auto. 
  destruct H2 as [b [Hi Hj]]; apply Lim_getValue in Hj as Hk; auto.
  assert (Limit_Seq y' (-b)).
  { split; auto; intros. destruct Hj. apply H3 in H1 as [N []].
    exists N; split; auto; intros. rewrite Minus_P4; auto.
    apply H4 in H6; auto. apply Hb in H5 as H7.
    assert (y'[n] ∈ ℝ).
    { destruct Hc as [Hc []]. apply H9, (@ Property_ran n), Property_Value;
      auto. rewrite H8; auto. }
    assert (y[n] ∈ ℝ).
    { destruct H2 as [H2 []]. apply H10, (@ Property_ran n), Property_Value;
      auto; rewrite H9; auto. }
    apply (RMult_Eq _ _ (-(1))) in H7; auto with real.
    rewrite Mult_P4, <-PlusMult_Co3, Minus_P4, Mult_P4, <-PlusMult_Co3 in H7;
    auto with real. rewrite H7, PlusMult_Co3, Mult_P4 in H6; auto with real.
    assert (- b = b · (-(1))).
    { rewrite PlusMult_Co3, Mult_P4; auto with real. }
    rewrite H10, <-Mult_P5, Mult_P4, <-PlusMult_Co3 in H6; auto with real.
    assert ((y'[n] + b) ∈ ℝ). { auto with real. }
    assert (｜(y'[n] + b)｜ = ｜(- (y'[n] + b))｜). { apply Abs_P2; auto. }
    rewrite H12; auto. }
  apply Lim_getValue in H1 as Hl; auto with real.
  assert (lim y' = - lim y). { rewrite Hl, Hk; auto. }
  assert (Conv_Seq y').
  { exists (- b); split; auto with real. }
  rewrite Hd, <-H2. apply Theorem2_7a; auto.
Qed.

Corollary OrderPM_Co12 : ∀ r1 r2 r3 r4, r1 ∈ ℝ -> r2 ∈ ℝ 
  -> r3 ∈ ℝ -> r4 ∈ ℝ -> 0 ≤ r1 -> 0 ≤ r3 -> r1 < r2 -> r3 < r4 
  -> r1 · r3 < r2 · r4.
Proof.
  intros. destruct (classic (r3 = 0)).
  - rewrite H7, PlusMult_Co1; auto. apply OrderPM_Co5; auto. 
    left; split; [apply (Order_Co2 _ r1 _); auto with real|
    apply (Order_Co2 _ r3 _); auto with real].
  - assert (0 < r3). { split; auto. }
    assert (0 < r2). { apply (Order_Co2 _ r1 _); auto with real. }
    apply (OrderPM_Co7a _ _ r3) in H5; auto.
    apply (OrderPM_Co7a _ _ r2) in H6; auto.
    rewrite Mult_P4, (Mult_P4 r4) in H6; auto.
    destruct H5; apply (Order_Co2 _ (r2 · r3) _); auto with real.
Qed.

(* x,y是收敛数列,则 x*y 收敛,且有 lim(x*y) = limx*limy *)
Theorem Theorem2_7c : ∀ x y, Seq x -> Seq y 
  -> Conv_Seq x -> Conv_Seq y
  -> Conv_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] · y[n] \}\
    /\ lim \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] · y[n] \}\ = lim x · lim y.
Proof.
  intros. pose proof H1; pose proof H2.
  destruct H3 as [a [Ha Hb]], H4 as [b [Hc Hd]].
  pose proof (Theorem2_3 _ H0 H2) as [M [He [Hf]]].
  pose proof H; pose proof H0. destruct H4 as [H4 []], H5 as [H5 []].
  assert (∀ ε, ε ∈ ℝ /\ 0 < ε -> (∃ N, N ∈ ℕ /\ ∀ n, n ∈ ℕ -> N < n 
    -> ｜((x[n] · y[n]) - (a · b))｜ < (M + ｜a｜) · ε)).
  { intros. apply Hb in H10 as Hg; destruct Hg as [N1 []].
    apply Hd in H10 as Hh; destruct Hh as [N2 []].
    pose proof (Max_nat_2 _ _ H11 H13) as [N [H15 []]].
    exists N; split; auto; intros. pose proof H10; destruct H20 as [Hh Hi]. 
    assert (N1 < n /\ N2 < n) as [].
    { split; [apply NTrans_Lt with N; auto|apply NTrans_Lt with N; auto]. }
    apply H12 in H20; apply H14 in H21; auto.
    assert (x[n] ∈ ℝ /\ y[n] ∈ ℝ) as [].
    { split; [apply H7, (@ Property_ran n), Property_Value; auto; 
      rewrite H6; auto| apply H9, (@ Property_ran n), Property_Value; auto;
      rewrite H8; auto]. }
    assert ((x[n] · y[n]) - (a · b) = (x[n] - a) · y[n] + a · (y[n] - b)).
    { assert (a · (y[n] - b) = a · y[n] - a · b).
      { rewrite Mult_P4, Mult_P5, Mult_P4, PlusMult_Co3, <-Mult_P3, 
        (Mult_P4 b), <-PlusMult_Co3; auto with real. }
      rewrite Mult_P5, H24, <-Plus_P3, (Plus_P3 ((-(a)) · y[n])),
      (Plus_P4 ((-(a)) · y[n])); auto with real.
      assert (((-(a)) · y[n]) = - (a · y[n])). 
      { rewrite PlusMult_Co3, <-Mult_P3, <-PlusMult_Co3; auto with real. }
      rewrite H25, Minus_P1, (Plus_P4 0), Plus_P1; auto with real. }
    rewrite H24. assert (｜((x[n] - a) · y[n] + a · (y[n] - b))｜
      ≤ ｜((x[n] - a) · y[n])｜ + ｜(a · (y[n] - b))｜).
    { apply Abs_P5; auto with real. }
    apply (Order_Co2 _ (｜((x[n] - a) · y[n])｜ + ｜(a · (y[n] - b))｜) _);
    auto with real. apply Abs_in_R; auto with real. apply Plus_close;
    auto with real. right; split; auto. rewrite (Mult_P5 M); auto with real.
    assert (｜((x[n] - a) · y[n])｜ = ｜(x[n] - a)｜· ｜(y[n])｜).
    { apply Abs_P3; auto with real. }
    assert (｜(a · (y [n] - b))｜ = ｜a｜· ｜(y[n] - b)｜).
    { apply Abs_P3; auto with real. }
    rewrite H26, H27.
    assert (｜(x[n] - a)｜· ｜(y[n])｜ < M · ε).
    { assert (0 ≤ ｜(x[n] - a)｜). { apply Abs_P1; auto with real. }
      assert (0 ≤ ｜(y[n])｜). { apply Abs_P1; auto. }
      rewrite (Mult_P4 M); auto. destruct (classic (｜(y[n])｜ = M)).
      - rewrite H30. apply OrderPM_Co7a; auto with real.
      - assert (｜(y[n])｜ < M). { apply H3 in H18; split; auto. }
        apply OrderPM_Co12; auto with real. }
    assert (｜a｜ · ｜(y [n] - b)｜ ≤ ｜a｜ · ε).
    { assert (0 ≤ ｜a｜). { apply Abs_P1; auto. }
      rewrite Mult_P4, (Mult_P4 (｜a｜)); auto with real.
      destruct H21; apply OrderPM_Co7b; auto with real. }
    rewrite Plus_P4, (Plus_P4 (M · ε)); auto with real.
    apply OrderPM_Co4; auto with real. }
  assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] · y[n] \}\).
  { repeat split; intros.
    - unfold Relation; intros. apply AxiomII in H11 as [_[x0 [y0]]].
      exists x0, y0; tauto.
    - apply AxiomII' in H11 as [_[H11 []]]; 
      apply AxiomII' in H12 as [_[_[H12]]]. rewrite H15; auto.
    - apply AxiomI; split; intros.
      + apply AxiomII in H11 as [_[y0]]. apply AxiomII' in H11; tauto.
      + assert (x[z] · y[z] ∈ ℝ).
        { apply Mult_close; [apply H7, (@ Property_ran z), Property_Value;
          auto; rewrite H6; auto|apply H9, (@ Property_ran z), Property_Value;
          auto; rewrite H8; auto]. } 
        apply AxiomII; split; eauto. exists (x[z] · y[z]); apply AxiomII';
        split; auto. apply MKT49a; eauto.
    - unfold Included; intros. apply AxiomII in H11 as [_[x0]].
      apply AxiomII' in H11; tauto. }
  assert (Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] · y[n] \}\ (a · b)).
  { split; auto; intros. assert (0 < (M + ｜a｜)).
    { assert (M ≤ (M + ｜a｜)).
      { assert (M + 0 ≤ M + ｜a｜).
        { apply OrderPM_Co3; auto with real. apply Leq_P1; auto.
          apply Abs_P1; auto. }
        rewrite Plus_P1 in H13; auto. }
      apply (Order_Co2 _ M _); auto with real. }
    assert ((M + ｜a｜) ∈ (ℝ ~ [0])).
    { apply MKT4'; split; auto with real.
      apply AxiomII; split; eauto with real. intro. apply MKT41 in H14;
      eauto with real. rewrite H14 in H13. destruct H13; auto. }
    destruct H12. apply Mult_inv1 in H14 as H16. apply MKT4' in H16 as [].
    apply OrderPM_Co10 in H13; auto with real.
    apply (OrderPM_Co7a _ _ ε) in H13; auto with real.
    rewrite Mult_P4, PlusMult_Co1 in H13; auto with real.
    assert ((((M + ｜a｜)⁻) · ε) ∈ ℝ /\ 0 < (((M + ｜a｜)⁻) · ε)).
    { split; auto with real. }
    apply H10 in H18 as [N [H18]]; exists N; split; auto. intros.
    rewrite Mult_P3, Divide_P1, (Mult_P4 1), Mult_P1 in H19; auto with real.
    assert (x[n] · y[n] = 
      \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] · y[n] \}\ [n]).
    { assert (x[n] · y[n] ∈ ℝ).
      { apply Mult_close; [apply H7, (@ Property_ran n), Property_Value;
        auto; rewrite H6; auto|apply H9, (@ Property_ran n), Property_Value;
        auto; rewrite H8; auto]. }
      apply Property_Fun. destruct H11; auto.
      apply AxiomII'; repeat split; auto. apply MKT49a; eauto with real. }
    apply H19 in H21; auto. rewrite <-H22; auto. }
  split. exists (a · b); split; auto with real.
  apply Lim_getValue in Hb, Hd; auto. rewrite Hb, Hd.
  apply Lim_getValue in H12; auto with real.
Qed.

Proposition Abs_Neq_0 : ∀ x, x ∈ ℝ -> x ≠ 0 -> 0 ≠｜x｜ .
Proof.
  intros. intro. elim H0. apply Abs_P1; auto.
Qed.

Proposition Abs_Div : ∀ a b, a ∈ ℝ -> b ∈ ℝ -> b ≠ 0 
  -> ｜(a / b)｜ = ｜a｜ / ｜b｜.
Proof.
  intros. pose proof H; pose proof H0; pose proof OrderPM_Co9.
  assert (b ∈ (ℝ ~ [0])) as Ha.
  { apply MKT4'; split; auto. apply AxiomII; split; eauto. intro.
    apply MKT41 in H5; eauto with real. }
  assert (- b ∈ (ℝ ~ [0])) as Hb.
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto with real.
    intro. apply MKT41 in H5; eauto with real. apply (RMult_Eq _ _ (-(1)))
    in H5; auto with real. rewrite Mult_P4, <-PlusMult_Co3, Minus_P4,
    Mult_P4, PlusMult_Co1 in H5; auto with real. }
  apply Mult_inv1 in Ha as Hc. apply MKT4' in Hc as [Hc _].
  destruct (Leq_P4 b 0) as [|]; auto with real.
  - assert (((b)⁻) ≤ 0) as Hd.
    { assert (b < 0). { split; auto. }
      destruct (Order_Co1 ((b)⁻) 0) as [H7 |[H7 | H7]]; auto with real.
      -- destruct H7; auto.
      -- apply (OrderPM_Co6 b ((b)⁻)) in H7; auto.
         rewrite Divide_P1 in H7; auto. destruct H7, H4.
         elim H8. apply Leq_P2; auto with real.
      -- rewrite H7; apply Leq_P1; auto with real. }
    destruct (Leq_P4 a 0) as [|]; auto with real.
    + pose proof H6. apply (OrderPM_Co8b _ _ ((b)⁻)) in H7; auto with real.
      rewrite Mult_P4, PlusMult_Co1 in H7; auto with real.
      assert (｜(a · (b ⁻))｜= a · (b ⁻)).
      { apply me_zero_Abs; auto with real. }
      assert ((｜a｜ = - a) /\ (｜b｜ = - b)) as [].
      { split; [apply le_zero_Abs; auto|apply le_zero_Abs; auto]. }
      rewrite H8, H9, H10. apply Mult_Co3; auto with real.
      rewrite PlusMult_Co3, <-Mult_P3, (Mult_P4 a), (Mult_P3 b), Divide_P1,
      (Mult_P4 1), Mult_P1, <-PlusMult_Co3; auto with real.
    + pose proof H6. apply (OrderPM_Co8b _ _ ((b)⁻)) in H7; auto with real.
      rewrite (Mult_P4 0), PlusMult_Co1 in H7; auto with real.
      assert (｜(a · (b ⁻))｜= - (a · (b ⁻))).
      { apply le_zero_Abs; auto with real. }
      assert ((｜a｜ = a) /\ (｜b｜ = - b)) as [].
      { split; [apply me_zero_Abs; auto|apply le_zero_Abs; auto]. }
      rewrite H8, H9, H10. apply Mult_Co3; auto with real.
      rewrite PlusMult_Co3, (Mult_P4 (-(1))), <-Mult_P3, <-PlusMult_Co3,
      Minus_P4; auto with real. rewrite (Mult_P4 a), Mult_P3, Divide_P1,
      Mult_P4, Mult_P1; auto with real.
  - assert (0 < (b ⁻)) as []. { apply OrderPM_Co10; auto; split; auto. }
    destruct (Leq_P4 a 0) as [|]; auto with real.
    + pose proof H8. apply (OrderPM_Co7b _ _ ((b)⁻)) in H9; auto with real.
      rewrite (Mult_P4 0), PlusMult_Co1 in H9; auto with real.
      assert (｜(a · (b ⁻))｜= - (a · (b ⁻))).
      { apply le_zero_Abs; auto with real. }
      assert ((｜a｜ = - a) /\ (｜b｜ = b)) as [].
      { split; [apply le_zero_Abs; auto|apply me_zero_Abs; auto]. }
      rewrite H10, H11, H12. rewrite PlusMult_Co3, Mult_P4; auto with real.
      symmetry. rewrite PlusMult_Co3, <-Mult_P3, Mult_P4; auto with real.
    + pose proof H8; apply (OrderPM_Co7b _ _ ((b)⁻)) in H9; auto with real.
      rewrite Mult_P4, PlusMult_Co1 in H9; auto with real.
      assert (｜(a · (b ⁻))｜= (a · (b ⁻))).
      { apply me_zero_Abs; auto with real. }
      assert ((｜a｜ = a) /\ (｜b｜ = b)) as [].
      { split; [apply me_zero_Abs; auto|apply me_zero_Abs; auto]. }
      rewrite H10, H11, H12; auto.
Qed.

Corollary RMult_Distr_Inv : ∀ r1 r2, r1 ∈ (ℝ ~ [0]) -> r2 ∈ (ℝ ~ [0])
  -> (r1 · r2)⁻ = (r1)⁻ · (r2)⁻.
Proof.
  intros. pose proof H; pose proof H0.
  apply MKT4' in H as [H Ha]; apply MKT4' in H0 as [H0 Hb].
  apply Mult_inv1 in H1 as Hc; apply MKT4' in Hc as [Hc _].
  apply Mult_inv1 in H2 as Hd; apply MKT4' in Hd as [Hd _].
  apply AxiomII in Ha as [_ Ha]; apply AxiomII in Hb as [_ Hb].
  assert (r1 · r2 ∈ (ℝ ~ [0])).
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto with real.
    intro. apply MKT41 in H3; eauto with real.
    elim Ha. apply MKT41; eauto with real. apply (RMult_Eq' _ _ r2);
    auto with real. symmetry. rewrite Mult_P4, PlusMult_Co1; auto with real. }
  apply Mult_inv1 in H3; apply MKT4' in H3 as [H3 _].
  assert ((1 / r1) · (1 / r2) = (1 · 1) / (r1 · r2)).
  { apply Frac_P2; auto with real. }
  rewrite (Mult_P4 1), Mult_P1, (Mult_P4 1), Mult_P1 in H4; auto with real.
  rewrite Mult_P1, (Mult_P4 1), Mult_P1 in H4; auto with real.
Qed.

Corollary Abs_Cond : ∀ r, r ∈ (ℝ ~ [0]) -> ｜r｜ ∈ (ℝ ~ [0]).
Proof.
  intros. pose proof H. apply MKT4' in H0 as []. apply AxiomII in H1 as [_ H1].
  apply MKT4'; split; auto with real. apply AxiomII; split; eauto with real.
  intro. elim H1. apply MKT41 in H2; eauto with real.
  apply MKT41; eauto with real. apply Abs_P1; auto.
Qed.

Corollary RTrans_Lt : ∀ x y z, x ∈ ℝ -> y ∈ ℝ -> z ∈ ℝ 
  -> x < y -> y < z -> x < z.
Proof.
  intros. destruct H2. apply (Order_Co2 _ y _); auto.
Qed.

(* y是收敛数列,y(n),lim y均不等于0,则lim /y[n] = /(lim y)  *)
Lemma Lemma2_7d : ∀ y, Seq y -> Conv_Seq y
  -> (∀ n, n ∈ ℕ -> y[n] ≠ 0) -> lim y ≠ 0
  -> Limit_Seq (\{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = (y[n])⁻ \}\) (lim y)⁻.
Proof.
  intros. pose proof H0. destruct H3 as [b [Ha]].
  apply Lim_getValue in H3 as Hb; auto. rewrite Hb in *.
  destruct OrderPM_Co9. pose proof OrderPM_Co9 as Hc.
  assert (0 < 1 + 1) as Hd.
  { apply (Order_Co2 _ 1 _); auto with real. left; split; auto.
    assert (1 + 0 ≤ 1 + 1).
    { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
    rewrite Plus_P1 in H6; auto with real. }
  apply OrderPM_Co10 in Hd as He; auto with real.
  assert (1 + 1 ∈ (ℝ ~ [0])) as Hf.
  { apply MKT4'; split; auto with real.
    apply AxiomII; split; eauto with real. intro. apply MKT41 in H6;
    eauto with real. rewrite H6 in Hd. destruct Hd; auto. }
  apply Mult_inv1 in Hf as Hg. apply MKT4' in Hg as [Hg Hh].
  assert ((1 / (1 + 1)) < 1) as Hi.
  { assert (1 + 0 < (1 + 1)).
    { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
    rewrite Plus_P1 in H6; auto with real.
    apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H6; auto with real.
    rewrite Divide_P1 in H6; auto. }
  assert ((-(1)) < 0) as Hz. { apply OrderPM_Co2a; auto with real. }
  assert (b ∈ ((ℝ ~ [0]))) as Hy.
  { apply MKT4'; split; auto. apply AxiomII; split; eauto. intro.
    apply MKT41 in H6; eauto with real. }
  assert (0 < b· b) as Hx.
  { destruct (Leq_P4 b 0); auto with real.
    - assert (b < 0). { split; auto. } apply OrderPM_Co5; auto.
    - assert (0 < b). { split; auto. } apply OrderPM_Co5; auto. }
  assert (b· b ∈ ℝ) as Hw. { auto with real. }
  assert (b· b ∈ (ℝ ~ [0])) as Hv.
  { apply MKT4'; split; auto. apply AxiomII; split; eauto.
    intro. apply MKT41 in H6; eauto with real.
    rewrite H6 in Hx. destruct Hx; auto. }
  apply Mult_inv1 in Hy as Hu; apply MKT4' in Hu as [Hu _].
  apply Mult_inv1 in Hv as Ht. apply MKT4' in Ht as [Ht _].
  assert (∃ N3, N3 ∈ ℕ /\ ∀ n, n ∈ ℕ -> N3 < n -> ｜b｜ / (1 + 1) < ｜(y[n])｜).
  { destruct (Leq_P4 b 0); auto with real.
    - assert (b < 0). { split; auto. }
      assert (b / (1 + 1) ∈ ℝ /\ b / (1 + 1) ∈ ］b,0［).
      { split; auto with real. 
        apply AxiomII. apply (OrderPM_Co8a _ _ b) in Hi; auto with real.
        rewrite Mult_P4, Mult_P1 in Hi; auto with real.
        rewrite Mult_P4, Mult_P3, Mult_P1 in Hi; auto with real.
        apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H7; auto with real.
        rewrite (Mult_P4 0), PlusMult_Co1 in H7; auto with real.
        split; eauto with real. }
      assert ((∀ a', a' ∈ ℝ /\ a' ∈ ］b,0［
        -> (∃ N, N ∈ ℕ /\ (∀ n, n ∈ ℕ -> N < n -> y[n] < a')))).
      { apply Theorem2_4b; auto. }
      apply H9 in H8 as H10. destruct H10 as [N [H10]]. exists N; split; auto.
      intros. apply H11 in H13; auto. destruct H8 as [_]. 
      assert (y[n] ∈ ℝ).
      { destruct H as [H []]. apply H15, (@ Property_ran n), Property_Value;
        auto; rewrite H14; auto. }
      assert (y[n] < 0).
      { apply AxiomII in H8 as [_[_[_]]]. destruct H13.
        apply (Order_Co2 _ (b / (1 + 1)) _); auto with real. }
      destruct H15. assert (｜b｜ = (- b) /\ ｜(y[n])｜ = (-(y[n]))) as [].
      { split; [apply le_zero_Abs; auto|apply le_zero_Abs; auto]. } 
      rewrite H17, H18. apply (OrderPM_Co8a _ _ (-(1))) in H13; auto with real.
      rewrite Mult_P4, (Mult_P4 (y[n])), <-PlusMult_Co3, <-PlusMult_Co3,
      PlusMult_Co3, Mult_P3, <-PlusMult_Co3 in H13; auto with real.
    - assert (0 < b). { split; auto. }
      assert (b / (1 + 1) ∈ ℝ /\ b / (1 + 1) ∈ ］0,b［).
      { split; auto with real.
        apply AxiomII. apply (OrderPM_Co7a _ _ b) in Hi; auto with real.
        rewrite (Mult_P4 1), Mult_P1, Mult_P4, (Mult_P4 1), Mult_P1 in Hi;
        auto with real. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H7;
        auto with real. rewrite Mult_P4, PlusMult_Co1 in H7; auto with real.
        split; eauto with real. }
      assert ((∀ a', a' ∈ ℝ /\ a' ∈ ］0,b［
        -> (∃ N, N ∈ ℕ /\ (∀ n, n ∈ ℕ -> N < n -> a' < y[n])))).
      { apply Theorem2_4a; auto. }
      apply H9 in H8 as H10. destruct H10 as [N [H10]]. exists N; split; auto.
      intros. apply H11 in H13; auto. destruct H8 as [_].
      assert (y[n] ∈ ℝ).
      { destruct H as [H []]. apply H15, (@ Property_ran n), Property_Value;
        auto; rewrite H14; auto. }
      assert (0 < y[n]).
      { apply AxiomII in H8 as [_[_[H8 _]]]. destruct H8.
        apply (Order_Co2 _ (b / (1 + 1)) _); auto with real. }
      assert (｜b｜ = b /\ ｜(y[n])｜ = (y[n])) as [].
      { destruct H7, H15. split; [apply me_zero_Abs in H7; auto|
        apply me_zero_Abs in H15; auto]. }
      rewrite H16, H17; auto. }
  assert ((∀ ε, ε ∈ ℝ /\ 0 < ε -> (∃ N, N ∈ ℕ /\ ∀ n, n ∈ ℕ -> N < n ->
    ｜((y[n])⁻ - (b)⁻)｜ < (1 + 1) · ε / (b · b)))).
  { intros. pose proof H7 as Hs. destruct Hs as [Hs Hr].
    apply H3 in H7 as [N2 [H7]]. destruct H6 as [N3 [H6]].
    pose proof (Max_nat_2 _ _ H7 H6) as [N [H10 []]]. exists N; split; auto. 
    intros. apply H1 in H13 as Hj.
    assert (N2 < n /\ N3 < n) as [].
    { split; [apply (NTrans_Lt _ N _); auto|apply (NTrans_Lt _ N _); auto]. }
    apply H8 in H15; apply H9 in H16; auto.
    assert (y[n] ∈ ℝ).
    { destruct H as [H []]; apply H18, (@ Property_ran n),Property_Value;
      auto; rewrite H17; auto. }
    assert (y[n] ∈ (ℝ ~ [0])).
    { apply MKT4'; split; auto. apply AxiomII; split; eauto. intro.
      apply MKT41 in H18; eauto with real. }
    apply Mult_inv1 in H18 as Hq; apply MKT4' in Hq as [Hq _].
    assert ((y [n] · b) ∈ ℝ). { auto with real. }
    assert ((y [n] · b) ∈ (ℝ ~ [0])).
    { apply MKT4'; split; auto. apply AxiomII; split; eauto.
      intro. apply MKT41 in H20; eauto with real.
      apply PlusMult_Co2 in H20 as [|]; auto. }
    apply Mult_inv1 in H20 as Hp. apply MKT4' in Hp as [Hp _].
    assert ((1 / y[n]) - (1 / b) = -((y[n] - b) / (y[n] · b))).
    { assert ((1 / y[n]) = (b / (y[n] · b))).
      { assert ((1 / y[n]) = ((1· b) / (y[n] · b))).
        { apply Frac_P1; auto with real. }
        symmetry in H21. rewrite (Mult_P4 1), Mult_P1 in H21; auto with real. }
      assert (1 / b = (y[n] / (y[n] · b))).
      { assert (1 / b = ((1 · y[n]) / (b· y[n]))).
        { apply Frac_P1; auto with real. }
        symmetry in H22. rewrite (Mult_P4 1), Mult_P1, (Mult_P4 b) in H22;
        auto with real. }
      rewrite H21, H22. rewrite PlusMult_Co3, Mult_P3, <-Mult_P5, 
      <-PlusMult_Co3; auto with real. symmetry. rewrite PlusMult_Co3, Mult_P3,
      <-PlusMult_Co3, Minus_P3, Minus_P4, Plus_P4; auto with real. }
    rewrite (Mult_P4 1), Mult_P1, (Mult_P4 1), Mult_P1 in H21; auto with real. 
    rewrite H21. assert (｜((y[n] - b) / (y[n] · b))｜ = 
      ｜(-((y[n] - b) / (y[n] · b)))｜). { apply Abs_P2; auto with real. }
    rewrite <-H22. assert (y[n] · b ≠ 0).
    { intro. elim Hj; apply (RMult_Eq' _ _ b); auto with real.
      rewrite (Mult_P4 0), PlusMult_Co1; auto with real. }
    assert (｜(y[n] · b)｜ = ｜(y[n])｜ · ｜b｜). { apply Abs_P3; auto. }
    rewrite Abs_Div, H24; auto with real.
    assert (0 < ｜(y[n])｜ · ｜b｜).
    { apply OrderPM_Co5; auto with real. left; split.
      split; [apply Abs_P1; auto|intro; elim Hj; apply Abs_P1; auto].
      split; [apply Abs_P1; auto|intro; elim H2; apply Abs_P1; auto]. }
    assert (｜(y [n])｜ · ｜b｜ ∈ ℝ). { auto with real. }
    assert (｜(y [n])｜ · ｜b｜ ∈ (ℝ ~ [0])). 
    { apply MKT4'; split; auto. apply AxiomII; split; eauto.
      intro. apply MKT41 in H27; eauto with real.
      rewrite H27 in H25. destruct H25; auto. }
    assert (0 < (｜(y[n])｜ · ｜b｜)⁻). { apply OrderPM_Co10; auto with real. }
    apply Mult_inv1 in H27 as Ho; apply MKT4' in Ho as [Ho _].
    apply (OrderPM_Co7a _ _ (｜(y[n])｜ · ｜b｜)⁻) in H15 as Hn; auto with real.
    apply (RTrans_Lt _ (ε · ((｜(y[n])｜ · ｜b｜)⁻)) _); auto with real.
    (* Note: 传递右侧证明 *)
    assert (｜b｜ / (1 + 1) ∈ ℝ /\ ｜(y[n])｜ ∈ ℝ) as [].
    { split; auto with real. }
    assert (0 < ｜b｜ / (1 + 1)).
    { apply OrderPM_Co5; auto with real. left; split; auto.
      split; [apply Abs_P1; auto|intro; elim H2; apply Abs_P1; auto]. }
    pose proof (OrderPM_Co11 _ _ H29 H30 H31 H16) as [].
    apply Abs_Cond in Hy as Hl, H18 as Hk.
    apply Mult_inv1 in Hl as HA; apply MKT4' in HA as [HA _].
    apply Mult_inv1 in Hk as HB; apply MKT4' in HB as [HB _].
    rewrite RMult_Distr_Inv, Mult_P3, (Mult_P4 ε), <-Mult_P3; auto with real.
    rewrite <-(Mult_P3 (1 + 1)), (Mult_P4 ε ((b · b)⁻)), (Mult_P3 (1 + 1));
    auto with real. assert (b · b = ｜b｜ · ｜b｜).
    { destruct (Leq_P4 b 0); auto with real.
      - assert (｜b｜ = - b). { apply le_zero_Abs; auto. }
        rewrite H35. rewrite PlusMult_Co3, Mult_P3, (Mult_P4 (((-(1)) · b))),
        <-PlusMult_Co3, <-PlusMult_Co3, Minus_P4; auto with real.
      - assert (｜b｜ = b). { apply me_zero_Abs; auto. }
        rewrite H35; auto. }
    rewrite H34, RMult_Distr_Inv; auto. rewrite <-(Mult_P3 (1 + 1)),
    <-(Mult_P3 (｜b｜⁻)),(Mult_P4 (｜b｜⁻) ε),(Mult_P3 (1 + 1)); auto with real.
    assert (0 < ε · ((｜b｜)⁻)).
    { apply OrderPM_Co5; auto. left; split; auto.
      apply OrderPM_Co10; auto with real.
      split; [apply Abs_P1; auto|intro; elim H2; apply Abs_P1; auto]. }
    apply (OrderPM_Co7a _ _ (ε · ((｜b｜)⁻))); auto with real.
    assert ((1 + 1) · ((｜b｜)⁻) = (｜ b ｜ / (1 + 1))⁻).
    { rewrite RMult_Distr_Inv; auto with real.
      assert ((｜b｜)⁻ / (1 + 1)⁻ = ((｜b｜)⁻ · (1 + 1)) / ((1 + 1)⁻ · (1 + 1))).
      { apply Mult_inv1 in Hf as HC. apply Frac_P1; auto. }
      rewrite (Mult_P4 ((1 + 1)⁻)),Divide_P1,Divide_P2 in H36; auto with real.
      rewrite H36. rewrite Mult_P4; auto with real. }
    (* ****** rewrite <-H36 in H33. ****** *)
    assert ((｜(y[n])｜) ⁻ < (｜b｜ / (1 + 1))⁻); auto. 
    rewrite <-H36 in H37. auto. }
  assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = (y[n])⁻ \}\).
  { destruct H as [H []]. repeat split; intros.
    - unfold Relation; intros. apply AxiomII in H10 as [_[x0 [y0]]];
      exists x0, y0; tauto.
    - apply AxiomII' in H10 as [_[H10 []]];
      apply AxiomII' in H11 as [_[_[H11]]]. rewrite H14; auto.
    - apply AxiomI; split; intros.
      + apply AxiomII in H10 as [H10 []]. apply AxiomII' in H11; tauto.
      + assert (y[z] ∈ ℝ).
        { apply H9, (@ Property_ran z), Property_Value; auto; 
          rewrite H8; auto. }
        assert (y[z] ∈ (ℝ ~ [0])).
        { apply H1 in H10 as Hj. apply MKT4'; split; auto.
          apply AxiomII; split; eauto. intro.
          apply MKT41 in H12; eauto with real. }
        apply Mult_inv1 in H12 as Hk; apply MKT4' in Hk as [Hk _].
        apply AxiomII; split; eauto. exists (y[z]⁻).
        apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
    - unfold Included; intros. apply AxiomII in H10 as [_[x0]].
      apply AxiomII' in H10; tauto. }
  split; auto; intros. pose proof H9; destruct H10 as [].
  assert ((1 + 1)⁻ · ε · (b · b) ∈ ℝ /\ 0 < (1 + 1)⁻ · ε · (b · b)).
  { split; auto with real.
    apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H11; auto with real.
    rewrite Mult_P4, PlusMult_Co1, Mult_P4 in H11; auto with real.
    apply (OrderPM_Co7a _ _ (b · b)) in H11; auto with real.
    rewrite Mult_P4, PlusMult_Co1 in H11; auto with real. }
  apply H7 in H12. destruct H12 as [N []]. exists N; split; auto; intros.
  apply H13 in H15; auto. rewrite <-Mult_P3, <-Mult_P3, Divide_P1, Mult_P1,
  Mult_P3, Divide_P1, Mult_P4, Mult_P1 in H15; auto with real.
  assert ((y[n])⁻ = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = (y[n])⁻ \}\ [n]).
  { destruct H as [H []], H8 as [H8 _].
    assert (y[n] ∈ ℝ).
    { apply H17, (@ Property_ran n), Property_Value; auto; rewrite H16; auto. }
    assert (y[n] ∈ (ℝ ~ [0])).
    { apply H1 in H14 as HD. apply MKT4'; split; auto.
      apply AxiomII; split; eauto. intro.
      apply MKT41 in H19; eauto with real. }
    apply Mult_inv1 in H19 as HE; apply MKT4' in HE as [HE _].
    apply Property_Fun; auto. apply AxiomII'; repeat split; auto. 
    apply MKT49a; eauto. }
  rewrite <-H16; auto.
Qed.

(* x y是收敛数列,y(n), lim y 均不为0, lim(x/y) = limx/limy *)
Theorem Theorem2_7d : ∀ x y, Seq x -> Seq y
  -> Conv_Seq x -> Conv_Seq y
  -> (∀ n, n ∈ ℕ -> y[n] ≠ 0)-> lim y ≠ 0
  -> Conv_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] / y[n] \}\
    /\ lim \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] / y[n] \}\ = lim x / lim y.
Proof.
  intros. pose proof H1; pose proof H2.
  destruct H5 as [a [Ha Hb]], H6 as [b [Hc Hd]].
  apply Lim_getValue in Hb as He; auto; apply Lim_getValue in Hd as Hf; auto.
  pose proof H as Hg; pose proof H0 as Hh.
  destruct Hg as [Hg []], Hh as [Hh []].
  set (y' := \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = (y[n])⁻ \}\).
  assert (Seq y').
  { repeat split; intros.
    - unfold Relation; intros. apply AxiomII in H9 as [_[x0 [y0]]].
      exists x0, y0; tauto.
    - apply AxiomII' in H9 as [_[H9 []]];
      apply AxiomII' in H10 as [_[_ []]]. rewrite H13; auto.
    - apply AxiomI; split; intros.
      + apply AxiomII in H9 as [_[y0]]. apply AxiomII' in H9; tauto.
      + apply H3 in H9 as Hi. assert (y[z] ∈ ℝ).
        { apply H8, (@ Property_ran z), Property_Value; auto;
          rewrite H7; auto. }
        assert (y[z] ∈ (ℝ ~ [0])).
        { apply MKT4'; split; auto. apply AxiomII; split; eauto.
          intro. apply MKT41 in H11; eauto with real. }
        apply Mult_inv1 in H11 as Hj; apply MKT4' in Hj as [Hj _].
        apply AxiomII; split; eauto. exists ((y[z])⁻).
        apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
    - unfold Included; intros. apply AxiomII in H9 as [_[x0]].
      apply AxiomII' in H9; tauto. }
  assert (Limit_Seq y' (b)⁻).
  { rewrite <-Hf. apply Lemma2_7d; auto. }
  pose proof H9 as Hj; destruct H9 as [H9 _].
  assert (∀n, n ∈ ℕ -> (y[n])⁻ = y'[n]).
  { intros. apply H3 in H11 as Hk.
    assert (y[n] ∈ ℝ).
    { apply H8, (@ Property_ran n), Property_Value; auto;
      rewrite H7; auto. }
    assert (y[n] ∈ (ℝ ~ [0])).
    { apply MKT4'; split; auto. apply AxiomII; split; eauto.
      intro. apply MKT41 in H13; eauto with real. }
    apply Mult_inv1 in H13 as Hl; apply MKT4' in Hl as [Hl _].
    apply Property_Fun; auto. apply AxiomII'; repeat split; auto.
    apply MKT49a; eauto. }
  assert (\{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] / y[n] \}\
    = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] · y'[n] \}\).
  { apply AxiomI; split; intros.
    - apply AxiomII in H12 as [H12 [x0 [y0 [H13 [H14 []]]]]].
      apply AxiomII; split; auto. exists x0, y0; repeat split; auto.
      apply H11 in H14. rewrite <-H14; auto.
    - apply AxiomII in H12 as [H12 [x0 [y0 [H13 [H14 []]]]]].
      apply AxiomII; split; auto. exists x0, y0; repeat split; auto.
      apply H11 in H14; rewrite H14; auto. }
  assert (b ∈ (ℝ ~ [0])).
  { rewrite Hf in H4. apply MKT4'; split; auto. apply AxiomII; split; eauto.
    intro. apply MKT41 in H13; eauto with real. }
  apply Mult_inv1 in H13 as Hk; apply MKT4' in Hk as [Hk _].
  assert (lim y' = (lim y)⁻).
  { apply Lim_getValue in H10; auto. rewrite Hf; auto. }
  assert (Conv_Seq y').
  { exists (b)⁻; split; auto. }
  rewrite H12, <-H14. apply Theorem2_7c; auto.
Qed.

(* 定义1 子列(y 是 x 的子列) *)
Definition SubSeq x y := Seq x /\ Seq y
  /\ (∃ f, StrictMonoInc_Fun f /\ dom(f) = ℕ /\ ran(f) ⊂ ℕ
    /\ (∀ n, n ∈ ℕ -> y[n] = x[f[n]])).

(* k ≤ nk *)
Fact K_Leq_Fk  : ∀ f k, Function f -> dom(f) = ℕ -> ran(f) ⊂ ℕ
  -> k ∈ dom(f) -> StrictMonoInc_Fun f -> k ≤ f[k].
Proof.
  intros. set (F:= \{ λ n, n ∈ ℕ /\ n ≤ f[n] \}).
  assert (F = ℕ).
  { apply MathInd_Ma; unfold Included; intros.
    - apply AxiomII in H4; tauto.
    - apply AxiomII; repeat split; eauto with real.
      assert (f[1] ∈ ℕ). 
      { apply H1, (@ Property_ran 1), Property_Value; auto; 
        rewrite H0; auto with real. }
      pose proof one_is_min_in_N. apply H5; auto.
    - apply AxiomII in H4 as [H4 []].
      assert (x ∈ dom(f) /\ (x + 1) ∈ dom(f)) as [].
      { split; [rewrite H0; auto|rewrite H0; auto with real]. }
      assert (f[x] ∈ ℕ /\ f[x + 1] ∈ ℕ) as [].
      { split; [apply H1, (@ Property_ran x), Property_Value; auto
        |apply H1, (@ Property_ran (x + 1)), Property_Value; auto]. }
      apply AxiomII; repeat split; eauto with real.
      assert (f[x] < f[x + 1]).
      { apply H3; auto. apply Nat_P4a; auto with real.
        apply Leq_P1; auto with real. }
      apply Nat_P4; auto. apply (Order_Co2 _ f[x] _); auto with real. }
  rewrite H0, <-H4 in H2. apply AxiomII in H2; tauto.
Qed.

(* 定理2.8 数列收敛的充要条件 *)
Theorem Theorem2_8 : ∀ x, Seq x -> (Conv_Seq x 
  <-> (∀ y, SubSeq x y -> Conv_Seq y)).
Proof.
  split; intros.
  - destruct H0 as [a [Ha [_]]]. destruct H1 as [Hb [Hc [f [Hd [He [Hf]]]]]].
    exists a; split; auto. split; auto; intros.
    apply H0 in H2 as [N [H2]]. exists N; split; auto; intros.
    apply H1 in H4 as H6. rewrite H6. pose proof Hd; destruct Hd.
    assert (n ≤ f[n]).
    { rewrite <-He in H4. apply K_Leq_Fk ; auto. }
    assert (f[n] ∈ ℕ).
    { apply Hf, (@ Property_ran n), Property_Value; auto; rewrite He; auto. }
    assert (N < f[n]). { apply (Order_Co2 _ n _); auto with real. }
    apply H3 in H12; auto.
  - assert (SubSeq x x).
    { unfold SubSeq; split; auto; split; auto.
      exists \{\ λ u v, u ∈ ℕ /\ v ∈ ℕ /\ v = u \}\.
      assert (Function \{\ λ u v, u ∈ ℕ /\ v ∈ ℕ /\ v = u \}\).
      { split; intros.
        --- unfold Relation; intros. apply AxiomII in H1 as [_[x0 [y0]]].
           exists x0, y0; tauto.
        --- apply AxiomII' in H1 as [_[H1 []]], H2 as [_[_[H5]]].
           rewrite H2; auto. }
      assert (StrictMonoInc_Fun \{\ λ u v, u ∈ ℕ /\ v ∈ ℕ /\ v = u \}\).
      { split; auto; intros.
        apply AxiomII in H2 as [_[y1]], H3 as [_[y2]].
        apply AxiomII' in H2 as [Ha [Hb []]], H3 as [Hc [Hd []]].
        assert (y1 = \{\ λ u v, u ∈ ℕ /\ v ∈ ℕ /\ v = u \}\ [x1]).
        { apply Property_Fun; auto. apply AxiomII'; repeat split; auto. }
        assert (y2 = \{\ λ u v, u ∈ ℕ /\ v ∈ ℕ /\ v = u \}\ [x2]).
        { apply Property_Fun; auto; apply AxiomII'; repeat split; auto. }
        rewrite <-H7, <-H8. rewrite H5, H6; auto. }
      split; auto. repeat split.
      -- apply AxiomI; split; intros.
         ++ apply AxiomII in H3 as [_[y0]]. apply AxiomII' in H3; tauto.
         ++ apply AxiomII; split; eauto. exists z.
            apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
      -- unfold Included; intros. apply AxiomII in H3 as[_[x0]].
         apply AxiomII' in H3; tauto.
      -- intros. assert (n = \{\ λ u v, u ∈ ℕ /\ v ∈ ℕ /\ v = u \}\ [n]).
         { apply Property_Fun; auto. apply AxiomII'; repeat split; eauto.
           apply MKT49a; eauto. }
         rewrite <-H4; auto. }
    apply H0 in H1; auto.
Qed.

(* 收敛数列的任意子列具有相同极限 *)
Corollary Lim_SubSeq : ∀ x a, a ∈ ℝ -> Limit_Seq x a -> ∀ y, SubSeq x y
  -> Limit_Seq y a.
Proof.
  intros. destruct H0 as [Ha Hb]. unfold SubSeq in H1.
  destruct H1 as [H1 [H2 [f [H3 [H4 []]]]]]. split; auto; intros.
  apply Hb in H6 as [N [H6]]. exists N; split; auto; intros.
  pose proof H3; destruct H3. assert (f[n] ∈ ℕ).
  { apply H0, (@ Property_ran n), Property_Value; auto; rewrite H4; auto. }
  apply H5 in H8 as Hc. rewrite Hc. apply H7; auto.
  apply (Order_Co2 _ n _); auto with real. rewrite <-H4 in H8.
  left; split; auto. apply K_Leq_Fk ; auto.
Qed.

(* 2.3 数列极限存在的条件 *)

(* 定义：单调递增数列 *)
Definition MonoInc_Seq x := Seq x /\ (∀ n, n ∈ ℕ -> x[n] ≤ x[n + 1]).

(* 定义：单调递减数列 *)
Definition MonoDec_Seq x := Seq x /\ (∀ n, n ∈ ℕ -> x[n + 1] ≤ x[n]).

(* 定义：单调数列 *)
Definition MonotonicSeq x := MonoInc_Seq x \/ MonoDec_Seq x.

(* 定理：单调数列的等价性 *)
Fact MonoInc_Seq_Equal : ∀ x, MonoInc_Seq x
  <-> (Seq x /\ (∀ n1 n2, n1 ∈ ℕ -> n2 ∈ ℕ -> n1 < n2 -> x[n1] ≤ x[n2])).
Proof.
  split; intros. 
  - destruct H. split; auto. intros. destruct H as [Ha [Hb Hc]].
    set (F:= \{ λ n2, n2 ∈ ℕ /\ (∀ n1, n1 ∈ ℕ -> n1 < n2 -> x[n1] ≤ x[n2])\}).
    assert (F = ℕ).
    { apply MathInd_Ma; unfold Included; intros.
      -- apply AxiomII in H; tauto.
      -- apply AxiomII; repeat split; eauto with real.
         intros. pose proof H. apply one_is_min_in_N in H. destruct H4.
         elim H6. apply Leq_P2; auto with real.
      -- apply AxiomII in H as [H [H4]].
         apply AxiomII; repeat split; eauto with real.
         intros. assert (x[n0] ∈ ℝ /\ x[x0] ∈ ℝ ) as [Hd He].
         { split; [apply Hc, (@ Property_ran n0), Property_Value; auto;
           rewrite Hb; auto|apply Hc, (@ Property_ran x0), Property_Value;
           auto; rewrite Hb; auto]. }
         assert (x[x0 + 1] ∈ ℝ) as Hf.
         { apply Hc, (@ Property_ran (x0 + 1)), Property_Value; auto;
           rewrite Hb; auto with real. }
         destruct (Order_Co1 n0 x0) as [H8 | [|]]; auto with real.
         ++ apply H0 in H4 as H9. apply (Leq_P3 _ x[x0] _); auto.
         ++ apply Nat_P4 in H8; auto. apply N_NLt_Ge in H8; auto with real.
            contradiction.
         ++ rewrite H8. apply H0; auto. }
    rewrite <-H in H2. apply AxiomII in H2 as [H2 []]. apply H5; auto.
  - destruct H. split; auto. intros. pose proof OrderPM_Co9.
    assert (n < n + 1).
    { assert (n + 0 < n + 1).
      { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
      rewrite Plus_P1 in H3; auto with real. }
    apply H0; auto with real.
Qed.

Fact MonoDec_Seq_Equal : ∀ x, MonoDec_Seq x
  <-> (Seq x /\ (∀ n1 n2, n1 ∈ ℕ -> n2 ∈ ℕ -> n1 < n2 -> x[n2] ≤ x[n1])).
Proof.
  split; intros.
  - destruct H; split; auto; intros. destruct H as [Ha [Hb Hc]].
    set (F:= \{ λ n2, n2 ∈ ℕ /\ (∀ n1, n1 ∈ ℕ -> n1 < n2 -> x[n2] ≤ x[n1]) \}).
    assert (F = ℕ).
    { apply MathInd_Ma; unfold Included; intros.
      -- apply AxiomII in H; tauto.
      -- apply AxiomII; repeat split; eauto with real. intros.
         apply one_is_min_in_N in H as H5. destruct H4. elim H6.
         apply Leq_P2; auto with real.
      -- apply AxiomII in H as [H []].
         apply AxiomII; repeat split; eauto with real. intros.
         assert (x[n0] ∈ ℝ /\ x[x0] ∈ ℝ) as [].
         { split; [apply Hc, (@ Property_ran n0), Property_Value; auto;
           rewrite Hb; auto| apply Hc, (@ Property_ran x0), Property_Value;
           auto; rewrite Hb; auto]. }
         assert (x[x0 + 1] ∈ ℝ).
         { apply Hc, (@ Property_ran (x0 + 1)), Property_Value; auto;
           rewrite Hb; auto with real. }
         destruct (Order_Co1 n0 x0) as [H11 | [|]]; auto with real.
         ++ apply H0 in H4 as H12. apply (Leq_P3 _ x[x0] _); auto.
         ++ apply Nat_P4 in H11; auto. apply N_NLt_Ge in H11; auto with real.
            contradiction.
         ++ rewrite H11; apply H0; auto. }
    rewrite <-H in H2. apply AxiomII in H2 as [_[]]. apply H4; auto.
  - destruct H; split; auto. intros.
    assert (n < n + 1).
    { assert (n + 0 < n + 1).
      { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
      rewrite Plus_P1 in H2; auto with real. }
    apply H0; auto with real.
Qed.

(* 把用到该定理的全部替换掉 *)
Corollary OrderPM_Co1a : ∀ x y z, x ∈ ℝ -> y ∈ ℝ -> z ∈ ℝ
  -> x + z < y + z -> x < y.
Proof.
  intros. apply (OrderPM_Co1 _ _ (-(z))) in H2; auto with real.
  rewrite <-Plus_P3, <-Plus_P3, Minus_P1, Plus_P1, Plus_P1 in H2;
  auto with real.
Qed.

Corollary Plus_Leq_Cancel : ∀ x y z, x ∈ ℝ -> y ∈ ℝ -> z ∈ ℝ
  -> x + z ≤ y + z -> x ≤ y.
Proof.
  intros. apply (Plus_Leq _ _ (- z)) in H2; auto with real.
  rewrite <-Plus_P3, <-Plus_P3, Minus_P1, Plus_P1, Plus_P1 in H2;
  auto with real.
Qed.

(* 上有界数列 *)
Definition BoundedUp_Seq x := Seq x
  /\ (∃ M, M ∈ ℝ /\ (∀ n, n ∈ ℕ -> x[n] ≤ M)).

(* 下有界数列 *)
Definition BoundedDown_Seq x := Seq x
  /\ (∃ M, M ∈ ℝ /\ (∀ n, n ∈ ℕ -> M ≤ x[n])).

(* 定义：有界数列 *)
Definition BoundedSeq x:= Seq x /\
  (∃ M, M ∈ ℝ /\ (∀ n, n ∈ ℕ -> ｜(x[n])｜ ≤ M)).
  
Fact BoundedSeq_Equal : ∀ x, BoundedSeq x <-> 
  BoundedUp_Seq x /\ BoundedDown_Seq x.
Proof.
  split; intros.
  - destruct H as [H[M[]]]. split.
    + split; auto. exists M; split; auto. intros. apply H1 in H2 as H3.
      assert (x[n] ∈ ℝ).
      { destruct H as [H[]]. apply H5,(@ Property_ran n),Property_Value; auto.
        rewrite H4; auto. }
      assert (0 ≤ M).
      { apply (Leq_P3 _ ｜(x[n])｜ _); auto with real. apply Abs_P1; auto. }
      apply Abs_P4 in H3 as []; auto.
    + split; auto. exists (-M); split; auto with real. intros.
      apply H1 in H2 as H3. assert (x[n] ∈ ℝ).
      { destruct H as [H[]]. apply H5,(@ Property_ran n),Property_Value; auto.
        rewrite H4; auto. }
      assert (0 ≤ M).
      { apply (Leq_P3 _ ｜(x[n])｜ _); auto with real. apply Abs_P1; auto. }
      apply Abs_P4 in H3 as []; auto.
  - destruct H,H as [H[M1[]]],H0 as [H0[M2[]]],H0 as [H0[]].
    assert (∃ M, M ∈ ℝ /\ ｜M1｜ < M /\ ｜M2｜ < M).
    { destruct (Leq_P4 ｜M1｜｜M2｜) as [H7|H7]; auto with real.
      - exists (｜M2｜ + 1); split; auto with real.
        assert (｜M2｜ < ｜M2｜ + 1).
        { assert (｜M2｜ + 0 < ｜M2｜ + 1).
          { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
          rewrite Plus_P1 in H8; auto with real. }
        split; auto. apply (Order_Co2 _ ｜M2｜ _); auto with real.
      - exists (｜M1｜ + 1); split; auto with real.
        assert (｜M1｜ < ｜M1｜ + 1).
        { assert (｜M1｜ + 0 < ｜M1｜ + 1).
          { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
          rewrite Plus_P1 in H8; auto with real. }
        split; auto. apply (Order_Co2 _ ｜M1｜ _); auto with real. }
    destruct H7 as [M[H7[]]]. split; auto. exists M; split; auto. intros.
    assert (0 ≤ M).
    { apply (Order_Co2 _ ｜M1｜ _); auto with real. right; split; auto.
      apply Abs_P1; auto. }
    assert (x[n] ∈ ℝ).
    { apply H6,(@ Property_ran n),Property_Value; auto; rewrite H5; auto. }
    destruct H8,H9. apply Abs_P4 in H8 as [],H9 as []; auto.
    apply Abs_P4; auto. split.
    + apply (Leq_P3 _ M2 _); auto with real.
    + apply (Leq_P3 _ M1 _); auto with real.
Qed.

(* 单调递增上有界数列有极限 *)
Lemma Lemma2_9a : ∀ x, MonoInc_Seq x -> BoundedUp_Seq x
  -> Conv_Seq x.
Proof.
  intros. apply MonoInc_Seq_Equal in H as []. destruct H0 as [[H0[]] [M[]]].
  assert (ran(x) ≠ Φ).
  { apply NEexE. exists x[1]. apply (@ Property_ran 1),Property_Value; auto.
    rewrite H2; auto with real. }
  pose proof (Sup_Inf_Principle _ H3 H6) as [].
  assert (∃ M, UpperBound ran(x) M).
  { exists M; repeat split; auto. intros xn H9. apply AxiomII in H9 as [H9[n]].
    apply Property_dom in H10 as H11. rewrite H2 in H11.
    apply Property_Fun in H10 as H12; auto. rewrite H12. apply H5; auto. }
  apply H7 in H9. destruct H9 as [a[]],H9 as [],H9 as [_[]].
  exists a; split; auto; split; auto. intros.
  pose proof H13 as []. pose proof H15 as [].
  assert (a - ε ∈ ℝ). { auto with real. }
  assert (a - ε < a).
  { apply OrderPM_Co2a in H15; auto. apply (OrderPM_Co1 _ _ a) in H15;
    auto with real. rewrite (Plus_P4 0),Plus_P1,Plus_P4 in H15;
    auto with real. }
  pose proof (H11 _ H18 H19) as [xN[]]. apply AxiomII in H20 as [_[N]].
  apply Property_dom in H20 as H22. rewrite H2 in H22.
  apply Property_Fun in H20; auto. rewrite H20 in H21. exists N; split; auto.
  intros. assert (x[n] ∈ ℝ /\ x[N] ∈ ℝ) as [].
  { rewrite <-H2 in H22,H23. apply Property_dm in H22,H23; auto. }
  assert (a - ε < x[n]).
  { apply H1 in H24; auto. apply (Order_Co2 _ x[N] _); auto with real. }
  assert (x[n] ≤ a).
  { rewrite <-H2 in H23. apply Property_dm in H23; auto. }
  assert (x[n] < a + ε).
  { assert (a < a + ε).
    { apply (OrderPM_Co1 _ _ a) in H15; auto with real.
      rewrite Plus_P4,Plus_P1,Plus_P4 in H15; auto with real. } 
    apply (Order_Co2 _ a _); auto with real. }
  destruct H27,H29. split.
  + apply Abs_P4; auto with real. split.
    * apply (Plus_Leq _ _ (-a)) in H27; auto with real.
      rewrite (Plus_P4 a),<-Plus_P3,Minus_P1,Plus_P1 in H27; auto with real.
    * apply (Plus_Leq _ _ (-a)) in H29; auto with real.
      rewrite (Plus_P4 a),<-Plus_P3,Minus_P1,Plus_P1 in H29; auto with real.
  + intro. assert (x[n] - a ≤ 0).
    { apply (Plus_Leq _ _ (-a)) in H28; auto with real.
      rewrite Minus_P1 in H28; auto. }
    assert (｜(x[n] - a)｜ = - (x[n] - a)). 
    { apply le_zero_Abs; auto with real. }
    rewrite Minus_P3,Minus_P4 in H34; auto with real. rewrite H34 in H32.
    apply (RPlus_Eq _ _ (- a)) in H32; auto with real.
    rewrite <-Plus_P3,Minus_P1,Plus_P1,Plus_P4 in H32; auto with real.
    apply (RMult_Eq _ _ (-(1))) in H32; auto with real.
    rewrite Mult_P4,PlusMult_Co4,Mult_P4,<-PlusMult_Co3,
    Minus_P3,Minus_P4 in H32; auto with real.
Qed.

(* 单调递减下有界数列有极限 *)
Lemma Lemma2_9b : ∀ x, MonoDec_Seq x -> BoundedDown_Seq x
  -> Conv_Seq x.
Admitted.

(* 2.9 单调有界定理 *)
Theorem Theorem2_9 : ∀ x, MonotonicSeq x -> BoundedSeq x -> Conv_Seq x.
Proof.
  intros. apply BoundedSeq_Equal in H0 as []. destruct H as [|].
  - apply Lemma2_9a; auto. 
  - apply Lemma2_9b; auto.
Qed.
 
(*   assert (∃ L, LowerBound ran(x) L).
    { exists (- M). unfold LowerBound; repeat split; auto with real.
      intros xn H2. apply AxiomII in H2 as [_[n]].
      apply Property_Fun in H2 as H3; auto.
      apply Property_dom in H2 as H4; rewrite Hd in H4. rewrite H3.
      assert (x[n] ∈ ℝ).
      { apply He, (@ Property_ran n), Property_Value; auto; rewrite Hd; auto. }
      assert (0 ≤ M).
      { apply (Leq_P3 _ ｜(x[n])｜ _); auto with real. apply Abs_P1; auto. }
      apply H0 in H4. apply Abs_P4 in H4 as [H4 _]; auto. }
    apply Hg in H2 as [a []]. destruct H2, H2 as [_[]]. exists a; split; auto.
    split; auto; intros. destruct H6; pose proof H7; destruct H8.
    assert (a < a + ε).
    { apply (OrderPM_Co1 _ _ a) in H7; auto with real.
      rewrite Plus_P4, Plus_P1, Plus_P4 in H7; auto with real. }
    apply H4 in H10 as [xN []]; auto with real.
    apply AxiomII in H10 as H12. destruct H12 as [_[N]].
    apply Property_Fun in H12 as H13; auto.
    apply Property_dom in H12 as H14; rewrite Hd in H14.
    rewrite H13 in H10, H11. exists N; split; auto; intros.
    assert (x[n] ∈ ℝ).
    { apply He, (@ Property_ran n), Property_Value; auto; rewrite Hd; auto. }
    assert (x[n] < a + ε).
    { apply MonoDec_Seq_Equal in H as []. apply H18 in H16; auto.
      apply (Order_Co2 _ (x[N]) _); auto with real. }
    assert (a ≤ x[n]).
    { rewrite <-Hd in H15. apply Property_dm in H15; auto. }
    assert (a - ε < x[n]).
    { assert (a - ε < a).
      { apply OrderPM_Co2a in H7; auto.
        apply (OrderPM_Co1 _ _ a) in H7; auto with real.
        rewrite Plus_P4, (Plus_P4 0), Plus_P1 in H7; auto with real. }
      apply (Order_Co2 _ a _); auto with real. }
    destruct H18, H20. split.
    + apply Abs_P4; auto with real. split.
      * apply (Plus_Leq_Cancel _ _ a); auto with real.
        rewrite <-Plus_P3, (Plus_P4 (- a)), Minus_P1, Plus_P1, Plus_P4;
        auto with real.
      * apply (Plus_Leq_Cancel _ _ a); auto with real.
        rewrite <-Plus_P3, (Plus_P4 (- a)), Minus_P1, Plus_P1, Plus_P4;
        auto with real.
    + intro. assert (｜(x[n] - a)｜ = (x[n] - a)).
      { apply (Plus_Leq _ _ (- a)) in H19; auto with real.
        rewrite Minus_P1 in H19; auto. apply me_zero_Abs; auto with real. }
      rewrite H24 in H23. apply (RPlus_Eq _ _ a) in H23; auto with real.
      rewrite <-Plus_P3, (Plus_P4 (- a)), Minus_P1, Plus_P1, Plus_P4 in H23;
      auto with real. *)

(* 定义：数列 x 第 n 项之后的最大项 *)
Definition Max_Seq_n x n m := Seq x /\ n ∈ ℕ /\ m ∈ ℕ /\ n < m 
  /\ (∀ i, i ∈ ℕ -> n ≤ i -> x[i] ≤ x[m]).

(* x是有界数列, y是x的子列, 可推得y也是有界数列 *)
Lemma Lemma2_10a : ∀ x y, BoundedSeq x -> SubSeq x y -> BoundedSeq y.
Proof.
  intros. unfold BoundedSeq, SubSeq in *.
  destruct H as [Ha [M [Hb]]], H0 as [_[Hc [f [Hd [He [Hf]]]]]], Hd as [Hd Hg].
  split; auto; exists M; split; auto; intros. rewrite H0; auto.
  apply H. apply Hf, (@ Property_ran n), Property_Value; auto; rewrite He; auto.
Qed.

Print Max.

(* 递归在数学中非常常见。例如，集合论对自然数的正式定义是：1 是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。

递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。 *)

(* f是h的参数，每一个f都可以定义递归函数h,递归函数h的定义与f有关 *)
Definition h f := \{\ λ x y, x ∈ ran(f)
  /\ Max \{ λ v, ∃ m, m ∈ ℕ /\ v = f[m]
    /\ (∩\{ λ k, Min \{ λ u, u ∈ ℕ /\ x = f[u] \} k \}) < m \} y \}\.

Fact Fact_h1 : ∀ f, Seq f -> (Function (h f)).
Proof.
  intros. split; intros.
  - unfold Relation; intros. apply AxiomII in H0 as [H0[x[y[H1[H2]]]]].
    exists x, y; auto.
  - apply AxiomII' in H0 as [_[_]], H1 as [_[_]].
    eapply Max_Corollary; eauto.
Qed.

Fact Fact_h2 : ∀ f, Seq f 
  -> (∀ k, k ∈ ℕ -> ∃ m, m ∈ ℕ /\ Max_Seq_n f k m)
  -> dom(h f) ⊂ ℝ.
Proof.
  intros. red; intros.
  apply AxiomII in H1 as [H1[y]]. apply AxiomII' in H2 as [_[]].
  destruct H as [H[]]; auto.
Qed.

Fact Fact_h3 : ∀ f, Seq f
  -> (∀ k, k ∈ ℕ -> ∃ m, m ∈ ℕ /\ Max_Seq_n f k m)
  -> ran(h f) ⊂ dom(h f).
Proof.
  intros. red; intros y H1. apply AxiomII in H1 as [H1[x]].
  apply AxiomII' in H2 as [H2[H3[_[]]]].
  apply AxiomII in H4 as [H4[m[H6[]]]]. destruct H as [Hz[Hy Hx]].
  apply AxiomII; split; eauto.
  apply H0 in H6 as H9. destruct H9 as [m0[H9[H10[_[_[H11]]]]]].
  assert (Min \{ λ u, u ∈ ℕ /\ y = f[u] \} m).
  { repeat split.
    - red; intros. apply AxiomII in H12 as [_[H12]]; auto with real.
    - apply AxiomII; split; eauto.
    - intros. apply AxiomII in H12 as [_[H12]].
      assert (m ≤ m). { apply Leq_P1; auto with real. }
      apply H in H14; auto. rewrite <-H7 in H14. rewrite H13 in H14. admit.
       }
  assert (∩ \{ λ k, Min \{ λ u, u ∈ ℕ /\ y = f[u] \} k \} = m).
  { replace (\{ λ k, Min \{ λ u, u ∈ ℕ /\ y = f[u] \} k \}) with [m].
    apply MKT44; eauto. apply AxiomI; split; intros.
    - apply MKT41 in H13; eauto. rewrite H13.
      apply AxiomII; split; eauto.
    - apply MKT41; eauto. apply AxiomII in H13 as [_].
      eapply Min_Corollary; eauto. }
  (* 根据条件H0，该集合一定有最大值 *)
  assert (∃ m0, Max \{ λ v, ∃ m, m ∈ ℕ /\ v = f[m]
    /\ (∩\{ λ k, Min \{ λ u, u ∈ ℕ /\ y = f[u] \} k \}) < m \} m0).
  { exists f[m0]. red; repeat split.
    - red; intros. apply AxiomII in H14 as [_[m1[H14[H15]]]]. rewrite H15.
      apply Hx,(@ Property_ran m1),Property_Value; auto. rewrite Hy; auto.
    - assert (f[m0] ∈ ℝ).
      { apply Hx,(@ Property_ran m0),Property_Value; auto; rewrite Hy; auto. }
      apply AxiomII; split; eauto. exists m0; split; auto; split; auto.
      rewrite H13; auto.
    - intros. apply AxiomII in H14 as [_[x1[H14[H15]]]]. rewrite H15.
      apply H; auto. rewrite H13 in H16. destruct H16; auto. }
  destruct H14 as [y0]. exists y0. apply AxiomII'; split; [idtac|split; auto].
  - destruct H14 as [H14[]]. apply AxiomII in H15 as []. apply MKT49a; auto.
  - rewrite H7. apply (@ Property_ran m),Property_Value; auto. rewrite Hy; auto.
Admitted.











(* 取出数列的单调递减子列 *)
(* Theorem SubSeq_Dec : ∀ x, Seq x
  -> exists ! f, Function f /\ dom(f) = ℕ /\ ran(f) ⊂ ℝ
  /\ f[0] = ∩\{ λ u, u ∈ ℝ /\ u = Max_Seq_n x 0 \}
  /\ (∀ n, n ∈ ℕ -> f[PlusOne n] = 
    \{\ λ u v, u ∈ ℝ /\ Max_Seq_n x n v (\{ λ k, k ∈ ℕ /\ FirstMember \{ λ u, u ∈ ℕ /\ x[u] = (f[n]) \} \{\ λ u v, u ∈ ℕ /\ v ∈ ℕ /\ u ≤ v \}\ v \}) \}\  ).  *)
  
(* 取出数列的单调递增子列 *)

(* 数列x的片段有一个最大项x[k] *)
Lemma Lemma2_10b : ∀ x m n, Seq x -> m ∈ ℕ -> n ∈ ℕ -> n ≤ m
  -> (∃ k, k ∈ ℕ /\ n ≤ k /\ k ≤ m 
    /\ (∀ i, i ∈ ℕ -> n ≤ i -> i ≤ m -> x[i] ≤ x[k])).
Proof.
  intros.
Admitted.

(* x是一个数列, 我们可以找到它的一个子列y是单调数列 *)
Lemma Lemma2_10c : ∀ x, Seq x -> (∃ y, SubSeq x y /\ MonotonicSeq y).
Admitted.


(* 2.10 致密性定理：任何有界数列必定有收敛的子列 *)
Theorem Theorem2_10 : ∀ x, BoundedSeq x -> (∃ y, SubSeq x y /\ Conv_Seq y).
Proof.
  Admitted.

(* 2.11 柯西收敛准则 *)
Theorem Theorem2_11 : ∀ x, Seq x -> Conv_Seq x 
  <-> (∀ ε, ε ∈ ℝ /\ 0 < ε -> (∃ N, N ∈ ℕ /\ ∀ n m, n ∈ ℕ -> m ∈ ℕ
    -> N < n -> N < m -> ｜(x[n] - x[m])｜ < ε)).
Proof.
  assert ((1 + 1) ∈ ℝ) as Ha. { auto with real. }
  assert (0 < 1 + 1) as Hb.
  { assert (0 + 0 < 1 + 1).
    { apply OrderPM_Co4; auto with real. apply OrderPM_Co9. }
    rewrite Plus_P1 in H; auto with real. }
  assert (0 < (1 + 1)⁻) as Hc. { apply OrderPM_Co10; auto. }
  assert ((1 + 1) ∈ (ℝ ~ [0])) as Hd.
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto.
    intro. apply MKT41 in H; eauto with real. rewrite H in Hb.
    destruct Hb; auto. }
  apply Mult_inv1 in Hd as He; apply MKT4' in He as [Hf _].
  split; intros.
  - destruct H0 as [A [Hg [_]]]. pose proof H1 as Hh. destruct H1 as [Hi Hj].
    assert (ε / (1 + 1) ∈ ℝ /\ 0 < ε / (1 + 1)).
    { split; auto with real. apply OrderPM_Co5; auto. }
    apply H0 in H1 as H2; destruct H2 as [N1 []].
    apply H0 in H1 as H4; destruct H4 as [N2 []].
    destruct (Max_nat_2 _ _ H2 H4) as [N [H6 []]].
    exists N; split; auto; intros.
    assert (N1 < n /\ N2 < m) as [].
    { split; [apply (NTrans_Lt _ N _); auto|apply (NTrans_Lt _ N _); auto]. }
    apply H3 in H13; auto; apply H5 in H14; auto.
    assert (x[n] ∈ ℝ /\ x[m] ∈ ℝ) as [Hk Hl].
    { destruct H as [H []]. split; [apply H16, (@ Property_ran n),
      Property_Value; auto; rewrite H15; auto| apply H16, (@ Property_ran m),
      Property_Value; auto; rewrite H15; auto]. }
    assert (｜(A - x[m])｜ = ｜(x[m] - A)｜). { apply Abs_P7; auto. }
    apply (Order_Co2 _ (｜(x[n] - A)｜+ ｜(A - x[m])｜) _); auto with real.
    right; split. apply Abs_P8; auto.
    assert (ε + ε = ε · (1 + 1)).
    { rewrite Mult_P4, Mult_P5, (Mult_P4 1), Mult_P1; auto with real. }
    assert (ε = ((ε + ε) · (1 + 1)⁻)).
    { rewrite H16, <-Mult_P3, Divide_P1, Mult_P1; auto. }
    assert (ε = ε / (1 + 1) + ε / (1 + 1)). { rewrite <-Mult_P5; auto. }
    rewrite H18, H15. destruct H13. apply OrderPM_Co4; auto with real.
  - assert (BoundedSeq x).
    { unfold BoundedSeq; split; auto.
      assert (1 ∈ ℝ /\ 0 < 1). { split; auto with real. apply OrderPM_Co9. }
      apply H0 in H1 as [N0 []]. assert (N0 < N0 + 1).
      { apply Nat_P4a; auto with real. apply Leq_P1; auto with real. }
      assert (∀ n, n ∈ ℕ -> N0 < n -> ｜(x[n] - x[N0 + 1])｜ < 1).
      { intros. apply H2; auto with real. }
      assert (x[N0 + 1] ∈ ℝ) as Hz.
      { destruct H as [H []]; apply H6, (@ Property_ran (N0 + 1)),
        Property_Value; auto; rewrite H5; auto with real. }
      assert (∀ n, n ∈ ℕ -> N0 < n -> ｜(x[n])｜ ≤ ｜(x[N0 + 1])｜ + 1).
      { intros. apply H4 in H6 as H7; auto.
        assert (x[n] ∈ ℝ).
        { destruct H as [H []]; apply H9, (@ Property_ran n), Property_Value;
          auto; rewrite H8; auto. }
        assert (｜(x[n])｜ = ｜(x[N0 + 1] + (x[n] - x[N0 + 1]))｜).
        { rewrite (Plus_P4 x[n]), Plus_P3, Minus_P1, Plus_P4, Plus_P1;
          auto with real. }
        apply (Order_Co2 _ (｜(x[N0 + 1])｜ + ｜(x[n] - x[N0 + 1])｜) _);
        auto with real. right; split.
        --- rewrite H9. apply Abs_P5; auto with real.
        --- apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
      set (F:= \{ λ N0, N0 ∈ ℕ
        /\ (∃ M1, M1 ∈ ℝ /\ ∀ n, n ∈ ℕ -> n ≤ N0 -> ｜(x[n])｜ ≤ M1) \}).
      assert (F = ℕ).
      { apply MathInd_Ma; unfold Included; intros.
        --- apply AxiomII in H6; tauto.
        --- apply AxiomII; repeat split; eauto with real.
            assert (x[1] ∈ ℝ).
            { destruct H as [H []]; apply H7, (@ Property_ran 1),
              Property_Value; auto; rewrite H6; auto with real. }
            exists (｜(x[1])｜); split; auto with real. intros.
            assert (n = 1).
            { apply one_is_min_in_N in H7 as H9. apply Leq_P2; auto with real. }
            rewrite H9. apply Leq_P1; auto with real.
        --- apply AxiomII in H6 as [_[H6 [M0 []]]].
            apply AxiomII; repeat split; eauto with real.
            assert (x[x0 + 1] ∈ ℝ).
            { destruct H as [H []]; apply H10, (@ Property_ran (x0 + 1)),
              Property_Value; auto; rewrite H9; auto with real. }
            destruct (Order_Co1 M0 ｜(x[x0 + 1])｜) as [H10 |[H10 | H10]]; 
            auto with real.
            +++ exists (｜(x[x0 + 1])｜); split; auto with real. intros.
                destruct (classic (n = x0 + 1)).
                *** rewrite H13. apply Leq_P1; auto with real.
                *** assert (n < x0 + 1). { split; auto. }
                    assert (n ≤ x0).
                    { apply Nat_P4 in H14; auto with real.
                      apply (Plus_Leq _ _ (-(1))) in H14; auto with real.
                      rewrite <-Plus_P3, Minus_P1, Plus_P1, <-Plus_P3,
                      Minus_P1, Plus_P1 in H14; auto with real. }
                    assert (x[n] ∈ ℝ).
                    { destruct H as [H []]; apply H17, (@ Property_ran n),
                      Property_Value; auto; rewrite H16; auto. }
                    apply (Order_Co2 _ M0 _); auto with real.
            +++ exists M0; split; auto. intros.
                destruct (classic (n = x0 + 1)).
                *** destruct H10. rewrite H13; auto.
                *** assert (n < x0 + 1). { split; auto. }
                    assert (n ≤ x0).
                    { apply Nat_P4 in H14; auto with real.
                      apply (Plus_Leq _ _ (-(1))) in H14; auto with real.
                      rewrite <-Plus_P3, Minus_P1, Plus_P1, <-Plus_P3,
                      Minus_P1, Plus_P1 in H14; auto with real. }
                    apply H8; auto.
           +++ exists M0; split; auto. intros.
               destruct (classic (n = x0 + 1)).
               *** rewrite H10, H13; apply Leq_P1; auto with real.
               *** assert (n < x0 + 1). { split; auto. }
                   assert (n ≤ x0).
                   { apply Nat_P4 in H14; auto with real;
                     apply (Plus_Leq _ _ (-(1))) in H14; auto with real;
                     rewrite <-Plus_P3, Minus_P1, Plus_P1, <-Plus_P3,
                     Minus_P1, Plus_P1 in H14; auto with real. }
                   apply H8; auto. }
      pose proof H1 as Hy; rewrite <-H6 in Hy.
      apply AxiomII in Hy as [_[_[M []]]].
      destruct (Order_Co1 M (｜(x[N0 + 1])｜ + 1)) as [H9 | [H9 | H9]];
      auto with real.
      -- exists (｜(x[N0 + 1])｜ + 1); split; auto with real. intros.
         assert (x[n] ∈ ℝ).
         { destruct H as [H []]. apply H12, (@ Property_ran n), Property_Value;
           auto; rewrite H11; auto. }
         destruct (Order_Co1 n N0) as [H12 | [H12 | H12]]; auto with real.
         ++ destruct H12. apply H8 in H10 as H14; auto.
            apply (Order_Co2 _ M _); auto with real.
         ++ apply H8 in H10 as H13. apply (Order_Co2 _ M _); auto with real.
            rewrite H12; apply Leq_P1; auto with real.
      -- exists M; split; auto. intros.
         assert (x[n] ∈ ℝ).
         { destruct H as [H []]. apply H12, (@ Property_ran n), Property_Value;
           auto; rewrite H11; auto. }
         destruct (Order_Co1 n N0) as [H12 | [H12 | H12]]; auto with real.
         ++ destruct H12; apply H8; auto.
         ++ apply H5 in H10 as H13; auto.
            apply (Order_Co2 _ (｜(x[N0 + 1])｜ + 1) _); auto with real.
         ++ apply H8; auto. rewrite H12; apply Leq_P1; auto with real.
      -- exists M; split; auto. intros.
         destruct (Order_Co1 n N0) as [H12 | [H12 | H12]]; auto with real.
         ++ destruct H12; auto.
         ++ rewrite H9; auto.
         ++ apply H8; auto. rewrite H12; apply Leq_P1; auto with real. }
    apply Theorem2_10 in H1 as [y [Hz Hy]]. destruct Hy as [ξ [Hy Hx]].
    pose proof Hx as H1. destruct H1. apply Lim_getValue in Hx as Hw; auto.
    destruct Hz as [Hz [_[f [Hu [Ht [Hs]]]]]]. exists ξ; split; auto.
    split; auto; intros. destruct H4 as [].
    assert (ε / (1 + 1) ∈ ℝ /\ 0 < ε / (1 + 1)).
    { split; auto with real. apply OrderPM_Co5; auto. }
    apply H0 in H6 as [N []]. exists N; split; auto; intros.
    assert (∀ k, k ∈ ℕ -> N < k -> ｜(x[n] - y[k])｜ < ε / (1 + 1)).
    { intros. assert (∃ nk, nk ∈ ℕ /\ N < nk /\ y[k] = x[nk]).
      { pose proof H10. rewrite <-Ht in H12.
        pose proof Hu. destruct H13 as [H13 _]. apply K_Leq_Fk  in H12; auto.
        assert (f[k] ∈ ℕ).
        { apply Hs, (@ Property_ran k), Property_Value; auto;
          rewrite Ht; auto. }
        assert (N < f[k]). { apply (Order_Co2 _ k _); auto with real. }
        apply H3 in H10 as H16. exists f[k]; split; auto. }
        destruct H12 as [nk [H12 []]]. rewrite H14; auto. }
    set (z:= \{\ λ k v, k ∈ ℕ /\ v ∈ ℝ /\ v = ｜(x[n] - y[k])｜ \}\).
    assert (x[n] ∈ ℝ) as Hv.
    { destruct Hz as [Hz []]. apply H12, (@ Property_ran n), Property_Value;
      auto; rewrite H11; auto. }
    assert (Function z).
    { split; intros.
      -- unfold Relation; intros. apply AxiomII in H11 as [_[x0 [y0]]].
         exists x0, y0; tauto.
      -- apply AxiomII' in H11 as [H11 [H13 [H14]]].
         apply AxiomII' in H12 as [H12 [H16 [H17]]].
         apply MKT49b in H11 as [], H12 as []. rewrite H15, H18; auto. }
    assert (Seq z).
    { split; auto; split.
      -- apply AxiomI; split; intros.
         ++ apply AxiomII in H12 as [_[y0]]. apply AxiomII' in H12; tauto.
         ++ assert (y[z0] ∈ ℝ).
            { destruct H1 as [H1 []]. apply H14, (@ Property_ran z0),
              Property_Value; auto; rewrite H13; auto. }
            assert (｜(x[n] - y[z0])｜ ∈ ℝ). { apply Abs_in_R; auto with real. }
            apply AxiomII; split; eauto. exists ｜(x[n] - y[z0])｜.
            apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
      -- unfold Included; intros. apply AxiomII in H12 as [_[k]].
         apply AxiomII' in H12; tauto. }
    assert (Limit_Seq z ｜(x[n] - ξ)｜).
    { split; auto; intros. destruct Hx as [_ Hx]. apply Hx in H13 as H14.
      destruct H14 as [N0 []], H13. exists N0; split; auto.
      intros. apply H15 in H18 as H19; auto.
      assert (y[n0] ∈ ℝ).
      { destruct H1 as [H1 []]. apply H21, (@ Property_ran n0), 
        Property_Value; auto; rewrite H20; auto. }
      assert (｜(x[n] - y[n0])｜ ∈ ℝ). { auto with real. }
      assert (｜(x[n] - ξ)｜ ∈ ℝ). { auto with real. }
      assert (｜(x[n] - y[n0])｜ = z[n0]).
      { apply Property_Fun; auto. apply AxiomII'; repeat split;
        auto with real. apply MKT49a; eauto. }
      rewrite <-H23. apply (Order_Co2 _ (｜(y[n0] - ξ)｜) _); auto with real.
      right; split; auto.
      assert (y[n0] - ξ = -((x[n] - y[n0]) - (x[n] - ξ))).
      { repeat rewrite Minus_P3, Minus_P4; auto with real. symmetry.
        rewrite (Plus_P4 (x[n])), Plus_P4, <-Plus_P3, (Plus_P3 x[n]),
        Minus_P1, (Plus_P4 0), Plus_P1, Plus_P4; auto with real. }
      assert (｜(x[n] - y[n0] - (x[n] - ξ))｜
        = ｜(-(x[n] - y[n0] - (x[n] - ξ)))｜). { apply Abs_P2; auto with real. }
      rewrite H24, <-H25. apply Abs_P5; auto with real. }
    set (c := \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = ε / (1 + 1) \}\).
    assert (Function c).
    { split; intros.
      -- unfold Relation; intros. apply AxiomII in H14 as [_[x0 [y0]]].
         exists x0, y0; tauto.
      -- apply AxiomII' in H14 as [_[H14 []]], H15 as [_[_[]]].
         rewrite H17, H18; auto. }
    assert (Seq c).
    { split; auto; split.
      -- apply AxiomI; split; intros.
         ++ apply AxiomII in H15 as [_[y0]]. apply AxiomII' in H15; tauto.
         ++ apply AxiomII; split; eauto. exists (ε / (1 + 1)).
            apply AxiomII'; repeat split; auto with real.
            apply MKT49a; eauto with real.
      -- unfold Included; intros. apply AxiomII in H15 as [_[x0]].
         apply AxiomII' in H15; tauto. }
    assert (Limit_Seq c (ε / (1 + 1))).
    { split; auto. intros. destruct H13 as [_]. apply H13 in H16 as H17.
      destruct H17 as [N0 []], H16. exists N0; split; auto. intros.
      assert (ε / (1 + 1) = c[n0]).
      { apply Property_Fun; auto. apply AxiomII'; repeat split;
        auto with real. apply MKT49a; eauto with real. }
      assert (｜0｜ = 0). { apply Abs_P1; auto with real. }
      assert (｜0｜ < ε0). { rewrite H23; auto. }
      rewrite <-H22, Minus_P1; auto with real. }
    assert (Conv_Seq z /\ Conv_Seq c) as [].
    { split; [exists (｜(x[n] - ξ)｜); split; auto with real|
      exists (ε / (1 + 1)); split; auto with real]. }
    assert (ε / (1 + 1) < ε).
    { assert (1 < (1 + 1)).
      { assert (1 + 0 < 1 + 1).
        { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
        rewrite Plus_P1 in H19; auto with real. }
      assert (0 < ε / (1 + 1)).
      { apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H5; auto with real.
        rewrite Mult_P4, PlusMult_Co1 in H5; auto with real. }
      apply (OrderPM_Co7a _ _ (ε / (1 + 1))) in H19; auto with real.
      rewrite Mult_P4, Mult_P1, (Mult_P4 ε), Mult_P3, Divide_P1,
      (Mult_P4 1), Mult_P1, Mult_P4 in H19; auto with real. }
    apply (Order_Co2 _ (ε / (1 + 1)) _); auto with real. right; split; auto.
    apply Lim_getValue in H13 as H20, H16 as H21; auto with real.
    rewrite <-H20, <-H21. apply Theorem2_5; auto.
    exists N; split; auto. intros. 
    assert (y[n0] ∈ ℝ).
    { destruct H1 as [H1 []]. apply H25, (@ Property_ran n0), Property_Value;
      auto; rewrite H24; auto. }
    assert (｜(x[n] - y[n0])｜ ∈ ℝ). { auto with real. }
    assert (｜(x[n] - y[n0])｜ = z[n0]).
    { apply Property_Fun; auto. apply AxiomII'; repeat split; auto with real.
      apply MKT49a; eauto. }
    assert (ε / (1 + 1) = c[n0]).
    { apply Property_Fun; auto. apply AxiomII'; repeat split; auto with real.
      apply MKT49a; eauto with real. }
    rewrite <-H26, <-H27; apply H10; auto.
Qed.

(* 3.1 函数极限的概念 *)

(* R -> R函数 *)
Definition FunctionR_R f := Function f /\ dom(f) = ℝ /\ ran(f) ⊂ ℝ.

(* 区间上的单调函数 *) 

(* x 趋于 ∞ 时的极限 *)
(* 定义1 : x 趋于 +∞ 时的极限*)
Definition Limit_PosInf f A := FunctionR_R f /\ A ∈ ℝ
  /\ (∃ a, a ∈ ℝ /\ ［a, +∞［ ⊂ dom(f) /\ (∀ ε, ε ∈ ℝ /\ 0 < ε 
    -> (∃ M, M ∈ ℝ /\ a ≤ M /\ (∀ x, x ∈ ℝ -> M < x -> ｜(f[x] - A)｜ < ε)))).

(* 定义1' : x 趋于 -∞ 时的极限*)
Definition Limit_NegInf f A := FunctionR_R f /\ A ∈ ℝ
  /\ (∃ a, a ∈ ℝ /\ ］-∞, a］ ⊂ dom(f) /\ (∀ ε, ε ∈ ℝ /\ 0 < ε
    -> (∃ M, M ∈ ℝ /\ M ≤ a /\ (∀ x, x ∈ ℝ -> x < M -> ｜(f[x] - A)｜ < ε)))).
    
(* 定义1'' : x 趋于 ∞ 时的极限*)
Definition Limit_Inf f A := FunctionR_R f /\ A ∈ ℝ
  /\ (∃ a, a ∈ ℝ /\ ］-∞, (-a)］ ∪ ［a, +∞［ ⊂ dom(f)
    /\ (∀ ε, ε ∈ ℝ /\ 0 < ε -> (∃ M, M ∈ ℝ  /\ a ≤ M
      /\ (∀ x, x ∈ ℝ -> M < ｜x｜ -> ｜(f[x] - A)｜ < ε)))).

(* 定理: 函数极限的等价 *)
Theorem Limit_Inf_Equal : ∀ f A, Limit_Inf f A 
  <-> (Limit_PosInf f A /\ Limit_NegInf f A).
Proof.
  assert ((-(1)) < 0) as Ha.
  { pose proof OrderPM_Co9. apply OrderPM_Co2a in H; auto with real. }
  pose proof Ha as Hb; destruct Hb as [Hb Hc].
  split; intros.
  - destruct H as [H [H0 [a [H1 []]]]]. split.
    + split; auto; split; auto. exists a; repeat split; auto.
      * unfold Included; intros. apply H2. apply MKT4; right; auto.
      * intros. apply H3 in H4 as [M [H4 [H5]]].
        exists M; split; auto; split; auto. intros. apply H6; auto.
        assert (x ≤ ｜x｜). { apply Abs_P2; auto. }
        apply (Order_Co2 _ x _); auto with real.
    + split; auto; split; auto. exists (- a); repeat split; auto with real.
      * unfold Included; intros. apply H2. apply MKT4; left; auto.
      * intros. apply H3 in H4 as [M [H4 []]]. exists (- M); split;
        auto with real. split. apply (OrderPM_Co8b _ _ (-(1))) in H5;
        auto with real. rewrite Mult_P4, <-PlusMult_Co3, Mult_P4,
        <-PlusMult_Co3 in H5; auto with real. intros. 
        assert (M < (- x)).
        { apply (OrderPM_Co8a _ _ (-(1))) in H8; auto with real.
          rewrite Mult_P4, <-PlusMult_Co3, Minus_P4,
          Mult_P4, <-PlusMult_Co3 in H8; auto with real. }
        assert ((-x) ≤ ｜(-x)｜). { apply Abs_P2; auto with real. }
        assert (｜x｜ = ｜(-x)｜). { apply Abs_P2; auto. }
        apply H6; auto. rewrite H11.
        apply (Order_Co2 _ (- x) _); auto with real.
  - destruct H, H as [H [H1 [a1 [H2 []]]]], H0 as [_[_[a2 [H5 []]]]].
    split; auto; split; auto.
    assert (∃ a, a ∈ ℝ /\ a1 < a /\ (-a) < a2).
    { destruct (Order_Co1 a1 (-a2)) as [H7 | [H7 |H7]]; auto with real.
      -- exists (-a2 + 1); split; auto with real.
         assert (a1 < -a2 + 1).
         { assert (a1 + 0 < (-a2) + 1).
           { apply OrderPM_Co4; auto with real. apply H7. }
           rewrite Plus_P1 in H8; auto. }
         assert (- (-a2 + 1) < a2).
         { assert (a2 < a2 + 1).
           { assert (a2 + 0 < a2 + 1).
             { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
             rewrite Plus_P1 in H9; auto. }
           rewrite Minus_P3, Minus_P4; auto with real.
           apply (OrderPM_Co1 _ _ (-(1))) in H9; auto with real.
           rewrite <-Plus_P3, Minus_P1, Plus_P1 in H9; auto with real. }
         split; auto.
      -- exists (a1 + 1); split; auto with real.
         assert (a1 < a1 + 1).
         { assert (a1 + 0 < a1 + 1).
           { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
           rewrite Plus_P1 in H8; auto. }
         assert (- (a1 + 1) < a2).
         { assert (-a2 < a1 + 1).
           { assert (-a2 + 0 < a1 + 1).
             { apply OrderPM_Co4; auto with real. apply H7. }
             rewrite Plus_P1 in H9; auto with real. }
           apply (OrderPM_Co8a _ _ (-(1))) in H9; auto with real.
           rewrite Mult_P4, <-PlusMult_Co3, Mult_P4, <-PlusMult_Co3,
           Minus_P4 in H9; auto with real. }
         split; auto.
      -- assert (a1 < a1 + 1).
         { assert (a1 + 0 < a1 + 1).
           { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
           rewrite Plus_P1 in H8; auto. }
         pose proof H8. pattern a1 at 1 in H9. rewrite H7 in H9.
         apply (OrderPM_Co8a _ _ (-(1))) in H9; auto with real.
         rewrite Mult_P4, <-PlusMult_Co3, Mult_P4, <-PlusMult_Co3, Minus_P4
         in H9; auto with real. exists (a1 + 1); split; auto with real. }
    destruct H7 as [a [H7 []]]. exists a; repeat split; auto.
    unfold Included; intros. apply MKT4 in H10 as [|];
    [apply AxiomII in H10 as [H10 []]; apply H0; apply AxiomII; repeat split;
     auto; apply (Order_Co2 _ (-a) _); auto with real
    |apply AxiomII in H10 as [H10 []]; apply H3; apply AxiomII; repeat split;
     auto; apply (Order_Co2 _ a _); auto].
    intros. apply H4 in H10 as H11; apply H6 in H10 as H12.
    destruct H11 as [M1 [H13 []]], H12 as [M2 [H12 []]].
    assert (∃ M, M ∈ ℝ /\ a ≤ M /\ M1 ≤ M /\ (-M) ≤ M2).
    { destruct (Leq_P4 M1 (-M2)) as [H17 | H17]; auto with real.
      -- destruct (Leq_P4 a (-M2)) as [H18 | H18]; auto with real.
         ++ exists (-M2); repeat split; auto with real.
            rewrite Minus_P4; auto. apply Leq_P1; auto.
         ++ exists a; repeat split; auto. apply Leq_P1; auto.
            apply (Leq_P3 _ (-M2) _); auto with real.
            apply (OrderPM_Co8b _ _ (-(1))) in H18; auto with real.
            rewrite Mult_P4, <-PlusMult_Co3, Mult_P4, <-PlusMult_Co3,
            Minus_P4 in H18; auto with real.
      -- destruct (Leq_P4 a M1) as [H18 | H18]; auto.
         ++ exists M1; repeat split; auto. apply Leq_P1; auto.
            apply (OrderPM_Co8b _ _ (-(1))) in H17; auto with real.
            rewrite Mult_P4, <-PlusMult_Co3, Mult_P4, <-PlusMult_Co3,
            Minus_P4 in H17; auto with real.
         ++ exists a; repeat split; auto. apply Leq_P1; auto.
            apply (OrderPM_Co8b _ _ (-(1))) in H17; auto with real.
            rewrite Mult_P4, <-PlusMult_Co3, Mult_P4, <-PlusMult_Co3,
            Minus_P4 in H17; auto with real.
            apply (OrderPM_Co8b _ _ (-(1))) in H18; auto with real.
            rewrite Mult_P4, <-PlusMult_Co3, Mult_P4, <-PlusMult_Co3 in H18;
            auto with real. apply (Leq_P3 _ (- M1) _); auto with real. }
    destruct H17 as [M [H17 [H18 []]]]. exists M; split; auto; split; auto.
    intros. destruct (Leq_P4 x 0) as [H23 | H23]; auto with real.
    + assert (｜x｜ = -x). { apply le_zero_Abs; auto. }
      rewrite H24 in H22. apply H16; auto.
      apply (OrderPM_Co8a _ _ (-(1))) in H22; auto with real.
      rewrite Mult_P4, <-PlusMult_Co3, Minus_P4, Mult_P4, <-PlusMult_Co3
      in H22; auto with real. apply (Order_Co2 _ (-M) _); auto with real.
    + assert (｜x｜ = x). { apply me_zero_Abs; auto. }
      rewrite H24 in H22. apply H14; auto. apply (Order_Co2 _ M _); auto.
Qed.

(* x 趋近于 x0 时函数的极限 *)
(* 定义2：函数极限的 ε-δ 定义 *)
Definition Limit_x0 f x0 A := FunctionR_R f /\ x0 ∈ ℝ /\ A ∈ ℝ
  /\ (∃ δ', δ' ∈ ℝ /\ 0 < δ' /\ Uº(x0 ; δ') ⊂ dom(f)
    /\ (∀ ε, ε ∈ ℝ /\ 0 < ε -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < δ'
        /\ (∀ x, x ∈ ℝ -> 0 < ｜(x - x0)｜ /\ ｜(x - x0)｜ < δ 
          -> ｜(f[x] - A)｜ < ε)))).

(* 定义3：右(左)极限 *)
Definition Limit_Right f x0 A := FunctionR_R f /\ x0 ∈ ℝ /\ A ∈ ℝ
  /\ (∃ δ', δ' ∈ ℝ /\ 0 < δ' /\ U+º(x0 ; δ') ⊂ dom(f)
    /\ (∀ ε, ε ∈ ℝ /\ 0 < ε -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < δ'
        /\ (∀ x, x ∈ ℝ -> x0 < x /\ x < x0 + δ -> ｜(f[x] - A)｜ < ε)))).

Definition Limit_Left f x0 A := FunctionR_R f /\ x0 ∈ ℝ /\ A ∈ ℝ
  /\ (∃ δ', δ' ∈ ℝ /\ 0 < δ' /\ U-º(x0 ; δ') ⊂ dom(f)
    /\ (∀ ε, ε ∈ ℝ /\ 0 < ε -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < δ'
        /\ (∀ x, x ∈ ℝ -> x0 - δ < x /\ x < x0 -> ｜(f[x] - A)｜ < ε)))).

(* 定理3.1 *)
Theorem Theorem3_1 : ∀ f x0 A, Limit_x0 f x0 A
  <-> (Limit_Right f x0 A /\ Limit_Left f x0 A).
Proof.
  pose proof OrderPM_Co9 as Hz. pose proof Hz as Hy. destruct Hy as [Hy Hx].
  assert ((-(1)) ∈ (ℝ ~ [0])) as Hw.
  { apply MKT4'; split; auto with real. apply AxiomII; split;
    eauto with real. intro. apply MKT41 in H; eauto with real.
    apply (RMult_Eq _ _ (-(1))) in H; auto with real.
    rewrite <-PlusMult_Co3, Minus_P4, Mult_P4, PlusMult_Co1 in H;
    auto with real. }
  apply Mult_inv1 in Hw as Hv. apply MKT4' in Hv as [Hv _].
  assert (-(1) < 0) as Hu. { apply OrderPM_Co2a; auto with real. }
  pose proof Hu as Ht. destruct Ht as [Ht _].
  split; intros.
  - destruct H as [H [H1 [H2 [δ' [H3 [H4 []]]]]]]. pose proof H4 as Ha.
    destruct Ha as [Ha Hb]. split.
    + split; auto; repeat split; auto.
      exists δ'; split; auto; split; auto; split.
      * unfold Included; intros. apply H0. apply AxiomII in H6 as [H6 [H7 []]].
        destruct H8, H9. apply AxiomII; split; auto; split; auto; split.
        -- split.
           ++ apply Abs_P1; auto with real.
           ++ intro. elim H10. apply (RPlus_Eq' _ _ (-x0)); auto with real.
              rewrite Minus_P1; auto. symmetry. apply Abs_P1; auto with real.
        -- split.
           ++ apply Abs_P4; auto with real. split.
              assert (x0 - δ' ≤ x0).
              { assert (x0 - δ' ≤ x0 + 0).
                { apply OrderPM_Co3; auto with real. apply Leq_P1; auto.
                  apply OrderPM_Co2b; auto. }
                rewrite Plus_P1 in H12; auto. }
              apply (Plus_Leq_Cancel _ _ x0); auto with real.
              rewrite <-Plus_P3, (Plus_P4 (-x0)), Minus_P1, Plus_P1, Plus_P4;
              auto with real. apply (Leq_P3 _ x0 _); auto with real.
              apply (Plus_Leq _ _ (-x0)) in H9; auto with real.
              rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1 in H9;
              auto with real.
           ++ intro. elim H11. assert (0 ≤ z - x0).
              { apply (Plus_Leq _ _ (-x0)) in H8; auto with real.
                rewrite Minus_P1 in H8; auto. }
              apply (RPlus_Eq' _ _ (-x0)); auto with real.
              rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1;
              auto with real. rewrite <-H12. symmetry.
              apply me_zero_Abs; auto with real.
      * intros. apply H5 in H6 as H7. destruct H7 as [δ [H7 [H8 []]]].
        exists δ; do 3 (split; auto); intros. destruct H12. apply H10; auto.
        pose proof H8 as Hc. destruct Hc as [Hc Hd]. destruct H12, H13; split.
        -- split.
           ++ apply Abs_P1; auto with real.
           ++ intro. elim H14. apply (RPlus_Eq' _ _ (-x0)); auto with real.
              rewrite Minus_P1; auto. symmetry. apply Abs_P1; auto with real.
        -- split.
           ++ apply Abs_P4; auto with real. split.
              assert (x0 - δ ≤ x0).
              { assert (x0 - δ ≤ x0 + 0).
                { apply OrderPM_Co3; auto with real. apply Leq_P1; auto.
                  apply OrderPM_Co2b; auto. }
                rewrite Plus_P1 in H16; auto. }
              apply (Plus_Leq_Cancel _ _ x0); auto with real.
              rewrite <-Plus_P3, (Plus_P4 (-x0)), Minus_P1, Plus_P1, Plus_P4;
              auto with real. apply (Leq_P3 _ x0 _); auto with real.
              apply (Plus_Leq _ _ (-x0)) in H13; auto with real.
              rewrite (Plus_P4 x0) , <-Plus_P3, Minus_P1, Plus_P1 in H13;
              auto with real.
           ++ intro. elim H15. assert (0 ≤ x - x0).
              { apply (Plus_Leq _ _ (-x0)) in H12; auto with real.
                rewrite Minus_P1 in H12; auto. }
              apply (RPlus_Eq' _ _ (-x0)); auto with real.
              rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1;
              auto with real. rewrite <-H16. symmetry.
              apply me_zero_Abs; auto with real.
    + split; auto. repeat split; auto.
      exists δ'; split; auto; split; auto; split.
      * unfold Included; intros. apply H0. apply AxiomII in H6 as [H6 [H7 []]].
        destruct H8, H9. apply AxiomII; split; auto; split; auto; split.
        -- split.
           ++ apply Abs_P1; auto with real.
           ++ intro. elim H11. apply (RPlus_Eq' _ _ (-x0)); auto with real.
              rewrite Minus_P1; auto. apply Abs_P1; auto with real.
        -- split.
           ++ apply Abs_P4; auto with real. split.
              apply (Plus_Leq _ _ (-x0)) in H8; auto with real.
              rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1 in H8;
              auto with real. assert (x0 ≤ x0 + δ').
              { assert (x0 + 0 ≤ x0 + δ').
                { apply OrderPM_Co3; auto with real. apply Leq_P1; auto. }
                rewrite Plus_P1 in H12; auto. }
              apply (Plus_Leq_Cancel _ _ x0); auto with real.
              rewrite <-Plus_P3, (Plus_P4 (-x0)), Minus_P1, Plus_P1, Plus_P4;
              auto with real. apply (Leq_P3 _ x0 _); auto with real.
           ++ intro. elim H10. assert (z - x0 ≤ 0).
              { apply (Plus_Leq _ _ (-x0)) in H9; auto with real.
                rewrite Minus_P1 in H9; auto. }
              apply (RPlus_Eq' _ _ (-x0)); auto with real.
              rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1;
              auto with real. apply (RMult_Eq' _ _ (-(1))); auto with real.
              rewrite Mult_P4, <-PlusMult_Co3, Minus_P4, Mult_P4, 
              <-PlusMult_Co3; auto with real. rewrite <-H12.
              apply le_zero_Abs; auto with real.
      * intros. apply H5 in H6 as H7. destruct H7 as [δ [H7 [H8 []]]].
        exists δ; split; auto; split; auto; split; auto. intros. destruct H12.
        apply H10; auto. pose proof H8 as Hc. destruct Hc as [Hc Hd].
        destruct H12, H13. split.
        -- split.
           ++ apply Abs_P1; auto with real.
           ++ intro. elim H15. apply (RPlus_Eq' _ _ (-x0)); auto with real.
              rewrite Minus_P1; auto. apply Abs_P1; auto with real.
        -- split.
           ++ apply Abs_P4; auto with real. split.
              apply (Plus_Leq _ _ (-x0)) in H12; auto with real.
              rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1 in H12;
              auto with real. apply (Plus_Leq _ _ (-x0)) in H13;
              auto with real. rewrite Minus_P1 in H13; auto.
              apply (Leq_P3 _ 0 _); auto with real.
           ++ intro. elim H14. assert (x - x0 ≤ 0).
              { apply (Plus_Leq _ _ (-x0)) in H13; auto with real.
                rewrite Minus_P1 in H13; auto. }
              apply (RPlus_Eq' _ _ (-x0)); auto with real.
              rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1;
              auto with real. apply (RMult_Eq' _ _ (-(1))); auto with real.
              rewrite Mult_P4, <-PlusMult_Co3, Minus_P4, Mult_P4,
              <-PlusMult_Co3; auto with real. rewrite <-H16.
              apply le_zero_Abs; auto with real.
  - destruct H, H as [H [H1 [H2 [δ1' [H3 [H4 [H5 H6]]]]]]],
    H0 as [_[_[_[δ2' [H0 [H7 [H8 H9]]]]]]].
    split; auto; split; auto; split; auto.
    assert (∃ δ', δ' ∈ ℝ /\ 0 < δ' /\ δ' ≤ δ1' /\ δ' ≤ δ2').
    { destruct (Leq_P4 δ1' δ2') as [H10 | H10]; auto.
      -- exists δ1'; do 3 (split; auto); apply Leq_P1; auto.
      -- exists δ2'; do 3 (split; auto); apply Leq_P1; auto. }
    destruct H10 as [δ' [H10 [H11 []]]].
    exists δ'; split; auto; split; auto; split.
    + unfold Included; intros. apply AxiomII in H14 as [H14 [H15 []]].
      destruct H11, H16, H17. apply Abs_P4 in H17 as []; auto with real.
      destruct (Leq_P4 (z - x0) 0) as [H22 | H22]; auto with real.
      * apply H8. apply AxiomII; split; auto; split; auto; split.
        -- apply (OrderPM_Co1a _ _ (-x0)); auto with real.
           rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1; auto with real.
           apply (OrderPM_Co8b _ _ (-(1))) in H13; auto with real.
           rewrite Mult_P4, <-PlusMult_Co3, Mult_P4, <-PlusMult_Co3 in H13;
           auto with real. apply (Order_Co2 _ (-δ') _); auto with real.
           right; repeat split; auto. intro. elim H20. rewrite <-H23.
           assert (｜δ'｜ = δ'). { apply me_zero_Abs; auto. }
           pattern δ' at 2. rewrite <-H24. symmetry. apply Abs_P2; auto.
        -- apply (OrderPM_Co1a _ _ (-x0)); auto with real.
           rewrite Minus_P1; auto. split; auto. intro. elim H19.
           rewrite H23; symmetry. apply me_zero_Abs; auto with real.
           apply Leq_P1; auto with real.
      * apply H5. apply AxiomII; split; auto; split; auto; split.
        -- apply (OrderPM_Co1a _ _ (-x0)); auto with real.
           rewrite Minus_P1; auto. split; auto. intro. elim H19.
           rewrite <-H23; symmetry. apply me_zero_Abs; auto with real.
           apply Leq_P1; auto with real.
        -- apply (OrderPM_Co1a _ _ (-x0)); auto with real.
           rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1; auto with real.
           apply (Order_Co2 _ δ' _); auto with real. left; split; auto.
           split; auto. intro. elim H20. rewrite H23. apply me_zero_Abs; auto.
    + assert (1 + 1 ∈ ℝ) as Hs. { auto with real. }
      assert (0 < 1 + 1) as Hr.
      { assert (0 + 0 < 1 + 1).
        { apply OrderPM_Co4; auto with real. }
        rewrite Plus_P1 in H14; auto with real. }
      assert (0 < (1 + 1)⁻) as Hq. { apply OrderPM_Co10; auto. }
      assert (1 + 1 ∈ (ℝ ~ [0])) as Hp.
      { apply MKT4'; split; auto with real. apply AxiomII; split; eauto.
        intro. apply MKT41 in H14; eauto with real. destruct Hr; auto. }
      apply Mult_inv1 in Hp as Ho; apply MKT4' in Ho as [Ho _].
      intros. apply H6 in H14 as H15. apply H9 in H14 as H16.
      destruct H15 as [δ1 [H15 [H17 []]]], H16 as [δ2 [H20 [H21 []]]].
      assert (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < δ' /\ δ ≤ δ1 /\ δ ≤ δ2).
      { assert (0 < δ' / (1 + 1)) as Ha.
        { apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H11; auto with real.
          rewrite Mult_P4, PlusMult_Co1 in H11; auto with real. }
        assert (δ' < δ' · (1 + 1)) as Hb.
        { assert (δ' + δ' = δ' · (1 + 1)).
          { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
          assert (δ' + 0 < δ' + δ').
          { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
          rewrite <-H23. rewrite Plus_P1 in H24; auto. }
        destruct (Leq_P4 δ1 δ2) as [H23 | H23]; auto.
        -- destruct (Order_Co1 δ1 δ') as [H24 | [H24 | H24]]; auto.
           ++ exists δ1; do 4 (split; auto); apply Leq_P1; auto.
           ++ exists (δ' / (1 + 1)); split; auto with real.
              assert (δ' < δ1 · (1 + 1)).
              { assert (δ1 + δ1 = δ1 · (1 + 1)).
                { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
                assert (δ' + 0 < δ1 + δ1).
                { destruct H24. apply OrderPM_Co4; auto with real. }
                rewrite <-H25. rewrite Plus_P1 in H26; auto. }
              assert (δ' < δ2 · (1 + 1)).
              { assert (δ2 + δ2 = δ2 · (1 + 1)).
                { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
                assert (δ' + 0 < δ2 + δ2).
                { apply OrderPM_Co4; auto with real. apply (Order_Co2 _ δ1 _);
                  auto with real. }
                rewrite <-H26. rewrite Plus_P1 in H27; auto. }
              apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in Hb, H25, H26;
              auto with real.
              rewrite <-Mult_P3, Divide_P1, Mult_P1 in Hb, H25, H26;
              auto with real. destruct H25, H26; auto.
           ++ exists (δ' / (1 + 1)); split; auto with real.
              assert (δ' < δ2 · (1 + 1)).
              { assert (δ2 + δ2 = δ2 · (1 + 1)).
                { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
                assert (δ' + 0 < δ2 + δ2).
                { apply OrderPM_Co4; auto with real. rewrite <-H24; auto. }
                rewrite <-H25. rewrite Plus_P1 in H26; auto. }
              apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in Hb, H25; auto with real.
              rewrite <-Mult_P3, Divide_P1, Mult_P1 in Hb, H25; auto with real.
              rewrite H24. pose proof Hb. destruct H25, H26; auto.
        -- destruct (Order_Co1 δ2 δ') as [H24 | [H24 | H24]]; auto. 
           ++ exists δ2; do 4 (split; auto); apply Leq_P1; auto.
           ++ exists (δ' / (1 + 1)); split; auto with real.
              assert (δ' < δ1 · (1 + 1)).
              { assert (δ1 + δ1 = δ1 · (1 + 1)).
                { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
                assert (δ' + 0 < δ1 + δ1).
                { apply OrderPM_Co4; auto with real. apply (Order_Co2 _ δ2 _);
                  auto with real. }
                rewrite <-H25. rewrite Plus_P1 in H26; auto. }
              assert (δ' < δ2 · (1 + 1)).
              { assert (δ2 + δ2 = δ2 · (1 + 1)).
                { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
                assert (δ' + 0 < δ2 + δ2).
                { destruct H24. apply OrderPM_Co4; auto with real. }
                rewrite <-H26. rewrite Plus_P1 in H27; auto. }
              apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in Hb, H25, H26;
              auto with real.
              rewrite <-Mult_P3, Divide_P1, Mult_P1 in Hb, H25, H26;
              auto with real. destruct H25, H26; auto.
           ++ exists (δ' / (1 + 1)); split; auto with real.
              assert (δ' < δ1 · (1 + 1)).
              { assert (δ1 + δ1 = δ1 · (1 + 1)).
                { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
                assert (δ' + 0 < δ1 + δ1).
                { apply OrderPM_Co4; auto with real. rewrite <-H24; auto. }
                rewrite <-H25. rewrite Plus_P1 in H26; auto. }
              apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in Hb, H25; auto with real.
              rewrite <-Mult_P3, Divide_P1, Mult_P1 in Hb, H25; auto with real.
              rewrite H24. pose proof Hb. destruct H25, H26; auto. }
      destruct H23 as [δ [H23 [H24 [H25 []]]]]. exists δ; split; auto;
      split; auto; split; auto. intros. pose proof H24. destruct H29, H30.
      destruct H29, H31. apply Abs_P4 in H31 as []; auto with real.
      destruct (Leq_P4 (x - x0) 0) as [H36 | H36]; auto with real.
      * apply H22; auto. split.
        -- assert (-δ2 ≤ -δ).
           { apply (OrderPM_Co8b _ _ (-(1))) in H27; auto with real.
             rewrite Mult_P4, <-PlusMult_Co3, Mult_P4, <-PlusMult_Co3 in H27;
             auto with real. }
           apply (OrderPM_Co1a _ _ (-x0)); auto with real.
           rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1; auto with real.
           apply (Order_Co2 _ (-δ) _); auto with real. right; split; auto.
           split; auto. intro; elim H34. rewrite <-H38.
           assert (｜δ｜ = δ). { apply me_zero_Abs; auto. }
           pattern δ at 2. rewrite <-H39; symmetry. apply Abs_P2; auto.
        -- apply (OrderPM_Co1a _ _ (-x0)); auto with real.
           rewrite Minus_P1; auto. split; auto. intro; elim H33.
           symmetry; apply Abs_P1; auto with real.
      * apply H19; auto. split.
        -- apply (OrderPM_Co1a _ _ (-x0)); auto with real.
           rewrite Minus_P1; auto. split; auto. intro; elim H33.
           symmetry; apply Abs_P1; auto with real.
        -- apply (OrderPM_Co1a _ _ (-x0)); auto with real.
           rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1; auto with real.
           apply (Order_Co2 _ δ _); auto with real. left; split; auto.
           split; auto. intro; elim H34. rewrite H37. apply me_zero_Abs; auto.
Qed.


(* 3.2 函数极限的性质 *)

(* 定理3.2 唯一性 *)
Theorem Theorem3_2 : ∀ f x0 A B, Limit_x0 f x0 A -> Limit_x0 f x0 B -> A = B.
Proof.
  pose proof OrderPM_Co9 as Ha; pose proof Ha as [Hb Hc].
  assert (1 + 1 ∈ ℝ) as Hd. { auto with real. }
  assert (0 < 1 + 1) as He.
  { assert (0 + 0 < 1 + 1).
    { apply OrderPM_Co4; auto with real. }
    rewrite Plus_P1 in H; auto with real. }
  assert (0 < (1 + 1)⁻) as Hf. { apply OrderPM_Co10; auto. }
  assert (1 + 1 ∈ (ℝ ~ [0])) as Hg.
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto.
    intro. apply MKT41 in H; eauto with real. destruct He; auto. }
  apply Mult_inv1 in Hg as Hh; apply MKT4' in Hh as [Hh _].
  intros. destruct H as [H [H1 [H2 [δ1' [H3 [H4 [H5 H6]]]]]]].
  destruct H0 as [_[_[H0 [δ2' [H7 [H8 [H9]]]]]]], H as [H [Hz Hy]].
  assert (∀ ε, ε ∈ ℝ /\ 0 < ε -> (｜(A - B)｜ < ε · (1 + 1))).
  { intros. apply H6 in H11 as H12; apply H10 in H11 as H13.
    destruct H12 as [δ1 [H14 [H15 [H16]]]], H13 as [δ2 [H17 [H18 [H19]]]].
    assert (∃ x, x ∈ ℝ /\ (0 < ｜(x - x0)｜ /\ ｜(x - x0)｜ < δ1)
      /\ (0 < ｜(x - x0)｜ /\ ｜(x - x0)｜ < δ2)).
    { assert (0 < δ1 / (1 + 1)) as Hi.
      { apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H15; auto with real.
        rewrite Mult_P4, PlusMult_Co1 in H15; auto with real. }
      assert (0 < δ2 / (1 + 1)) as Hj.
      { apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H18; auto with real.
        rewrite Mult_P4, PlusMult_Co1 in H18; auto with real. }
      pose proof Hi; pose proof Hj. destruct H20, H21.
      assert (｜(δ1 / (1 + 1))｜ = δ1 / (1 + 1)
        /\ ｜(δ2 / (1 + 1))｜ = δ2 / (1 + 1)) as [Hk Hl].
      { split; [apply me_zero_Abs; auto with real|apply me_zero_Abs;
        auto with real]. }
      assert (δ1 + δ1 = δ1 · (1 + 1) /\ δ2 + δ2 = δ2 · (1 + 1)) as [Hm Hn].
      { split; [rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real|
        rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real]. }
      destruct (Order_Co1 δ1 δ2) as [H24 | [H24 | H24]]; auto.
      - exists (x0 + δ1 / (1 + 1)); split; auto with real.
        assert (x0 + δ1 / (1 + 1) - x0 = δ1 / (1 + 1)).
        { rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1; auto with real. }
        rewrite H25. assert (δ1 < δ1 · (1 + 1) /\ δ1 < δ2 · (1 + 1)) as [].
        { assert (δ1 + 0 < δ1 + δ1 /\ δ1 + 0 < δ2 + δ2) as [].
          { split; [apply OrderPM_Co4; auto with real; apply Leq_P1; auto|
            apply OrderPM_Co4; auto with real; destruct H24; auto]. }
        rewrite <-Hm, <-Hn. rewrite Plus_P1 in H26, H27; auto. }
        rewrite Hk. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H26, H27;
        auto with real. rewrite <-Mult_P3, Divide_P1, Mult_P1 in H26, H27; auto.
      - exists (x0 + δ2 / (1 + 1)); split; auto with real.
        assert (x0 + δ2 / (1 + 1) - x0 = δ2 / (1 + 1)).
        { rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1; auto with real. }
        rewrite H25. assert (δ2 < δ1 · (1 + 1) /\ δ2 < δ2 · (1 + 1)) as [].
        { assert (δ2 + 0 < δ1 + δ1 /\ δ2 + 0 < δ2 + δ2) as [].
          { split; [apply OrderPM_Co4; auto with real; destruct H24; auto|
            apply OrderPM_Co4; auto with real; apply Leq_P1; auto]. }
        rewrite <-Hm, <-Hn. rewrite Plus_P1 in H26, H27; auto. }
        rewrite Hl. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H26, H27;
        auto with real. rewrite <-Mult_P3, Divide_P1, Mult_P1 in H26, H27; auto.
      - exists (x0 + δ1 / (1 + 1)); split; auto with real.
        assert (x0 + δ1 / (1 + 1) - x0 = δ1 / (1 + 1)).
        { rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1; auto with real. }
        rewrite H25, <-H24. assert (δ1 < δ1 · (1 + 1)).
        { assert (δ1 + 0 < δ1 + δ1).
          { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
          rewrite <-Hm. rewrite Plus_P1 in H26; auto. }
        rewrite Hk. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H26; auto with real.
        rewrite <-Mult_P3, Divide_P1, Mult_P1 in H26; auto. }
    destruct H20 as [x [H20 [H21 H22]]]. apply H12 in H21; auto.
    apply H13 in H22; auto. destruct H11.
    assert (f[x] ∈ ℝ).
    { apply Hy, (@ Property_ran x), Property_Value; auto; rewrite Hz; auto. }
    assert (ε · (1 + 1) = ε + ε).
    { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
    assert ((f[x] - A) - (f[x] - B) = - (A - B)).
    { rewrite (Plus_P4 f[x]), Minus_P3, <-Plus_P3, (Plus_P3 f[x]), Minus_P1,
      (Plus_P4 0), Plus_P1, Minus_P3, Minus_P4; auto with real. }
    assert (｜(A - B)｜ = ｜(- (A - B))｜).
    { assert (- (A - B) = B - A).
      { rewrite Minus_P3, Minus_P4, Plus_P4; auto with real. }
      rewrite H27. apply Abs_P7; auto. }
    rewrite H25, H27, <-H26.
    assert ((f[x] - A - (f[x] - B)) ∈ ℝ). { auto with real. }
    apply (Order_Co2 _ (｜(f[x] - A)｜ + ｜(f[x] - B)｜) _); auto with real.
    destruct H21. right; split. apply Abs_P5; auto with real.
    apply OrderPM_Co4; auto with real. }
  apply NNPP; intro.
  assert (｜(A - B)｜ / (1 + 1) ∈ ℝ /\ 0 < ｜(A - B)｜ / (1 + 1)).
  { split; auto with real. apply OrderPM_Co5; auto with real.
    left; split; auto. split.
    - apply Abs_P1; auto with real.
    - intro. elim H12. apply (RPlus_Eq' _ _ (-B)); auto with real.
      rewrite Minus_P1; auto. apply Abs_P1; auto with real. }
  apply H11 in H13. rewrite <-Mult_P3, (Mult_P4 (1 + 1)⁻), Divide_P1,
  Mult_P1 in H13; auto with real. destruct H13. elim H14; auto.
Qed.

Proposition Abs_P5a : ∀ x y, x ∈ ℝ -> y ∈ ℝ -> ｜x｜ - ｜y｜ ≤ ｜(x - y)｜.
Proof.
  intros. assert ((x - y) + y = x).
  { rewrite <-Plus_P3, (Plus_P4 (-y)), Minus_P1, Plus_P1; auto with real. }
  assert (｜((x - y) + y)｜ ≤ ｜(x - y)｜ + ｜y｜).
  { apply Abs_P5; auto with real. }
  rewrite H1 in H2. apply (Plus_Leq _ _ (-｜y｜)) in H2; auto with real.
  rewrite <-Plus_P3, Minus_P1, Plus_P1 in H2; auto with real.
Qed.

(* 定理3.3 局部有界性 *)
Theorem Theorem3_3a : ∀ f x0, (∃ A, A ∈ ℝ /\ Limit_x0 f x0 A)
  -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ DBoundedFun f Uº(x0; δ)).
Proof.
  intros. destruct H as [A[]],H0 as [H0[H1[H2[δ'[H3[H4[H5]]]]]]],H0 as [H0[]].
  assert (1 ∈ ℝ /\ 0 < 1). { split; auto with real. apply OrderPM_Co9. }
  apply H6 in H9 as [δ[H9[H10[H11]]]]. exists δ; do 3 (split; auto); split. 
  - unfold Included; intros. apply AxiomII in H13 as [H13[H14[H15]]].
    apply H5. apply AxiomII; do 3 (split; auto).
    apply (RTrans_Lt _ δ _); auto with real.
  - assert (0 < ｜A｜ + 1).
    { assert (0 + 0 < ｜A｜ + 1).
      { apply OrderPM_Co4; auto with real. apply Abs_P1; auto. }
      rewrite Plus_P1 in H13; auto with real. }
    exists (｜A｜ + 1); split; auto with real; split; auto. intros.
    apply AxiomII in H14 as [_[H14]]. apply H12 in H15; auto.
    assert (f[x] ∈ ℝ).
    { apply H8,(@ Property_ran x),Property_Value; auto; rewrite H7; auto. }
    assert (｜(f[x])｜-｜A｜ ≤ ｜(f[x] - A)｜). { apply Abs_P5a; auto with real. }
    apply (Plus_Leq_Cancel _ _ (-｜A｜)); auto with real.
    rewrite (Plus_P4 ｜A｜),<-Plus_P3,Minus_P1,Plus_P1; auto with real.
    apply (Order_Co2 _ ｜(f[x] - A)｜ _); auto with real.
Qed.

Theorem Theorem3_3b : ∀ f x0, (∃ A, A ∈ ℝ /\ Limit_x0 f x0 A)
  -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ (∃ M, M ∈ ℝ /\ 0 < M
      /\ (∀ x, x ∈ Uº(x0; δ) -> ｜(f[x])｜ ≤ M))).
Proof.
  intros. destruct H as [A [H H0]], H0 as [H0 [H1 [H2 [δ' [H3 [H4 [H5]]]]]]].
  assert (1 ∈ ℝ /\ 0 < 1). { split; auto with real. apply OrderPM_Co9. }
  apply H6 in H7 as [δ [H7 [H8 [H9]]]]. exists δ; split; auto; split; auto.
  assert (0 < ｜A｜ + 1).
  { assert (0 + 0 < ｜A｜ + 1).
    { apply OrderPM_Co4; auto with real. apply Abs_P1; auto. }
    rewrite Plus_P1 in H11; auto with real. }
  exists (｜A｜ + 1); split; auto with real; split; auto.
  intros. apply AxiomII in H12 as [_[H12]]. apply H10 in H13; auto.
  assert (f[x] ∈ ℝ).
  { destruct H0 as [H0 []]. apply H15, (@ Property_ran x), Property_Value;
    auto; rewrite H14; auto. }
  assert (｜(f[x])｜-｜A｜ ≤ ｜(f[x] - A)｜). { apply Abs_P5a; auto with real. }
  apply (Plus_Leq_Cancel _ _ (-｜A｜)); auto with real.
  rewrite (Plus_P4 ｜A｜), <-Plus_P3, Minus_P1, Plus_P1; auto with real.
  apply (Order_Co2 _ ｜(f[x] - A)｜ _); auto with real.
Qed.

(* 定理3.4 局部保号性 *)
Theorem Theorem3_4a : ∀ f x0 A, Limit_x0 f x0 A -> 0 < A
  -> (∀ r, r ∈ ℝ /\ 0 < r /\ r < A
    -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ (∀ x, x ∈ Uº(x0; δ) -> 0 < r /\ r < f[x]))).
Proof.
  intros. destruct H as [H[H2[H3[δ'[H4[H5[H6]]]]]]],H1 as [H8[H9]].
  assert (A - r ∈ ℝ /\ 0 < A - r).
  { split; auto with real. apply (OrderPM_Co1 _ _ (-r)) in H1; auto with real.
    rewrite Minus_P1 in H1; auto. }
  apply H7 in H10 as H11. destruct H11 as [δ[H11[H12[]]]], H10 as [_ H10].
  exists δ; split; auto; split; auto. intros; split; auto.
  apply AxiomII in H15 as [_[H15]]. apply H14 in H16; auto.
  assert (f[x] ∈ ℝ).
  { destruct H as [H[]]. apply H18,(@ Property_ran x),Property_Value;
    auto; rewrite H17; auto. }
  destruct H10,H16. apply Abs_P4 in H16 as []; auto with real.
  apply (Plus_Leq _ _ A) in H16; auto with real.
  rewrite <-Plus_P3, (Plus_P4 (-A)), Minus_P1, Plus_P1, Minus_P3, Minus_P4,
  Plus_P4, Plus_P3, Minus_P1, Plus_P4, Plus_P1 in H16; auto with real.
  split; auto. intro; elim H19. rewrite <-H21.
  assert (｜(r - A)｜ = ｜(A - r)｜). { apply Abs_P7; auto. }
  rewrite H22. apply me_zero_Abs; auto with real.
Qed.

Theorem Theorem3_4b : ∀ f x0 A, Limit_x0 f x0 A -> A < 0
  -> (∀ r, r ∈ ℝ /\ 0 < r /\ r < - A
    -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ (∀ x, x ∈ Uº(x0; δ) -> f[x] < -r /\ -r < 0))).
Proof.
  intros. destruct H as [H [H2 [H3 [δ' [H4 [H5 [H6]]]]]]], H1 as [H8 [H9]].
  assert (- A - r ∈ ℝ /\ 0 < - A - r).
  { split; auto with real. apply (OrderPM_Co1 _ _ (-r)) in H1; auto with real.
    rewrite Minus_P1 in H1; auto. }
  apply H7 in H10 as H11. destruct H11 as [δ [H11 [H12 []]]], H10 as [_ H10].
  assert (- r < 0).
  { assert (-(1) < 0). { apply OrderPM_Co2a; auto with real. }
    apply (OrderPM_Co8a _ _ (-(1))) in H9; auto with real.
    rewrite Mult_P4, <-PlusMult_Co3, Mult_P4, PlusMult_Co1 in H9; 
    auto with real. }
  exists δ; split; auto; split; auto. intros; split; auto.
  apply AxiomII in H16 as [_[H16]]. apply H14 in H17; auto.
  assert (f[x] ∈ ℝ).
  { destruct H as [H []]. apply H19, (@ Property_ran x), Property_Value;
    auto; rewrite H18; auto. }
  destruct H10, H17. apply Abs_P4 in H17 as []; auto with real.
  apply (Plus_Leq _ _ A) in H21; auto with real.
  rewrite <-Plus_P3, (Plus_P4 (-A)), Minus_P1, Plus_P1, Plus_P4, Plus_P3,
  Minus_P1, Plus_P4, Plus_P1 in H21; auto with real.
  split; auto. intro; elim H20. rewrite H22, Plus_P4; auto with real.
  apply me_zero_Abs; auto with real.
Qed.

(* 定理3.5 保不等式性 *)
Theorem Theorem3_5 : ∀ f g x0 A B, Limit_x0 f x0 A -> Limit_x0 g x0 B
  -> (∃ δ', δ' ∈ ℝ /\ 0 < δ' /\ (∀ x, x ∈ Uº(x0 ; δ') -> f[x] ≤ g[x]))
  -> A ≤ B.
Proof.
  pose proof OrderPM_Co9 as Ha. pose proof Ha as [Hb Hc].
  assert (1 + 1 ∈ ℝ) as Hd. { auto with real. }
  assert (0 < 1 + 1) as He.
  { assert (0 + 0 < 1 + 1).
    { apply OrderPM_Co4; auto with real. }
    rewrite Plus_P1 in H; auto with real. }
  assert (0 < (1 + 1)⁻) as Hf. { apply OrderPM_Co10; auto. }
  assert (1 + 1 ∈ (ℝ ~ [0])) as Hg.
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto.
    intro. apply MKT41 in H; eauto with real. destruct He; auto. }
  apply Mult_inv1 in Hg as Hh; apply MKT4' in Hh as [Hh _].
  intros. destruct H1 as [δ' [H1 [H2]]].
  destruct H as [H [H4 [H5 [δ1' [H6 [H7 [H8 H9]]]]]]].
  destruct H0 as [H0 [_[H10 [δ2' [H11 [H12 [H13]]]]]]].
  assert (∀ ε, ε ∈ ℝ /\ 0 < ε -> A < B + ε · (1 + 1)).
  { intros. pose proof H15 as Hz. destruct Hz as [Hz [Hy Hx]].
    apply H9 in H15 as H16; apply H14 in H15 as H17.
    destruct H16 as [δ1 [H16 [H18 [H19]]]], H17 as [δ2 [H17 [H21 [H22]]]].
    assert (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ ≤ δ' /\ δ ≤ δ1 /\ δ ≤ δ2).
    { destruct (Leq_P4 δ1 δ2) as [H24 | H24]; auto.
      - destruct (Leq_P4 δ1 δ') as [H25 | H25]; auto.
        + exists δ1; split; auto; split; auto; repeat split; auto.
          apply Leq_P1; auto.
        + exists δ'; split; auto; split; auto; repeat split; auto.
          apply Leq_P1; auto. apply (Leq_P3 _ δ1 _); auto.
      - destruct (Leq_P4 δ2 δ') as [H25 | H25]; auto.
        + exists δ2; split; auto; split; auto; repeat split; auto.
          apply Leq_P1; auto.
        + exists δ'; split; auto; split; auto; repeat split; auto.
          apply Leq_P1; auto. apply (Leq_P3 _ δ2 _); auto. }
    destruct H24 as [δ [H24 [H25 [H26 [H27]]]]].
    assert (∃ x, x ∈ ℝ /\ x ∈ Uº(x0 ; δ')
      /\ (0 < ｜(x - x0)｜ /\ ｜(x - x0)｜ < δ1)
      /\ (0 < ｜(x - x0)｜ /\ ｜(x - x0)｜ < δ2)).
    { assert (x0 + (δ / (1 + 1)) ∈ ℝ). { auto with real. }
      exists (x0 + (δ / (1 + 1))); split; auto with real.
      assert (x0 + (δ / (1 + 1)) - x0 = δ / (1 + 1)).
      { rewrite (Plus_P4 x0), <-Plus_P3, Minus_P1, Plus_P1; auto with real. }
      assert (0 < δ / (1 + 1)).
      { apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H25; auto with real.
        rewrite Mult_P4, PlusMult_Co1 in H25; auto with real. }
      assert (｜(δ / (1 + 1))｜ = (δ / (1 + 1))).
      { destruct H31. apply me_zero_Abs; auto with real. }
      assert (δ' · (1 + 1) = δ' + δ' /\ δ1 · (1 + 1) = δ1 + δ1
        /\ δ2 · (1 + 1) = δ2 + δ2) as [H33 [H34 H35]].
      { repeat split; [rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; 
        auto with real|rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; 
        auto with real|rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; 
        auto with real]. }
      assert (δ < δ' · (1 + 1) /\ δ < δ1 · (1 + 1) /\ δ < δ2 · (1 + 1)).
      { assert (δ + 0 < δ' + δ'). { apply OrderPM_Co4; auto with real. }
        assert (δ + 0 < δ1 + δ1). { apply OrderPM_Co4; auto with real. }
        assert (δ + 0 < δ2 + δ2). { apply OrderPM_Co4; auto with real. }
        rewrite Plus_P1 in H36, H37, H38; auto. rewrite H33, H34, H35; auto. }
      destruct H36 as [H36 [H37 H38]].
      apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H36, H37, H38; auto with real.
      rewrite <-Mult_P3, Divide_P1, Mult_P1 in H36, H37, H38; auto.
      split. apply AxiomII; split; eauto; split; auto. rewrite H30, H32; auto.
      rewrite H30, H32; split; auto. }
    destruct H29 as [x [H29 [H30 [H31]]]].
    assert (ε · (1 + 1) = ε + ε).
    { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
    assert (f[x] ∈ ℝ /\ g[x] ∈ ℝ) as [].
    { destruct H as [H []], H0 as [H0 []]. split;
      [apply H35, (@ Property_ran x), Property_Value; auto; rewrite H34; auto|
      apply H37, (@ Property_ran x), Property_Value; auto; rewrite H36; auto]. }
    apply H3 in H30; auto; apply H20 in H31; auto; apply H23 in H32; auto.
    destruct H31, H32. apply Abs_P4 in H31 as [], H32 as []; auto with real.
    assert (A - ε < B + ε).
    { assert (A - ε < f[x]).
      { apply (Plus_Leq _ _ A) in H31; auto with real.
        rewrite <-Plus_P3, (Plus_P4 (-A)), Minus_P1, Plus_P1, Plus_P4 in H31;
        auto with real. split; auto. intro; elim H36. rewrite <-H40.
        rewrite (Plus_P4 A), <-Plus_P3, Minus_P1, Plus_P1; auto with real.
        assert (｜ε｜ = ｜(- ε)｜). { apply Abs_P2; auto. }
        rewrite <-H41. apply me_zero_Abs; auto. }
      assert (g[x] < B + ε).
      { apply (Plus_Leq _ _ B) in H39; auto with real.
        rewrite <-Plus_P3, (Plus_P4 (-B)), Minus_P1, Plus_P1, Plus_P4 in H39;
        auto with real. split; auto. intro; elim H37. rewrite H41.
        rewrite (Plus_P4 B), <-Plus_P3, Minus_P1, Plus_P1; auto with real.
        apply me_zero_Abs; auto. }
      apply (Order_Co2 _ f[x] _); auto with real. left; split; auto.
      apply (Order_Co2 _ g[x] _); auto with real. }
    apply (OrderPM_Co1 _ _ ε) in H40; auto with real.
    rewrite <-Plus_P3, (Plus_P4 (-ε)), Minus_P1, Plus_P1, <-Plus_P3 in H40;
    auto with real. rewrite H33; auto. }
  apply NNPP; intro.
  assert ((A - B) / (1 + 1) ∈ ℝ /\ 0 < (A - B) / (1 + 1)).
  { apply RNot_Le_Gt in H16; auto. split; auto with real.
    apply OrderPM_Co5; auto with real. left; split; auto.
    apply (OrderPM_Co1 _ _ (-B)) in H16; auto with real.
    rewrite Minus_P1 in H16; auto. }
  apply H15 in H17. rewrite <-Mult_P3, (Mult_P4 (1 + 1)⁻), Divide_P1, Mult_P1,
  (Plus_P4 A), Plus_P3, Minus_P1, (Plus_P4 0), Plus_P1 in H17; auto with real.
  destruct H17; auto.
Qed.

(* 定理3.6 迫敛性 *)
Theorem Theorem3_6 : ∀ f g h x0 A, Limit_x0 f x0 A -> Limit_x0 g x0 A
  -> FunctionR_R h -> (∃ δ', δ' ∈ ℝ /\ 0 < δ' /\ Uº(x0 ; δ') ⊂ dom(h)
    /\ (∀ x, x ∈ Uº(x0 ; δ') -> f[x] ≤ h[x] /\ h[x] ≤ g[x]))
  -> Limit_x0 h x0 A.
Proof.
  pose proof OrderPM_Co9 as Ha. pose proof Ha as [Hb Hc].
  assert (1 + 1 ∈ ℝ) as Hd. { auto with real. }
  assert (0 < 1 + 1) as He.
  { assert (0 + 0 < 1 + 1).
    { apply OrderPM_Co4; auto with real. }
    rewrite Plus_P1 in H; auto with real. }
  assert (0 < (1 + 1)⁻) as Hf. { apply OrderPM_Co10; auto. }
  assert (1 + 1 ∈ (ℝ ~ [0])) as Hg.
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto.
    intro. apply MKT41 in H; eauto with real. destruct He; auto. }
  apply Mult_inv1 in Hg as Hh; apply MKT4' in Hh as [Hh _].
  intros f g h x0 A H H0 H1 H2. destruct H2 as [δ' [H2 [H3 [H4 H5]]]];
  destruct H as [H [H6 [H7 [δ1' [H8 [H9 [H10 H11]]]]]]];
  destruct H0 as [H0 [_[H12 [δ2' [H13 [H14 [H15]]]]]]].
  split; auto. repeat split; auto. exists δ'; split; auto; split; auto;
  split; auto. intros. pose proof H17 as Hz. destruct Hz as [Hz [Hy Hx]].
  apply H11 in H17 as H18; apply H16 in H17 as H19.
  destruct H18 as [δ1 [H18 [H20 [H21 H22]]]], H19 as [δ2 [H19 [H23 [H24]]]].
  assert (δ' · (1 + 1) = δ' + δ' /\ δ1 · (1 + 1) = δ1 + δ1
    /\ δ2 · (1 + 1) = δ2 + δ2) as [Hi [Hj Hk]].
  { repeat split; [rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real|
    rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real|
    rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real]. }
  assert (δ' < δ' · (1 + 1) /\ δ1 < δ1 · (1 + 1) /\ δ2 < δ2 · (1 + 1)).
  { assert (δ' + 0 < δ' + δ').
    { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
    assert (δ1 + 0 < δ1 + δ1).
    { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
    assert (δ2 + 0 < δ2 + δ2).
    { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
    rewrite Plus_P1 in H26, H27, H28; auto. rewrite Hi, Hj, Hk; auto. }
  destruct H26 as [H26 []].
  assert (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < δ' /\ δ < δ1 /\ δ < δ2).
  { destruct (Leq_P4 δ1 δ2) as [H29 | H29]; auto.
    -- destruct (Order_Co1 δ1 δ') as [H30 | [H30 | H30]]; auto.
       ++ exists (δ1 / (1 + 1)); split; auto with real.
          split. apply OrderPM_Co5; auto.
          assert (δ1 < δ' · (1 + 1) /\ δ1 < δ2 · (1 + 1)) as [].
          { assert (δ1 + 0 < δ' + δ' /\ δ1 + 0 < δ2 + δ2) as [].
            { split. apply OrderPM_Co4; auto with real. destruct H30; auto.
              apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H31, H32; auto. rewrite Hi, Hk; auto. }
          apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H27, H31, H32; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H27, H31, H32; auto.
       ++ exists (δ' / (1 + 1)); split; auto with real.
          split. apply OrderPM_Co5; auto.
          assert (δ' < δ1 · (1 + 1) /\ δ' < δ2 · (1 + 1)) as [].
          { assert (δ' + 0 < δ1 + δ1 /\ δ' + 0 < δ2 + δ2) as [].
            { split. apply OrderPM_Co4; auto with real. destruct H30; auto.
              apply OrderPM_Co4; auto with real.
              apply (Order_Co2 _ δ1 _); auto. }
            rewrite Plus_P1 in H31, H32; auto. rewrite Hj, Hk; auto. }
          apply (OrderPM_Co7a _ _ (1 + 1)⁻)in H26, H31, H32; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H26, H31, H32; auto.
       ++ exists (δ' / (1 + 1)); split; auto with real.
          split. apply OrderPM_Co5; auto. rewrite H30.
          assert (δ' < δ2 · (1 + 1)).
          { assert (δ' + 0 < δ2 + δ2).
            { apply OrderPM_Co4; auto with real. rewrite <-H30; auto. }
            rewrite Plus_P1 in H31; auto. rewrite Hk; auto. }
          apply (OrderPM_Co7a _ _ (1 + 1)⁻)in H26, H31; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H26, H31; auto.
    -- destruct (Order_Co1 δ2 δ') as [H30 | [H30 | H30]]; auto.
       ++ exists (δ2 / (1 + 1)); split; auto with real.
          split. apply OrderPM_Co5; auto.
          assert (δ2 < δ' · (1 + 1) /\ δ2 < δ1 · (1 + 1)) as [].
          { assert (δ2 + 0 < δ' + δ' /\ δ2 + 0 < δ1 + δ1) as [].
            { split. apply OrderPM_Co4; auto with real. destruct H30; auto.
              apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H31, H32; auto. rewrite Hi, Hj; auto. }
          apply (OrderPM_Co7a _ _ (1 + 1)⁻)in H28, H31, H32; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H28, H31, H32; auto.
       ++ exists (δ' / (1 + 1)); split; auto with real.
          split. apply OrderPM_Co5; auto.
          assert (δ' < δ1 · (1 + 1) /\ δ' < δ2 · (1 + 1)) as [].
          { assert (δ' + 0 < δ1 + δ1 /\ δ' + 0 < δ2 + δ2) as [].
            { split. apply OrderPM_Co4; auto with real.
              apply (Order_Co2 _ δ2 _); auto.
              apply OrderPM_Co4; auto with real. destruct H30; auto. }
            rewrite Plus_P1 in H31, H32; auto. rewrite Hj, Hk; auto. }
          apply (OrderPM_Co7a _ _ (1 + 1)⁻)in H26, H31, H32; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H26, H31, H32; auto.
       ++ exists (δ' / (1 + 1)); split; auto with real.
          split. apply OrderPM_Co5; auto. rewrite <-H30.
          assert (δ2 < δ1 · (1 + 1)).
          { assert (δ2 + 0 < δ1 + δ1). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H31; auto. rewrite Hj; auto. }
          apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H28, H31; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H28, H31; auto. }
  destruct H29 as [δ [H29 [H30 [H31 [H32]]]]]. exists δ; split; auto;
  split; auto; split; auto. intros. destruct H35.
  assert (x ∈ Uº(x0 ; δ')).
  { apply AxiomII; split; eauto; split; auto; split; auto.
    apply (RTrans_Lt _ δ _); auto with real. }
  assert ((0 < ｜(x - x0)｜ /\ ｜(x - x0)｜ < δ1)
    /\ (0 < ｜(x - x0)｜ /\ ｜(x - x0)｜ < δ2)) as [].
  { split.
    - split; auto. apply (RTrans_Lt _ δ _); auto with real.
    - split; auto. apply (RTrans_Lt _ δ _); auto with real. }
  assert (f[x] ∈ ℝ /\ g[x] ∈ ℝ /\ h[x] ∈ ℝ) as [H40 []].
  { destruct H as [H [Hl Hm]], H0 as [H0 [Hn Ho]], H1 as [H1 [Hp Hq]].
    repeat split;
    [apply Hm, (@ Property_ran x), Property_Value; auto; rewrite Hl; auto|
     apply Ho, (@ Property_ran x), Property_Value; auto; rewrite Hn; auto|
     apply Hq, (@ Property_ran x), Property_Value; auto; rewrite Hp; auto]. }
  apply H5 in H37; auto. apply H22 in H38; auto. apply H25 in H39; auto.
  destruct H37, H38, H39. apply Abs_P4 in H38 as [], H39 as []; auto with real.
  assert (｜ε｜ = ε) as Hr. { apply me_zero_Abs; auto. }
  assert (A - ε < f[x]).
  { apply (Plus_Leq _ _ A) in H38; auto with real.
    rewrite <-Plus_P3, (Plus_P4 (-A)), Minus_P1, Plus_P1, Plus_P4 in H38;
    auto with real. split; auto. intro; elim H44. rewrite <-H48.
    rewrite (Plus_P4 A), <-Plus_P3, Minus_P1, Plus_P1; auto with real.
    pattern ε at 2; rewrite <-Hr; symmetry; apply Abs_P2; auto. }
  assert (g[x] < A + ε).
  { apply (Plus_Leq _ _ A) in H47; auto with real.
    rewrite <-Plus_P3, (Plus_P4 (-A)), Minus_P1, Plus_P1, Plus_P4 in H47;
    auto with real. split; auto. intro; elim H45. rewrite H49.
    rewrite (Plus_P4 A), <-Plus_P3, Minus_P1, Plus_P1; auto with real. }
  split.
  - apply Abs_P4; auto with real. split.
    + apply (Plus_Leq_Cancel _ _ A); auto with real.
      rewrite <-Plus_P3, (Plus_P4 (-A)), Minus_P1, Plus_P1, Plus_P4;
      auto with real. apply (Order_Co2 _ f[x] _); auto with real.
    + apply (Plus_Leq_Cancel _ _ A); auto with real.
      rewrite <-Plus_P3, (Plus_P4 (-A)), Minus_P1, Plus_P1, Plus_P4;
      auto with real. apply (Order_Co2 _ g[x] _); auto with real.
  - intro. destruct (Leq_P4 (h[x] - A) 0); auto with real.
    + assert (｜(h[x] - A)｜ = - (h[x] - A)).
      { apply le_zero_Abs; auto with real. }
      rewrite H52 in H50. apply (RMult_Eq _ _ (-(1))) in H50; auto with real.
      rewrite Mult_P4, <-PlusMult_Co3, Mult_P4, <-PlusMult_Co3,
      Minus_P3, Minus_P3, Minus_P4, Minus_P4 in H50; auto with real.
      apply (RPlus_Eq _ _ A) in H50; auto with real.
      rewrite <-Plus_P3, (Plus_P4 (-A)), Minus_P1, Plus_P1, Plus_P4 in H50;
      auto with real.
      assert (f[x] = A - ε).
      { rewrite H50 in H37. destruct H48. apply Leq_P2; auto with real. }
      elim H44. rewrite H53, (Plus_P4 A), <-Plus_P3, Minus_P1, Plus_P1;
      auto with real. pattern ε at 2; rewrite <-Hr; symmetry.
      apply Abs_P2; auto.
    + assert (｜(h[x] - A)｜ = h[x] - A).
      { apply me_zero_Abs; auto with real. }
      rewrite H52 in H50. apply (RPlus_Eq _ _ A) in H50; auto with real.
      rewrite <-Plus_P3, (Plus_P4 (-A)), Minus_P1, Plus_P1, Plus_P4 in H50;
      auto with real.
      assert (g[x] = A + ε).
      { rewrite H50 in H43. destruct H49. apply Leq_P2; auto with real. }
      elim H45. rewrite H53, (Plus_P4 A), <-Plus_P3, Minus_P1, Plus_P1;
      auto with real.
Qed.

(* 定义72 x × y={[u,v]:u∈x/\v∈y} *)
(* Definition Cartesian x y := \{\ λ u v, u ∈ x /\ v ∈ y \}\. 
Notation "x × y" := (Cartesian x y) (at level 2, right associativity). *)

(* 定理3.7 四则运算 *)
Theorem Theorem3_7a : ∀ f g x0 A B, Limit_x0 f x0 A -> Limit_x0 g x0 B 
  -> Limit_x0 (f \+ g) x0 (A + B).
Proof.
  intros f g x0 A B [Ha [Hb [Hc [δ1' [Hd [He [Hf Hg]]]]]]]
  [Hh [Hi [Hj [δ2' [Hk [Hl [Hm Hn]]]]]]].
  destruct Ha as [Hz [Hy Hx]], Hh as [Hw [Hv Hu]].
  pose proof OrderPM_Co9 as Ho. pose proof Ho as [Hp Hq].
  assert (1 + 1 ∈ ℝ) as Hr. { auto with real. }
  assert (0 < 1 + 1) as Hs.
  { assert (0 + 0 < 1 + 1).
    { apply OrderPM_Co4; auto with real. }
    rewrite Plus_P1 in H; auto with real. }
  assert (0 < (1 + 1)⁻) as Ht. { apply OrderPM_Co10; auto. }
  assert (1 + 1 ∈ (ℝ ~ [0])) as HA.
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto.
    intro. apply MKT41 in H; eauto with real. destruct Hs; auto. }
  apply Mult_inv1 in HA as HB; apply MKT4' in HB as [HB _].
  set(h := f \+ g).
  assert (Function h).
  { split.
    -- unfold Relation; intros. apply AxiomII in H as [_[x [y]]].
       exists x, y; tauto.
    -- intros. apply AxiomII' in H as [_[_[_]]], H0 as [_[_[_]]].
       rewrite H, H0; auto. }
  assert (FunctionR_R h). 
  { red; split; auto; split.
    -- apply AxiomI; split; intros.
       ++ apply AxiomII in H0 as [H0 [y]]. apply AxiomII' in H1 as [_[H1 []]].
          rewrite <-Hy; auto. 
       ++ assert (f[z] ∈ ℝ /\ g[z] ∈ ℝ) as [].
          { split; [apply Hx, (@Property_ran z), Property_Value; auto; 
            rewrite Hy; auto| apply Hu, (@Property_ran z), Property_Value; auto;
            rewrite Hv; auto]. }
          apply AxiomII; split; eauto. exists (f[z] + g[z]).
          apply AxiomII'; repeat split; auto.
          apply MKT49a; eauto with real. rewrite Hy; auto. rewrite Hv; auto.
    -- unfold Included; intros. apply AxiomII in H0 as [H0 [x]].
       apply AxiomII' in H1 as [H1 [H2 []]].
       assert (f[x] ∈ ℝ /\ g[x] ∈ ℝ) as [].
       { split; [apply Hx, (@ Property_ran x), Property_Value; auto; 
         rewrite Hy; auto| apply Hu, (@ Property_ran x), Property_Value; auto;
         rewrite Hv; auto]. }
       rewrite H4; auto with real. }
  unfold Limit_x0. split; auto; repeat split; auto with real.
  assert (∃ δ', δ' ∈ ℝ /\ 0 < δ' /\ δ' ≤ δ1' /\ δ' ≤ δ2').
  { destruct (Leq_P4 δ1' δ2') as [H1 | H1]; auto.
    -- exists δ1'; do 3 (split; auto). apply Leq_P1; auto.
    -- exists δ2'; do 3 (split; auto). apply Leq_P1; auto. }
  destruct H1 as [δ'[H1 [H2 []]]]. exists δ'; split; auto; split; auto.
  split.
  - unfold Included; intros. apply AxiomII in H5 as [H5 [H6 []]].
    apply AxiomII; split; auto. exists (f[z] + g[z]).
    assert (f[z] ∈ ℝ /\ g[z] ∈ ℝ) as [].
    { split; [apply Hx, (@Property_ran z), Property_Value; auto;
      rewrite Hy; auto| apply Hu, (@Property_ran z), Property_Value; auto;
      rewrite Hv; auto]. }
    apply AxiomII'; repeat split. apply MKT49a; eauto with real.
    + apply Hf. apply AxiomII; do 3 (split; auto).
      apply (Order_Co2 _ δ' _); auto with real.
    + apply Hm. apply AxiomII; do 3 (split; auto).
      apply (Order_Co2 _ δ' _); auto with real.
  - intros. destruct H5.
    assert (ε · (1 + 1)⁻ ∈ ℝ /\ 0 < ε · (1 + 1)⁻).
    { split; auto with real.
      apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H6; auto with real.
      rewrite Mult_P4, PlusMult_Co1 in H6; auto with real. }
    apply Hg in H7 as H8; apply Hn in H7 as H9.
    destruct H8 as [δ1 [H8 [H10 []]]], H9 as [δ2 [H9 [H13 []]]].
    assert (δ' + δ' = δ' · (1 + 1) /\ δ1 + δ1 = δ1 · (1 + 1) 
      /\ δ2 + δ2 = δ2 · (1 + 1)) as [HC [HD HE]].
    { repeat split; do 3 (rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1;
      auto with real). }
    assert (δ' < δ' + δ') as HF.
    { assert (δ' + 0 < δ' + δ').
      { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
      rewrite Plus_P1 in H16; auto. }
    assert (δ1 < δ1 + δ1 /\ δ2 < δ2 + δ2) as [HG HH].
    { assert (δ1 + 0 < δ1 + δ1 /\ δ2 + 0 < δ2 + δ2) as [].
      { split; [apply OrderPM_Co4; auto with real; apply Leq_P1; auto|
        apply OrderPM_Co4; auto with real; apply Leq_P1; auto]. }
      rewrite Plus_P1 in H16, H17; auto. }
    rewrite HC in HF; rewrite HD in HG; rewrite HE in HH.
    apply (OrderPM_Co7a _ _ (1 + 1)⁻) in HF, HG, HH; auto with real.
    rewrite <-Mult_P3, Divide_P1, Mult_P1 in HF, HG, HH; auto.
    assert (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < δ' /\ δ < δ1 /\ δ < δ2).
    { destruct (Leq_P4 δ' δ1) as [H16 | H16]; auto.
      -- destruct (Leq_P4 δ' δ2) as [H17 | H17]; auto.
         ++ exists (δ' · (1 + 1)⁻). split; auto with real. split.
            apply OrderPM_Co5; auto. split; auto.
            assert (δ' < δ1 + δ1 /\ δ' < δ2 + δ2) as [].
            { assert (δ' + 0 < δ1 + δ1 /\ δ' + 0 < δ2 + δ2) as [].
              { split; apply OrderPM_Co4; auto with real. }
              rewrite Plus_P1 in H18, H19; auto. }
            rewrite HD in H18; rewrite HE in H19. 
            apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H18, H19; auto with real.
            rewrite <-Mult_P3, Divide_P1, Mult_P1 in H18, H19; auto with real.
         ++ exists (δ2 · (1 + 1)⁻). split; auto with real. split.
            apply OrderPM_Co5; auto.
            assert (δ2 < δ' + δ' /\ δ2 < δ1 + δ1) as [].
            { assert (δ2 + 0 < δ' + δ' /\ δ2 + 0 < δ1 + δ1) as [].
              { split; [apply OrderPM_Co4; auto with real|apply OrderPM_Co4;
                auto with real; apply (Leq_P3 _ δ' _); auto]. }
              rewrite Plus_P1 in H18, H19; auto. }
            rewrite HC in H18; rewrite HD in H19.
            apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H18, H19; auto with real.
            rewrite <-Mult_P3, Divide_P1, Mult_P1 in H18, H19; auto with real.
      -- destruct (Leq_P4 δ1 δ2) as [H17 | H17]; auto.
         ++ exists (δ1 · (1 + 1)⁻). split; auto with real. split.
            apply OrderPM_Co5; auto.
            assert (δ1 < δ' + δ' /\ δ1 < δ2 + δ2) as [].
            { assert (δ1 + 0 < δ' + δ' /\ δ1 + 0 < δ2 + δ2) as [].
              { split; apply OrderPM_Co4; auto with real. }
              rewrite Plus_P1 in H18, H19; auto. }
            rewrite HC in H18; rewrite HE in H19.
            apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H18, H19; auto with real.
            rewrite <-Mult_P3, Divide_P1, Mult_P1 in H18, H19; auto with real.
         ++ exists (δ2 · (1 + 1)⁻). split; auto with real. split.
            apply OrderPM_Co5; auto.
            assert (δ2 < δ' + δ' /\ δ2 < δ1 + δ1) as [].
            { assert (δ2 + 0 < δ' + δ' /\ δ2 + 0 < δ1 + δ1) as [].
              { split; [apply OrderPM_Co4; auto with real;
                apply (Leq_P3 _ δ1 _); auto|apply OrderPM_Co4; auto with real]. }
              rewrite Plus_P1 in H18, H19; auto. }
            rewrite HC in H18; rewrite HD in H19.
            apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H18, H19; auto with real.
            rewrite <-Mult_P3, Divide_P1, Mult_P1 in H18, H19; auto with real. }
    destruct H16 as [δ [H16 [H17 [H18 []]]]]. exists δ; do 3 (split; auto).
    intros. destruct H22.
    assert (f[x] ∈ ℝ /\ g[x] ∈ ℝ) as [].
    { split; [apply Hx, (@ Property_ran x), Property_Value; auto; 
      rewrite Hy; auto| apply Hu, (@ Property_ran x), Property_Value; auto;
      rewrite Hv; auto]. }
    assert (0 < ｜ (x - x0) ｜ /\ ｜ (x - x0) ｜ < δ1).
    { split; auto. apply (RTrans_Lt _ δ _); auto with real. }
    assert (0 < ｜ (x - x0) ｜ /\ ｜ (x - x0) ｜ < δ2).
    { split; auto. apply (RTrans_Lt _ δ _); auto with real. }
    apply H12 in H26; apply H15 in H27; auto.
    assert (f[x] + g[x] = h[x]).
    { apply Property_Fun; auto. apply AxiomII'. repeat split; auto.
      -- apply MKT49a; eauto with real.
      -- apply Hf. apply AxiomII; split; eauto; do 2 (split; auto).
         apply (RTrans_Lt _ δ _); auto with real; apply (Order_Co2 _ δ' _);
         auto with real.
      -- apply Hm. apply AxiomII; split; eauto; do 2 (split; auto).
         apply (RTrans_Lt _ δ _); auto with real; apply (Order_Co2 _ δ' _);
         auto with real. }
    assert ((f[x] + g[x]) - (A + B) = (f[x] - A) + (g[x] - B)).
    { rewrite Minus_P3, <-Plus_P3, (Plus_P3 g[x]), (Plus_P4 g[x]),
      <-(Plus_P3 (-A)), (Plus_P3 f[x]); auto with real. }
    assert (｜((f[x] - A) + (g[x] - B))｜ ≤ ｜(f[x] - A)｜ + ｜(g[x] - B)｜).
    { apply Abs_P5; auto with real. }
    rewrite <-H28, H29. apply (Order_Co2 _ (｜(f[x] - A)｜ + ｜(g[x] - B)｜) _);
    auto with real. right; split; auto.
    assert (ε + ε = ε · (1 + 1)).
    { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
    assert (ε = ε · (1 + 1)⁻ + ε · (1 + 1)⁻).
    { assert (ε / (1 + 1) + ε / (1 + 1) = (ε + ε) · (1 + 1)⁻).
      { rewrite Mult_P5; auto. }
      rewrite H32, H31, <-Mult_P3, Divide_P1, Mult_P1; auto. }
    rewrite H32. destruct H26; apply OrderPM_Co4; auto with real.
Qed.

Lemma Lemma3_7b : ∀ f x0 A, Limit_x0 f x0 A -> Limit_x0 (f \\· -(1)) x0 (- A).
Proof.
  intros. destruct H as [Ha [Hb [Hc [δ' [Hd [He [Hf]]]]]]], Ha as [Hz [Hy Hx]].
  assert (Function (f \\· -(1))).
  { split; intros.
    -- unfold Relation; intros. apply AxiomII in H0 as [_[x [y []]]].
       exists x, y; auto.
    -- apply AxiomII' in H0 as [_[H0]], H1 as [_[H1]]. rewrite H3; auto. }
  assert (FunctionR_R (f \\· -(1))).
  { split; auto; split.
    -- apply AxiomI; split; intros.
       ++ apply AxiomII in H1 as [_[y]]. apply AxiomII' in H1 as [H1 []].
          rewrite <-Hy; auto.
       ++ assert (f[z] ∈ ℝ).
          { apply Hx, (@ Property_ran z), Property_Value; auto;
            rewrite Hy; auto. }
          apply AxiomII; split; eauto. exists (-f[z]).
          apply AxiomII'; repeat split.
          ** apply MKT49a; eauto with real.
          ** rewrite Hy; auto.
          ** rewrite Mult_P4; auto with real; apply PlusMult_Co3; auto.
    -- unfold Included; intros. apply AxiomII in H1 as [_[x]].
       apply AxiomII' in H1 as [H1 []].
       assert (f[x] ∈ ℝ).
       { apply Hx, (@ Property_ran x), Property_Value; auto. }
       assert (f[x] · -(1) = - f[x]).
       { rewrite Mult_P4; auto with real. symmetry; apply PlusMult_Co3; auto. }
       rewrite H3, H5. apply Plus_neg1a; auto. }
  assert (Uº(x0; δ') ⊂ dom(f \\· -(1))).
  { unfold Included; intros. apply AxiomII in H2 as [H2 [H3 []]].
    apply AxiomII; split; auto. exists (-f[z]); apply AxiomII'.
    assert (f[z] ∈ ℝ).
    { apply Hx, (@ Property_ran z), Property_Value; auto; rewrite Hy; auto. }
    assert (f[z] · -(1) = - f[z]).
    { rewrite Mult_P4; auto with real. symmetry; apply PlusMult_Co3; auto. }
    repeat split; auto; [apply MKT49a; eauto with real|rewrite Hy; auto]. }
  unfold Limit_x0; split; auto; split; auto; split; eauto with real.
  exists δ'; do 3 (split; auto); intros. apply H in H3 as [δ [H3 [H4 []]]].
  exists δ; do 3 (split; auto); intros.
  assert (f[x] ∈ ℝ) as Hg.
  { apply Hx, (@ Property_ran x), Property_Value; auto; rewrite Hy; auto. }
  assert (f[x] · -(1) = - f[x]) as Hh.
  { rewrite Mult_P4; auto with real. symmetry; apply PlusMult_Co3; auto. }
  assert (- f[x] = (f \\· -(1))[x]).
  { apply Property_Fun; auto. apply AxiomII'; repeat split; auto; 
    [apply MKT49a; eauto with real|rewrite Hy; auto]. }
  assert (- f[x] - - A = A - f[x]).
  { rewrite Minus_P4, Plus_P4; eauto with real. }
  assert (A - f[x] = - (f[x] - A)).
  { rewrite Minus_P3, Minus_P4, Plus_P4; auto with real. }
  assert (｜(f[x] - A)｜ = ｜(- (f[x] - A))｜).
  { apply Abs_P2; auto with real. }
  rewrite <-H9, H10, H11, <-H12; auto.
Qed.

Theorem Theorem3_7b : ∀ f g x0 A B, Limit_x0 f x0 A -> Limit_x0 g x0 B
  -> Limit_x0 (f \- g) x0 (A - B).
Proof.
  intros. apply Lemma3_7b in H0 as Ha. pose proof H as HA; pose proof Ha as HB.
  destruct H as [Hb [Hc [Hd [δ1']]]], H0 as [He [Hf [Hg [δ2']]]],
  Ha as [Ha [Hh [Hi [δ3']]]].
  destruct Hb as [Hb [Hz Hy]], He as [He [Hx Hw]], Ha as [Ha [Hv Hu]].
  assert (f \- g = f \+ (g \\· -(1))). (* 写成✖(-1)，而不是直接写-g*)
  { apply AxiomI; split; intros.
    -- apply AxiomII in H2 as [H2 [x [y [H3 [H4 []]]]]].
       assert (g[x] ∈ ℝ).
       { apply Hw, (@ Property_ran x), Property_Value; auto. }
       assert (- g[x] = g[x] · -(1)).
       { rewrite Mult_P4; auto with real; apply PlusMult_Co3; auto.  }
       apply AxiomII; split; auto. exists x, y. repeat split; auto.
       ++ apply AxiomII; split; eauto. exists (- g[x]).
          apply AxiomII'; repeat split; auto. apply MKT49a; eauto with real.
       ++ assert (- g[x] = (g \\· -(1))[x]).
          { apply Property_Fun; auto. apply AxiomII'; split; auto.
            apply MKT49a; eauto with real. }
          rewrite <-H9; auto.
    -- apply AxiomII in H2 as [H2 [x [y [H3 [H4 [H5]]]]]].
       pose proof H5 as H7; rewrite Hv in H7.
       assert (g[x] ∈ ℝ).
       { apply Hw, (@ Property_ran x), Property_Value; auto; rewrite Hx; auto. }
       assert (- g[x] = g[x] · -(1)).
       { rewrite Mult_P4; auto with real; apply PlusMult_Co3; auto.  }
       apply AxiomII; split; auto. exists x, y; repeat split; auto.
       ++ rewrite Hx; auto.
       ++ assert (- g[x] = (g \\· -(1))[x]).
          { apply Property_Fun; auto. apply AxiomII'; repeat split; auto.
            apply MKT49a; eauto with real. rewrite Hx; auto. }
          rewrite H10; auto. }
  rewrite H2. apply Theorem3_7a; auto.
Qed.

Theorem Theorem3_7c : ∀ f g x0 A B, Limit_x0 f x0 A -> Limit_x0 g x0 B
  -> Limit_x0 (f \· g) x0 (A · B).
Proof.
  intros. pose proof H0 as Hz.
  destruct H as [Ha [Hb [Hc [δ1' [Hd [He [Hf]]]]]]],
  H0 as [Hg [Hh [Hi [δ2' [Hj [Hk [Hl]]]]]]].
  pose proof Ha as Hy; pose proof Hg as Hx.
  destruct Hy as [Hy [Hw Hv]], Hx as [Hx [Hu Ht]].
  pose proof OrderPM_Co9 as HA; pose proof HA as [HB HC].
  assert (1 + 1 ∈ ℝ) as HD. { auto with real. }
  assert (0 < 1 + 1) as HE.
  { assert (0 + 0 < 1 + 1).
    { apply OrderPM_Co4; auto with real. }
    rewrite Plus_P1 in H1; auto with real. }
  assert (0 < (1 + 1)⁻) as HF. { apply OrderPM_Co10; auto. }
  assert (1 + 1 ∈ (ℝ ~ [0])) as HG.
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto.
    intro. apply MKT41 in H1; eauto with real. destruct HE; auto. }
  apply Mult_inv1 in HG as HH; apply MKT4' in HH as [HH _].
  assert ((∃ B, B ∈ ℝ /\ Limit_x0 g x0 B)). { exists B; split; auto. }
  apply Theorem3_3b in H1 as [δ3' [H1 [H2 [M]]]].
  assert (δ1' < δ1' + δ1') as HI.
  { assert (δ1' + 0 < δ1' + δ1').
    { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
    rewrite Plus_P1 in H4; auto. }
  assert (δ2' < δ2' + δ2') as HJ.
  { assert (δ2' + 0 < δ2' + δ2').
    { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
    rewrite Plus_P1 in H4; auto. }
  assert (δ3' < δ3' + δ3') as HK.
  { assert (δ3' + 0 < δ3' + δ3').
    { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
    rewrite Plus_P1 in H4; auto. }
  assert (δ1' + δ1' = δ1' · (1 + 1)) as HL.
  { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
  assert (δ2' + δ2' = δ2' · (1 + 1)) as HM.
  { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
  assert (δ3' + δ3' = δ3' · (1 + 1)) as HN.
  { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
  rewrite HL in HI; rewrite HM in HJ; rewrite HN in HK; auto.
  apply (OrderPM_Co7a _ _ (1 + 1)⁻) in HI, HJ, HK; auto with real.
  rewrite <-Mult_P3, Divide_P1, Mult_P1 in HI, HJ, HK; auto.
  pose proof HF. destruct H4 as [HO HP].
  assert (∃ δ', δ' ∈ ℝ /\ 0 < δ' /\ δ' ≤ δ1' /\ δ' ≤ δ2' /\ δ' ≤ δ3').
  { destruct (Leq_P4 δ1' δ2') as [H4 | H4]; auto.
    -- destruct (Leq_P4 δ1' δ3') as [H5 | H5]; auto.
       ++ exists (δ1' · (1 + 1)⁻). split; auto with real.
          split. apply OrderPM_Co5; auto.
          assert (δ1' ≤ δ2' + δ2').
          { assert (δ1' + 0 ≤ δ2' + δ2'). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H6; auto. }
          assert (δ1' ≤ δ3' + δ3').
          { assert (δ1' + 0 ≤ δ3' + δ3'). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H7; auto. }
          rewrite HM in H6; rewrite HN in H7.
          apply (OrderPM_Co7b _ _ (1 + 1)⁻) in H6, H7; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H6, H7; auto.
          destruct HI; repeat split; auto.
       ++ exists (δ3' · (1 + 1)⁻). split; auto with real.
          split. apply OrderPM_Co5; auto.
          assert (δ3' ≤ δ1' + δ1').
          { assert (δ3' + 0 ≤ δ1' + δ1'). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H6; auto. }
          assert (δ3' ≤ δ2' + δ2').
          { assert (δ3' + 0 ≤ δ2' + δ2').
            { apply OrderPM_Co4; auto with real. apply (Leq_P3 _ δ1' _); auto. }
            rewrite Plus_P1 in H7; auto. }
          rewrite HL in H6; rewrite HM in H7.
          apply (OrderPM_Co7b _ _ (1 + 1)⁻) in H6, H7; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H6, H7; auto.
          destruct HK; repeat split; auto.
    -- destruct (Leq_P4 δ2' δ3') as [H5 | H5]; auto.
       ++ exists (δ2' · (1 + 1)⁻). split; auto with real.
          split. apply OrderPM_Co5; auto.
          assert (δ2' ≤ δ1' + δ1').
          { assert (δ2' + 0 ≤ δ1' + δ1'). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H6; auto. }
          assert (δ2' ≤ δ3' + δ3').
          { assert (δ2' + 0 ≤ δ3' + δ3'). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H7; auto. }
          rewrite HL in H6; rewrite HN in H7.
          apply (OrderPM_Co7b _ _ (1 + 1)⁻) in H6, H7; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H6, H7; auto.
          destruct HJ; repeat split; auto.
       ++ exists (δ3' · (1 + 1)⁻). split; auto with real.
          split. apply OrderPM_Co5; auto.
          assert (δ3' ≤ δ1' + δ1').
          { assert (δ3' + 0 ≤ δ1' + δ1').
            { apply OrderPM_Co4; auto with real; apply (Leq_P3 _ δ2' _); auto. }
            rewrite Plus_P1 in H6; auto. }
          assert (δ3' ≤ δ2' + δ2').
          { assert (δ3' + 0 ≤ δ2' + δ2'). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H7; auto. }
          rewrite HL in H6; rewrite HM in H7.
          apply (OrderPM_Co7b _ _ (1 + 1)⁻) in H6, H7; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H6, H7; auto.
          destruct HK; repeat split; auto. }
  destruct H4 as [δ' [H4 [H5 [H6 [H7]]]]].
  assert (Function (f \· g)).
  { split.
    -- unfold Relation; intros. apply AxiomII in H9 as [H9 [x [y]]].
       exists x, y; tauto.
    -- intros. apply AxiomII' in H9 as [H9 [H11 [H12 H13]]],
       H10 as [H10 [H14 [H15 H16]]]. rewrite H16; auto. }
  assert (FunctionR_R (f \· g)).
  { split; auto; split.
    -- apply AxiomI; split; intros.
       ++ apply AxiomII in H10 as [H10 []]. apply AxiomII' in H11 as [H11].
          rewrite <-Hw; tauto.
       ++ assert (f[z] ∈ ℝ /\ g[z] ∈ ℝ) as [].
          { split; [apply Hv, (@ Property_ran z), Property_Value; auto;
            rewrite Hw; auto|apply Ht, (@ Property_ran z), Property_Value;
            auto; rewrite Hu; auto]. }
          apply AxiomII; split; eauto. exists (f[z] · g[z]).
          apply AxiomII'; repeat split; auto.
          apply MKT49a; eauto with real. rewrite Hw; auto. rewrite Hu; auto.
    -- unfold Included; intros. apply AxiomII in H10 as [H10 [x]].
       apply AxiomII' in H11 as [H11 [H12 [H13]]]. rewrite Hw in H12.
       assert (f[x] ∈ ℝ /\ g[x] ∈ ℝ) as [].
       { split; [apply Hv, (@ Property_ran x), Property_Value; auto;
         rewrite Hw; auto|apply Ht, (@ Property_ran x), Property_Value;
         auto; rewrite Hu; auto]. }
       rewrite H14; apply Mult_close; auto. }
  assert (Uº(x0; δ') ⊂ dom(f \· g)).
  { unfold Included; intros. apply AxiomII in H11 as [H11 [H12 [H13]]].
    apply AxiomII; split; auto. exists (f[z] · g[z]).
    assert (f[z] ∈ ℝ /\ g[z] ∈ ℝ) as [].
    { split; [apply Hv, (@ Property_ran z), Property_Value; auto;
      rewrite Hw; auto|apply Ht, (@ Property_ran z), Property_Value; auto;
      rewrite Hu; auto]. }
    apply AxiomII'; repeat split; auto.
    -- apply MKT49a; eauto with real.
    -- apply Hf. apply AxiomII; do 3 (split; auto). apply (Order_Co2 _ δ' _);
       auto with real.
    -- apply Hl. apply AxiomII; do 3 (split; auto). apply (Order_Co2 _ δ' _);
       auto with real. }
  split; auto; split; auto; split; auto with real.
  exists δ'; do 3 (split; auto). intros ε []. destruct H3 as [HQ [HR HS]].
  assert (0 < M +｜A｜) as HT.
  { assert (0 + 0 < ｜A｜+ M).
    { apply OrderPM_Co4; auto with real; apply Abs_P1; auto. }
    rewrite Plus_P1, Plus_P4 in H3; auto with real. }
  assert (0 < (M +｜A｜)⁻) as HU. { apply OrderPM_Co10; auto with real. }
  assert ((M +｜A｜) ∈ (ℝ ~ [0])) as HV.
  { apply MKT4'; split; eauto with real.
    apply AxiomII; split; eauto with real. intro.
    apply MKT41 in H3; eauto with real; destruct HT; auto. }
  pose proof HV as HZZ. apply Mult_inv1 in HV; apply MKT4' in HV as [HV _]. 
  assert (ε / (M +｜A｜) ∈ ℝ /\ 0 < ε / (M +｜A｜)).
  { split; [auto with real|apply OrderPM_Co5; auto]. }
  apply H in H3 as H14; apply H0 in H3 as H15.
  destruct H14 as [δ1 [H14 [H16 [H17]]]], H15 as [δ2 [H15 [H19 [H20]]]].
  assert (δ' < δ' + δ') as HW.
  { assert (δ' + 0 < δ' + δ').
    { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
    rewrite Plus_P1 in H22; auto. }
  assert (δ1 < δ1 + δ1) as HX.
  { assert (δ1 + 0 < δ1 + δ1).
    { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
    rewrite Plus_P1 in H22; auto. }
  assert (δ2 < δ2 + δ2) as HY.
  { assert (δ2 + 0 < δ2 + δ2).
    { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
    rewrite Plus_P1 in H22; auto. }
  assert (δ' + δ' = δ' · (1 + 1)) as HZ.
  { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
  assert (δ1 + δ1 = δ1 · (1 + 1)) as HAA.
  { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
  assert (δ2 + δ2 = δ2 · (1 + 1)) as HBB.
  { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
  rewrite HZ in HW; rewrite HAA in HX; rewrite HBB in HY.
  apply (OrderPM_Co7a _ _ (1 + 1)⁻) in HW, HX, HY; auto with real.
  rewrite <-Mult_P3, Divide_P1, Mult_P1 in HW, HX, HY; auto.
  assert (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < δ' /\ δ ≤ δ1 /\ δ ≤ δ2).
  { destruct (Leq_P4 δ1 δ2) as [H22 | H22]; auto.
    -- destruct (Leq_P4 δ' δ1) as [H23 | H23]; auto.
       ++ exists (δ' · (1 + 1)⁻); split; auto with real.
          assert (δ' < δ1 + δ1).
          { assert (δ' + 0 < δ1 + δ1). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H24; auto. }
          assert (δ' < δ2 + δ2).
          { assert (δ' + 0 < δ2 + δ2).
            { apply OrderPM_Co4; auto with real; apply (Leq_P3 _ δ1 _); auto. }
            rewrite Plus_P1 in H25; auto. }
          rewrite HAA in H24; rewrite HBB in H25.
          apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H24, H25; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H24, H25; auto.
          split. apply OrderPM_Co5; auto. destruct H24, H25; auto.
       ++ exists (δ1 · (1 + 1)⁻); split; auto with real.
          assert (δ1 < δ' + δ').
          { assert (δ1 + 0 < δ' + δ'). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H24; auto. }
          assert (δ1 < δ2 + δ2).
          { assert (δ1 + 0 < δ2 + δ2). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H25; auto. }
          rewrite HZ in H24; rewrite HBB in H25.
          apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H24, H25; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H24, H25; auto.
          split. apply OrderPM_Co5; auto. destruct HX, H25; auto.
    -- destruct (Leq_P4 δ' δ2) as [H23 | H23]; auto.
       ++ exists (δ' · (1 + 1)⁻); split; auto with real.
          assert (δ' < δ1 + δ1).
          { assert (δ' + 0 < δ1 + δ1). 
            { apply OrderPM_Co4; auto with real; apply (Leq_P3 _ δ2 _); auto. }
            rewrite Plus_P1 in H24; auto. }
          assert (δ' < δ2 + δ2).
          { assert (δ' + 0 < δ2 + δ2). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H25; auto. }
          rewrite HAA in H24; rewrite HBB in H25.
          apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H24, H25; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H24, H25; auto.
          split. apply OrderPM_Co5; auto. destruct H24, H25; auto.
       ++ exists (δ2 · (1 + 1)⁻); split; auto with real.
          assert (δ2 < δ' + δ').
          { assert (δ2 + 0 < δ' + δ'). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H24; auto. }
          assert (δ2 < δ1 + δ1).
          { assert (δ2 + 0 < δ1 + δ1). { apply OrderPM_Co4; auto with real. }
            rewrite Plus_P1 in H25; auto. }
          rewrite HZ in H24; rewrite HAA in H25.
          apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H24, H25; auto with real.
          rewrite <-Mult_P3, Divide_P1, Mult_P1 in H24, H25; auto.
          split. apply OrderPM_Co5; auto. destruct HY, H25; auto. }
  destruct H22 as [δ [H22 [H23 [H24 [H25]]]]]. exists δ; do 3 (split; auto).
  intros. destruct H28.
  assert (f[x] ∈ ℝ /\ g[x] ∈ ℝ) as [].
  { split; [apply Hv, (@ Property_ran x), Property_Value; auto;
    rewrite Hw; auto|apply Ht, (@ Property_ran x), Property_Value;
    auto; rewrite Hu; auto]. }
  assert (f[x] · g[x] ∈ ℝ). { apply Mult_close; auto. }
  assert (0 < ｜(x - x0)｜ /\ ｜(x - x0)｜ < δ1).
  { split; auto; apply (Order_Co2 _ δ _); auto with real. }
  assert (0 < ｜(x - x0)｜ /\ ｜(x - x0)｜ < δ2).
  { split; auto; apply (Order_Co2 _ δ _); auto with real. }
  apply H18 in H33; apply H21 in H34; auto.
  assert (f[x] · g[x] = (f \· g) [x]).
  { apply Property_Fun; auto. apply AxiomII'; repeat split; auto.
    -- apply MKT49a; eauto.
    -- apply Hf. apply AxiomII; split; eauto; split; auto; split; auto. 
       apply (RTrans_Lt _ δ _); auto with real.
       apply (Order_Co2 _ δ' _); auto with real.
    -- apply Hl. apply AxiomII; split; eauto; split; auto; split; auto.
       apply (RTrans_Lt _ δ _); auto with real.
       apply (Order_Co2 _ δ' _); auto. }
  assert (f[x] · g[x] - A · B = (f[x] - A) · g[x] + A · (g[x] - B)).
  { assert ((f[x] - A) · g[x] = f[x] · g[x] -  A · g[x]).
    { rewrite Mult_P5,PlusMult_Co3,<-Mult_P3,<-PlusMult_Co3; auto with real. }
    assert (A · (g[x] - B) = A · g[x] - A · B).
    { rewrite Mult_P4, Mult_P5, PlusMult_Co3, <-Mult_P3, <-PlusMult_Co3,
      Mult_P4, (Mult_P4 B); auto with real. }
    rewrite H36, H37. rewrite <-Plus_P3, (Plus_P3 (- (A · g[x]))),
    (Plus_P4 (- (A · g[x]))), Minus_P1, (Plus_P4 0), Plus_P1; auto with real. }
  assert (｜((f[x] - A) · g[x] + A · (g[x] - B))｜ ≤ 
    ｜((f[x] - A) · g[x])｜ + ｜(A · (g[x] - B))｜).
  { apply Abs_P5; auto with real. }
  assert (｜((f[x] - A) · g[x])｜ = ｜(f[x] - A)｜ · ｜(g[x])｜).
  { apply Abs_P3; auto with real. }
  assert (｜(A · (g[x] - B))｜ = ｜A｜ · ｜(g[x] - B)｜).
  { apply Abs_P3; auto with real. }
  assert (｜((f[x] - A) · g[x])｜ ∈ ℝ /\ ｜(A · (g[x] - B))｜ ∈ ℝ) as [].
  { split; [apply Abs_in_R; auto with real|apply Abs_in_R; auto with real]. }
  assert (｜((f[x] - A) · g[x] + A · (g[x] - B))｜ ∈ ℝ).
  { apply Abs_in_R; auto with real. }
  rewrite <-H35, H36.
  apply (Order_Co2 _ (｜((f[x] - A) · g[x])｜ + ｜(A · (g[x] - B)) ｜) _); 
  auto with real. right; split; auto.
  assert (ε = (ε / (M +｜A｜)) · M + ｜A｜· (ε / (M +｜A｜))).
  { rewrite Mult_P4, <-Mult_P5, Mult_P3, (Mult_P4 (M +｜A｜)),
    <-Mult_P3, Divide_P1, Mult_P1; auto with real. }
  assert (｜(f[x] - A)｜ · ｜(g [x])｜ < (ε / (M + ｜A｜)) · M).
  { destruct (classic (｜(g[x])｜ = M)).
    -- rewrite H44. apply (OrderPM_Co7a _ _ M); auto with real.
    -- assert (｜(g[x])｜ < M).
       { split; auto. apply HS. apply AxiomII; split; eauto;
         split; auto; split; auto. apply (RTrans_Lt _ δ _); auto with real.
         apply (Order_Co2 _ δ' _); auto with real. }
       apply OrderPM_Co12; auto with real.
       apply Abs_P1; auto with real. apply Abs_P1; auto. }
  assert (｜A｜ · ｜(g[x] - B)｜ ≤ ｜A｜ · (ε / (M + ｜A｜))).
  { rewrite Mult_P4, (Mult_P4 ｜A｜); auto with real. destruct H34.
    apply OrderPM_Co7b; auto with real; apply Abs_P1; auto. }
  rewrite H38, H39, H43, Plus_P4, (Plus_P4 ((ε/(M +｜A｜)) · M));
  auto with real. apply OrderPM_Co4; auto with real.
Qed.

(* Corollary OrderPM_Co12 : ∀ r1 r2 r3 r4, r1 ∈ ℝ -> r2 ∈ ℝ 
  -> r3 ∈ ℝ -> r4 ∈ ℝ -> 0 ≤ r1 -> 0 ≤ r3 -> r1 < r2 -> r3 < r4 
  -> r1 · r3 < r2 · r4.
 *)

(* Definition div'_fun (f : sR2) a := (\{\ λ x y, x ∈ dom[f] /\ f[x] <> 0
  /\ y = a / f[x] \}\). *)

Lemma Lemma3_7d : ∀ f x0 A, Limit_x0 f x0 A -> A ≠ 0 
  -> Limit_x0 (1 /// f) x0 (1 / A).
Proof.
Admitted.

(* Theorem Theorem3_7d : ∀ f g x0 A B, Limit_x0 f x0 A -> Limit_x0 g x0 B
  -> B ≠ 0 -> Limit_x0 (f // g) x0 (A / B). *)


(* 3.3 函数极限存在的条件 *)

(* 定理3.8 归结原则 *)
Theorem Theorem3_8 : ∀ f x0 δ' A, FunctionR_R f -> x0 ∈ ℝ 
  -> δ' ∈ ℝ -> 0 < δ' -> Uº(x0; δ') ⊂ dom(f) -> Limit_x0 f x0 A
  <-> ∀ x, Limit_Seq x x0 -> ran(x) ⊂ Uº(x0; δ')
    -> Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\ A.
Proof.
  split; intros.
  destruct H4 as [[Ha[Hb Hc]] [_[Hd[δ1'[He[Hf[Hg]]]]]]], H5 as [[Hh[Hi Hj]]].
  - assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\).
    { repeat split; intros.
      - unfold Relation; intros. apply AxiomII in H7 as [_[x1[y1[]]]].
        exists x1, y1; auto.
      - apply AxiomII' in H7 as [H7[H9[H10]]], H8 as [H8[H12[H13]]].
        rewrite H14; auto.
      - apply AxiomI; split; intros.
         + apply AxiomII in H7 as [_[y]]. apply AxiomII' in H7; tauto.
         + assert (f[x[z]] ∈ ℝ).
           { apply Hc,(@ Property_ran x[z]),Property_Value; auto;
             rewrite Hb. apply Hj,(@ Property_ran z),Property_Value; auto;
             rewrite Hi; auto. }
           apply AxiomII; split; eauto. exists f[x[z]].
           apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
      - unfold Included; intros. apply AxiomII in H7 as [_[x1]].
        apply AxiomII' in H7; tauto. }
    split; auto; intros. apply H4 in H8 as H9. destruct H9 as [δ[H9[H10[H11]]]].
    assert (δ ∈ ℝ /\ 0 < δ); auto. apply H5 in H13 as [N[]].
    exists N; split; auto. intros.
    assert (x[n] ∈ Uº(x0; δ')).
    { apply H6,(@ Property_ran n),Property_Value; auto; rewrite Hi; auto. }
    apply AxiomII in H17 as [_[H17[H18 _]]]. apply H14 in H16; auto.
    assert (f[x[n]] ∈ ℝ).
    { apply Hc,(@ Property_ran x[n]),Property_Value; auto. rewrite Hb; auto. }
    assert (f[x[n]] = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\[n]).
    { destruct H7. apply Property_Fun; auto.
      apply AxiomII'; repeat split; auto. apply MKT49a; eauto. }
    rewrite <-H20; auto.
  -
Admitted.

(* 条件冗余，为了统一 *)
Corollary Corollary3_8a : ∀ f x0 δ' A, x0 ∈ ℝ -> δ' ∈ ℝ -> 0 < δ'
  -> U+º(x0; δ') ⊂ dom(f) -> Limit_Right f x0 A
  -> ∀ x, Limit_Seq x x0 -> ran(x) ⊂ U+º(x0; δ')
  -> Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\ A.
Proof.
  intros. destruct H3 as [[Ha[Hb Hc]] [_[Hd[δ1'[He[Hf[Hg]]]]]]],
  H4 as [[Hh[Hi Hj]]].
  assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\).
  { repeat split; intros.
    - unfold Relation; intros. apply AxiomII in H6 as [_[x1[y1[]]]].
      exists x1, y1; auto.
    - apply AxiomII' in H6 as [H6[H8[H9]]], H7 as [H11[H12[H13]]].
      rewrite H7; auto.
    - apply AxiomI; split; intros.
       + apply AxiomII in H6 as [_[y]]. apply AxiomII' in H6; tauto.
       + assert (f[x[z]] ∈ ℝ).
         { apply Hc,(@ Property_ran x[z]),Property_Value; auto;
           rewrite Hb. apply Hj,(@ Property_ran z),Property_Value; auto;
           rewrite Hi; auto. }
         apply AxiomII; split; eauto. exists f[x[z]].
         apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
    - unfold Included; intros. apply AxiomII in H6 as [_[x1]].
      apply AxiomII' in H6; tauto. }
  split; auto. intros. apply H3 in H7 as H8. destruct H8 as [δ[H8[H9[]]]].
  assert (δ ∈ ℝ /\ 0 < δ); auto.
  apply H4 in H12 as [N[]]. exists N; split; auto. intros.
  assert (x[n] ∈ U+º(x0; δ')).
  { apply H5,(@ Property_ran n),Property_Value; auto; rewrite Hi; auto. }
  apply AxiomII in H16 as [_[H16[H17 _]]]. apply H13 in H15; auto.
  assert (x[n] < x0 + δ).
  { destruct H15,H9. apply Abs_P4 in H15 as []; auto with real.
    apply (Plus_Leq _ _ x0) in H20; auto with real.
    rewrite <-Plus_P3,(Plus_P4 (-x0)),Minus_P1,Plus_P1,Plus_P4 in H20;
    auto with real. split; auto. intro. elim H18. rewrite H21.
    rewrite (Plus_P4 x0),<-Plus_P3,Minus_P1,Plus_P1; auto with real.
    apply me_zero_Abs; auto. }
  assert (x0 < x[n] /\ x[n] < x0 + δ); auto.
  assert (f[x[n]] ∈ ℝ).
  { apply Hc,(@ Property_ran x[n]),Property_Value; auto; rewrite Hb.
    apply Hj,(@ Property_ran n),Property_Value; auto; rewrite Hi; auto. }
  assert (f[x[n]] = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\[n]).
  { destruct H6. apply Property_Fun; auto. apply AxiomII'; repeat split; auto.
    apply MKT49a; eauto. }
  apply H11 in H19; auto. rewrite <-H21; auto.
Qed.

Corollary Corollary3_8b : ∀ f x0 δ' A, x0 ∈ ℝ -> δ' ∈ ℝ -> 0 < δ'
  -> U-º(x0; δ') ⊂ dom(f) -> Limit_Left f x0 A
  -> ∀ x, Limit_Seq x x0 -> ran(x) ⊂ U-º(x0; δ')
  -> Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\ A.
Proof.
  intros. destruct H3 as [[Ha[Hb Hc]] [_[Hd[δ1'[He[Hf[Hg]]]]]]],
  H4 as [[Hh[Hi Hj]]].
  assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\).
  { repeat split; intros.
    - unfold Relation; intros. apply AxiomII in H6 as [_[x1[y1[]]]].
      exists x1, y1; auto.
    - apply AxiomII' in H6 as [H6[H8[H9]]], H7 as [H11[H12[H13]]].
      rewrite H7; auto.
    - apply AxiomI; split; intros.
       + apply AxiomII in H6 as [_[y]]. apply AxiomII' in H6; tauto.
       + assert (f[x[z]] ∈ ℝ).
         { apply Hc,(@ Property_ran x[z]),Property_Value; auto;
           rewrite Hb. apply Hj,(@ Property_ran z),Property_Value; auto;
           rewrite Hi; auto. }
         apply AxiomII; split; eauto. exists f[x[z]].
         apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
    - unfold Included; intros. apply AxiomII in H6 as [_[x1]].
      apply AxiomII' in H6; tauto. }
  split; auto. intros. apply H3 in H7 as H8. destruct H8 as [δ[H8[H9[]]]].
  assert (δ ∈ ℝ /\ 0 < δ); auto.
  apply H4 in H12 as [N[]]. exists N; split; auto. intros.
  assert (x[n] ∈ U-º(x0; δ')).
  { apply H5,(@ Property_ran n),Property_Value; auto; rewrite Hi; auto. }
  apply AxiomII in H16 as [_[H16[_ H17]]]. apply H13 in H15; auto.
  assert (x0 - δ < x[n]).
  { destruct H15,H9. apply Abs_P4 in H15 as []; auto with real.
    apply (Plus_Leq _ _ x0) in H15; auto with real. rewrite <-Plus_P3,
    (Plus_P4 (-x0)),Minus_P1,Plus_P1,Plus_P4 in H15; auto with real.
    split; auto. intro. elim H18. rewrite <-H21. rewrite (Plus_P4 x0),
    <-Plus_P3,Minus_P1,Plus_P1; auto with real.
    assert (｜δ｜ = ｜(-δ)｜). { apply Abs_P2; auto. }
    rewrite <-H22. apply me_zero_Abs; auto. }
  assert (x0 - δ < x[n] /\ x[n] < x0); auto.
  assert (f[x[n]] ∈ ℝ).
  { apply Hc,(@ Property_ran x[n]),Property_Value; auto; rewrite Hb.
    apply Hj,(@ Property_ran n),Property_Value; auto; rewrite Hi; auto. }
  assert (f[x[n]] = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\[n]).
  { destruct H6. apply Property_Fun; auto. apply AxiomII'; split; auto.
    apply MKT49a; eauto. }
  apply H11 in H19; auto. rewrite <-H21; auto.
Qed.

(* f在x0邻域内连续的归结原则 *)
Theorem Theorem3_8' : ∀ f x0 A, x0 ∈ dom(f) -> f[x0] = A
  -> Limit_x0 f x0 A -> ∀ x, Limit_Seq x x0 -> ran(x) ⊂ dom(f)
  -> Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\ A.
Proof.
  intros. destruct H1 as [[Ha[Hb Hc]] [Hd[He[δ'[Hf[Hg[Hi]]]]]]],
  H2 as [[Hj[Hk Hl]]].
  assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\).
  { repeat split; intros.
    - unfold Relation; intros. apply AxiomII in H4 as [_[x1[y[]]]].
      exists x1, y; auto.
    - apply AxiomII' in H4 as [H4[H6[H7]]], H5 as [H5[H9[H10]]].
      rewrite H11; auto.
    - apply AxiomI; split; intros.
      + apply AxiomII in H4 as [_[]]. apply AxiomII' in H4 as [H4[]]; auto.
      + assert (f[x[z]] ∈ ℝ).
        { apply Hc,(@ Property_ran x[z]),Property_Value; auto; rewrite Hb.
          apply Hl,(@ Property_ran z),Property_Value; auto; rewrite Hk; auto. }
        apply AxiomII; split; eauto. exists f[x[z]].
        apply AxiomII'; split; auto. apply MKT49a; eauto.
    - unfold Included; intros. apply AxiomII in H4 as [_[x1]].
      apply AxiomII' in H4; tauto. }
  split; auto. intros. apply H1 in H5 as H6. destruct H6 as [δ[H6[H7[H8]]]].
  assert (δ ∈ ℝ /\ 0 < δ); auto.
  apply H2 in H10 as [N[]]. exists N; split; auto. intros.
  assert (x[n] ∈ ℝ).
  { apply Hl,(@ Property_ran n),Property_Value; auto; rewrite Hk; auto. }
  assert ( 0 ≤ ｜(x[n] - x0)｜). { apply Abs_P1; auto with real. }
  assert (｜(x[n] - x0)｜ < δ). { apply H11 in H13; auto. }
  assert (｜(f[x[n]] - A)｜ < ε).
  { assert (0 < ｜(x[n] - x0)｜ \/ ｜(x[n] - x0)｜ = 0).
    { destruct (classic (｜(x[n] - x0)｜ = 0)); auto. left; split; auto. }
    destruct H17 as [H17|H17].
    - apply H9; auto.
    - assert (x[n] = x0). { apply Abs_P6; auto. }
      assert (｜0｜ = 0). { apply Abs_P1; auto with real. }
      destruct H5 as []. rewrite <-H19 in H20. rewrite H18,H0,Minus_P1; auto. }
  assert (f[x[n]] ∈ ℝ).
  { apply Hc,(@ Property_ran x[n]),Property_Value; auto.
    apply H3, (@ Property_ran n),Property_Value; auto; rewrite Hk; auto. }
  assert (f[x[n]] = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\[n]).
  { destruct H4. apply Property_Fun; auto. apply AxiomII'; split; auto.
    apply MKT49a; eauto. }
  rewrite <-H19; auto.
Qed.

Corollary Corollary3_8a' :  ∀ f x0 A, x0 ∈ dom(f) -> f[x0] = A
  -> Limit_Right f x0 A -> ∀ x, Limit_Seq x x0 -> ran(x) ⊂ dom(f)
  -> (∀ n, n ∈ ℕ -> x0 ≤ x[n])
  -> Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\ A.
Proof.
  intros. destruct H1 as [[Ha[Hb Hc]] [Hd[He[δ'[Hf[Hg[Hi]]]]]]],
  H2 as [[Hj[Hk Hl]]].
  assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\).
  { repeat split; intros.
    - unfold Relation; intros. apply AxiomII in H5 as [_[x1[y[]]]].
      exists x1, y; auto.
    - apply AxiomII' in H5 as [H5[H7[H8]]], H6 as [H6[H10[H11]]].
      rewrite H12; auto.
    - apply AxiomI; split; intros.
      + apply AxiomII in H5 as [_[y]]. apply AxiomII' in H5 as [H5[]]; auto.
      + assert (f[x[z]] ∈ ℝ).
        { apply Hc,(@ Property_ran x[z]),Property_Value; auto; rewrite Hb.
          apply Hl,(@ Property_ran z),Property_Value; auto; rewrite Hk; auto. }
        apply AxiomII; split; eauto. exists f[x[z]].
        apply AxiomII'; split; auto. apply MKT49a; eauto.
    - unfold Included; intros. apply AxiomII in H5 as [_[x1]].
      apply AxiomII' in H5; tauto. }
  split; auto. intros. apply H1 in H6 as H7. destruct H7 as [δ[H7[H8[H9]]]].
  assert (δ ∈ ℝ /\ 0 < δ); auto.
  apply H2 in H11 as [N[]]. exists N; split; auto. intros.
  assert (x[n] ∈ ℝ).
  { apply Hl,(@ Property_ran n),Property_Value; auto; rewrite Hk; auto. }
  assert (x[n] < x0 + δ).
  { destruct H8. apply H12 in H14 as []; auto. apply Abs_P4 in H14 as [];
    auto with real. apply (Plus_Leq _ _ x0) in H18; auto with real.
    rewrite <-Plus_P3,(Plus_P4 (-x0)),Minus_P1,Plus_P1,Plus_P4 in H18;
    auto with real. split; auto. intro. elim H17. rewrite H19.
    rewrite (Plus_P4 x0),<-Plus_P3,Minus_P1,Plus_P1; auto with real.
    apply me_zero_Abs; auto. }
  assert (x0 ≤ x[n]). { apply H4 in H13; auto. }
  assert (｜(f[x[n]] - A)｜ < ε).
  { assert (x0 < x[n] \/ x0 = x[n]).
    { destruct (classic (x0 = x[n])); auto. left; split; auto. }
    destruct H18 as [H18|H18].
    - apply H10; auto.
    - assert (｜0｜ = 0). { apply Abs_P1; auto with real. }
      destruct H6 as []. rewrite <-H19 in H20. rewrite <-H18,H0,Minus_P1; auto. }
  assert (f[x[n]] ∈ ℝ).
  { apply Hc,(@ Property_ran x[n]),Property_Value; auto.
    apply H3, (@ Property_ran n),Property_Value; auto; rewrite Hk; auto. }
  assert (f[x[n]] = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\[n]).
  { destruct H5. apply Property_Fun; auto. apply AxiomII'; split; auto.
    apply MKT49a; eauto. }
  rewrite <-H20; auto.
Qed.

Corollary Corollary3_8b' :  ∀ f x0 A, x0 ∈ dom(f) -> f[x0] = A
  -> Limit_Left f x0 A -> ∀ x, Limit_Seq x x0 -> ran(x) ⊂ dom(f)
  -> (∀ n, n ∈ ℕ -> x[n] ≤ x0)
  -> Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\ A.
Proof.
  intros. destruct H1 as [[Ha[Hb Hc]] [Hd[He[δ'[Hf[Hg[Hi]]]]]]],
  H2 as [[Hj[Hk Hl]]].
  assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\).
  { repeat split; intros.
    - unfold Relation; intros. apply AxiomII in H5 as [_[x1[y[]]]].
      exists x1, y; auto.
    - apply AxiomII' in H5 as [H5[H7[H8]]], H6 as [H6[H10[H11]]].
      rewrite H12; auto.
    - apply AxiomI; split; intros.
      + apply AxiomII in H5 as [_[y]]. apply AxiomII' in H5 as [H5[]]; auto.
      + assert (f[x[z]] ∈ ℝ).
        { apply Hc,(@ Property_ran x[z]),Property_Value; auto; rewrite Hb.
          apply Hl,(@ Property_ran z),Property_Value; auto; rewrite Hk; auto. }
        apply AxiomII; split; eauto. exists f[x[z]].
        apply AxiomII'; split; auto. apply MKT49a; eauto.
    - unfold Included; intros. apply AxiomII in H5 as [_[x1]].
      apply AxiomII' in H5; tauto. }
  split; auto. intros. apply H1 in H6 as H7. destruct H7 as [δ[H7[H8[H9]]]].
  assert (δ ∈ ℝ /\ 0 < δ); auto.
  apply H2 in H11 as [N[]]. exists N; split; auto. intros.
  assert (x[n] ∈ ℝ).
  { apply Hl,(@ Property_ran n),Property_Value; auto; rewrite Hk; auto. }
  assert (x0 - δ < x[n]).
  { destruct H8. apply H12 in H14 as []; auto. apply Abs_P4 in H14 as [];
    auto with real. apply (Plus_Leq _ _ x0) in H14; auto with real.
    rewrite <-Plus_P3,(Plus_P4 (-x0)),Minus_P1,Plus_P1,Plus_P4 in H14;
    auto with real. split; auto. intro. elim H17. rewrite <-H19.
    rewrite (Plus_P4 x0),<-Plus_P3,Minus_P1,Plus_P1; auto with real.
    assert (｜δ｜ = ｜(-δ)｜). { apply Abs_P2; auto. }
    rewrite <-H20. apply me_zero_Abs; auto. }
  assert (x[n] ≤ x0). { apply H4 in H13; auto. }
  assert (｜(f[x[n]] - A)｜ < ε).
  { assert (x[n] < x0 \/ x0 = x[n]).
    { destruct (classic (x0 = x[n])); auto. left; split; auto. }
    destruct H18 as [H18|H18].
    - apply H10; auto.
    - assert (｜0｜ = 0). { apply Abs_P1; auto with real. }
      destruct H6 as []. rewrite <-H19 in H20. rewrite <-H18,H0,Minus_P1; auto. }
  assert (f[x[n]] ∈ ℝ).
  { apply Hc,(@ Property_ran x[n]),Property_Value; auto.
    apply H3, (@ Property_ran n),Property_Value; auto; rewrite Hk; auto. }
  assert (f[x[n]] = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\[n]).
  { destruct H5. apply Property_Fun; auto. apply AxiomII'; split; auto.
    apply MKT49a; eauto. }
  rewrite <-H20; auto.
Qed.

Theorem Theorem3_9 : ∀ f x0 δ' A, FunctionR_R f -> 0 < δ' -> U+º(x0; δ') ⊂ dom(f) 
  -> Limit_Right f x0 A <-> ∀ x, MonoDec_Seq x -> ran(x) ⊂ U+º(x0; δ')
  -> Limit_Seq x x0 -> Limit_Seq \{\ λ n v, v = f[x[n]] \}\ A.
Admitted.

(* 定理3.10 单调有界定理 *)
Theorem Theorem3_10 : ∀ f x0 δ', FunctionR_R f -> x0 ∈ ℝ -> δ' ∈ ℝ -> 0 < δ'
  -> U+º(x0 ; δ') ⊂ dom(f) -> DMonotonicFun f U+º(x0 ; δ')
  -> DBoundedFun f U+º(x0 ; δ') -> (∃ A, A ∈ ℝ /\ Limit_Right f x0 A).
Proof.
  pose proof OrderPM_Co9 as Ha. pose proof Ha as [Hb Hc].
  assert (1 + 1 ∈ ℝ) as Hd. { auto with real. }
  assert (0 < 1 + 1) as He.
  { assert (0 + 0 < 1 + 1).
    { apply OrderPM_Co4; auto with real. }
    rewrite Plus_P1 in H; auto with real. }
  assert (0 < (1 + 1)⁻) as Hf. { apply OrderPM_Co10; auto. }
  assert (1 + 1 ∈ (ℝ ~ [0])) as Hg.
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto.
    intro. apply MKT41 in H; eauto with real. destruct He; auto. }
  apply Mult_inv1 in Hg as Hh; apply MKT4' in Hh as [Hh _].
  assert (-(1) < 0) as Hz. { apply OrderPM_Co2a; auto with real. }
  intros. pose proof H as Hi. destruct Hi as [Hi[Hj Hk]].
  set (Range := \{ λ y, y ∈ ℝ /\ ∃ x, x ∈ U+º(x0 ; δ') /\ y = f[x] \}).
  assert (f[x0 + δ' / (1 + 1)] ∈ ℝ).
  { apply Hk,(@ Property_ran (x0 + δ' / (1 + 1))),Property_Value; auto;
    rewrite Hj; auto with real. }
  assert (Range ≠ Φ).
  { apply NEexE. exists (f[x0 + δ' / (1 + 1)]).
    apply AxiomII; repeat split; eauto.
    exists (x0 + δ' / (1 + 1)); split; auto.
    assert (0 < δ' / (1 + 1)).
    { apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H2; auto with real.
      rewrite Mult_P4,PlusMult_Co1 in H2; auto with real. }
    assert (x0 < x0 + δ' / (1 + 1)).
    { assert (x0 + 0 < x0 + δ' / (1 + 1)).
      { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
      rewrite Plus_P1 in H8; auto. }
    assert (δ' · (1 + 1) = δ' + δ').
    { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
    assert (δ' < δ' · (1 + 1)).
    { assert (δ' + 0 < δ' + δ').
      { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
      rewrite H9. rewrite Plus_P1 in H10; auto. }
    apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H10; auto with real.
    rewrite <-Mult_P3,Divide_P1,Mult_P1 in H10; auto.
    assert (x0 + δ' / (1 + 1) < x0 + δ').
    { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
    apply AxiomII; split; eauto with real. }
  assert (Range ⊂ ]-∞ , +∞[).
  { unfold Included; intros. apply AxiomII in H8; tauto. }
  destruct H4 as [H4|H4], H5 as [_[_[M[H5[]]]]].
  - apply Sup_Inf_Principle in H8 as H11; auto. destruct H11 as [_].
    assert (∃ L, LowerBound Range L).
    { exists (-M); repeat split; auto with real. intros y H12.
      apply AxiomII in H12 as [H12[]]. destruct H14 as [x[]].
      assert (f[x] ∈ ℝ).
      { apply Hk,(@ Property_ran x),Property_Value; auto. }
      assert (0 ≤ M).
      { apply (Leq_P3 _ ｜(f [x])｜ _); auto with real. apply Abs_P1; auto. }
      apply H10 in H14. apply Abs_P4 in H14 as [H14 _]; auto.
      rewrite H15; auto. }
    apply H11 in H12. destruct H12 as [A[[H12 H13]H14]],H12 as [_[H12]].
    exists A; do 4 (split; auto). exists δ'; do 3 (split; auto).
    intros. destruct H16. assert (A < A + ε).
    { assert (A + 0 < A + ε).
      { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
      rewrite Plus_P1 in H18; auto. }
    apply H13 in H18; auto with real. destruct H18 as [y' []].
    apply AxiomII in H18 as [_[]]. destruct H20 as [x'[]]. rewrite H21 in H19.
    pose proof H20. apply AxiomII in H22 as [_[H22[H23]]].
    assert (0 < x' - x0).
    { apply (OrderPM_Co1 _ _ (-x0)) in H23; auto with real.
      rewrite Minus_P1 in H23; auto. }
    assert (x' - x0 < δ').
    { apply (OrderPM_Co1 _ _ (-x0)) in H24; auto with real.
      rewrite (Plus_P4 x0),<-Plus_P3,Minus_P1,Plus_P1 in H24;  auto with real. }
    exists (x' - x0); split; auto with real; split; auto; split; auto.
    intros. destruct H28. rewrite (Plus_P4 x'),Plus_P3,Minus_P1,Plus_P4,
    Plus_P1 in H29; auto with real.
    assert (f[x] ∈ ℝ /\ f[x'] ∈ ℝ) as [].
    { split; [apply Hk,(@ Property_ran x),Property_Value; auto;
      rewrite Hj; auto|apply Hk,(@ Property_ran x'),Property_Value; auto;
      rewrite Hj; auto]. }
    assert (x ∈ U+º(x0 ; δ')).
    { apply AxiomII; split; eauto; split; auto; split; auto.
      apply (RTrans_Lt _ x' _); auto with real. }
    assert (f[x] ∈ Range). { apply AxiomII; repeat split; eauto. }
    apply H4 in H29 as H34; auto. apply H15 in H33.
    assert (- ε < 0).
    { apply (OrderPM_Co8a _ _ (-(1))) in H17; auto with real.
      rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,PlusMult_Co1 in H17;
      auto with real. }
    assert (A - ε < f[x]).
    { assert (A - ε < f[x] + 0). { apply OrderPM_Co4; auto with real. }
      rewrite Plus_P1 in H36; auto. }
    assert (f[x] < A + ε). { apply (Order_Co2 _ f[x'] _); auto with real. }
    destruct H17,H36,H37. split.
    + apply Abs_P4; auto with real. split.
      * apply (Plus_Leq_Cancel _ _ A); auto with real.
        rewrite <-Plus_P3,(Plus_P4 (-A)),Minus_P1,Plus_P1,Plus_P4;
        auto with real.
      * apply (Plus_Leq_Cancel _ _ A); auto with real.
        rewrite <-Plus_P3,(Plus_P4 (-A)),Minus_P1,Plus_P1,Plus_P4;
        auto with real.
    + intro. elim H40.
      assert (0 ≤ f[x] - A).
      { apply (Plus_Leq _ _ (-A)) in H33; auto with real.
        rewrite Minus_P1 in H33; auto. }
      assert (｜(f[x] - A)｜ = f[x] - A). { apply me_zero_Abs; auto with real. }
      rewrite H43 in H41. apply (RPlus_Eq' _ _ (-A)); auto with real.
      rewrite (Plus_P4 A),<-Plus_P3,Minus_P1,Plus_P1; auto with real.
  - apply Sup_Inf_Principle in H8 as H11; auto. destruct H11 as [H11 _].
    assert (∃ U, UpperBound Range U).
    { exists M; repeat split; auto with real. intros y H12.
      apply AxiomII in H12 as [H12[]]. destruct H14 as [x[]].
      assert (f[x] ∈ ℝ).
      { apply Hk,(@ Property_ran x),Property_Value; auto. }
      assert (0 ≤ M).
      { apply (Leq_P3 _ ｜(f [x])｜ _); auto with real. apply Abs_P1; auto. }
      apply H10 in H14. apply Abs_P4 in H14 as [_ H14]; auto.
      rewrite H15; auto. }
    apply H11 in H12. destruct H12 as [A[[H12 H13]H14]],H12 as [_[H12]].
    exists A; do 4 (split; auto). exists δ'; do 3 (split; auto).
    intros. destruct H16. assert (- ε < 0).
    { apply (OrderPM_Co8a _ _ (-(1))) in H17; auto with real.
      rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,PlusMult_Co1 in H17;
      auto with real. }
    assert (A - ε < A).
    { assert (A - ε < A + 0).
      { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
      rewrite Plus_P1 in H19; auto. }
    apply H13 in H19; auto with real. destruct H19 as [y'[]].
    apply AxiomII in H19 as [_[]]. destruct H21 as [x'[]]. rewrite H22 in H20.
    pose proof H21. apply AxiomII in H23 as [_[H23[H24]]].
    assert (0 < x' - x0).
    { apply (OrderPM_Co1 _ _ (-x0)) in H24; auto with real.
      rewrite Minus_P1 in H24; auto. }
    assert (x' - x0 < δ').
    { apply (OrderPM_Co1 _ _ (-x0)) in H25; auto with real.
      rewrite (Plus_P4 x0),<-Plus_P3,Minus_P1,Plus_P1 in H25; auto with real. }
    exists (x' - x0); split; auto with real; split; auto; split; auto.
    intros. destruct H29. rewrite (Plus_P4 x'),Plus_P3,Minus_P1,Plus_P4,
    Plus_P1 in H30; auto with real.
    assert (f[x] ∈ ℝ /\ f[x'] ∈ ℝ) as [].
    { split; [apply Hk, (@ Property_ran x), Property_Value; auto;
      rewrite Hj; auto|apply Hk, (@ Property_ran x'), Property_Value; auto;
      rewrite Hj; auto]. }
    assert (x ∈ U+º(x0 ; δ')).
    { apply AxiomII; split; eauto; split; auto; split; auto.
      apply (RTrans_Lt _ x' _); auto with real. }
    assert (f[x] ∈ Range). { apply AxiomII; repeat split; eauto. }
    apply H4 in H30 as H35; auto. apply H15 in H34.
    assert (f[x] < A + ε).
    { assert (f[x] + 0 < A + ε). { apply OrderPM_Co4; auto with real. }
      rewrite Plus_P1 in H36; auto. }
    assert (A - ε < f[x]). { apply (Order_Co2 _ f[x'] _); auto with real. }
    destruct H17,H36,H37. split.
    + apply Abs_P4; auto with real. split.
      * apply (Plus_Leq_Cancel _ _ A); auto with real.
        rewrite <-Plus_P3,(Plus_P4 (-A)),Minus_P1,Plus_P1,Plus_P4;
        auto with real.
      * apply (Plus_Leq_Cancel _ _ A); auto with real.
        rewrite <-Plus_P3,(Plus_P4 (-A)),Minus_P1,Plus_P1,Plus_P4;
        auto with real.
    + intro. elim H40.
      assert (f[x] - A ≤ 0).
      { apply (Plus_Leq _ _ (-A)) in H34; auto with real.
        rewrite Minus_P1 in H34; auto. }
      assert (｜(f[x] - A)｜ = - (f[x] - A)).
      { apply le_zero_Abs; auto with real. }
      rewrite H43 in H41. apply (RMult_Eq _ _ (-(1))) in H41; auto with real.
      rewrite Mult_P4,<-PlusMult_Co3,Minus_P3,Minus_P4,Minus_P3,Minus_P4,
      Mult_P4,<-PlusMult_Co3 in H41; auto with real.
      apply (RPlus_Eq _ _ A) in H41; auto with real.
      rewrite <-Plus_P3,(Plus_P4 (-A)),Minus_P1,Plus_P1,Plus_P4 in H41;
      auto with real.
Qed.

(* 3.11 柯西准则 *)
Theorem Theorem3_11 : ∀ f x0 δ', FunctionR_R f -> x0 ∈ ℝ -> δ' ∈ ℝ -> 0 < δ'
  -> Uº(x0 ; δ') ⊂ dom(f) -> (∃ A, Limit_x0 f x0 A)
  <-> (∀ ε, ε ∈ ℝ /\ 0 < ε -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < δ' 
      /\ (∀ x' x'', x' ∈ Uº(x0 ; δ) -> x'' ∈ Uº(x0 ; δ)
        -> (｜(f[x'] - f[x''])｜) < ε))).
Proof.
  pose proof OrderPM_Co9 as Ha. pose proof Ha as [Hb Hc].
  assert (1 + 1 ∈ ℝ) as Hd. { auto with real. }
  assert (0 < 1 + 1) as He.
  { assert (0 + 0 < 1 + 1).
    { apply OrderPM_Co4; auto with real. }
    rewrite Plus_P1 in H; auto with real. }
  assert (0 < (1 + 1)⁻) as Hf. { apply OrderPM_Co10; auto. }
  assert (1 + 1 ∈ (ℝ ~ [0])) as Hg.
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto.
    intro. apply MKT41 in H; eauto with real. destruct He; auto. }
  apply Mult_inv1 in Hg as Hh; apply MKT4' in Hh as [Hh _]. intros.
  destruct H as [H [Hi Hj]]. split; intros.
  - destruct H4 as [A [_[_[H4 [δ1' [H7 [H8 [H9]]]]]]]]. destruct H5.
    assert (ε / (1 + 1) ∈ ℝ /\ 0 < ε / (1 + 1)).
    { split; auto with real. apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H10;
      auto with real. rewrite Mult_P4, PlusMult_Co1 in H10; auto with real. }
    apply H6 in H11 as H12.
    assert (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < δ'
      /\ (∀ x, x ∈ Uº(x0 ; δ) -> ｜(f[x] - A)｜ < ε / (1 + 1))).
    { destruct H12 as [δ [H12 [H13 [H14]]]].
      destruct (Leq_P4 δ' δ1') as [H16 | H16]; auto.
      assert (0 < δ' / (1 + 1)).
      { apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H2; auto with real.
        rewrite Mult_P4, PlusMult_Co1 in H2; auto with real. }
      assert (δ' · (1 + 1) = δ' + δ').
      { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
      assert (δ' < δ' · (1 + 1)).
      { assert (δ' + 0 < δ' + δ').
        { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
        rewrite H18. rewrite Plus_P1 in H19; auto. }
      apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H19; auto with real.
      rewrite <-Mult_P3, Divide_P1, Mult_P1 in H19; auto.
      -- destruct (Order_Co1 δ' δ) as [H20 | [H20 | H20]]; auto.
         ++ exists (δ' / (1 + 1)); split; auto with real.
            split; auto; split; auto. intros.
            apply AxiomII in H21 as [_[H21 [H22]]]. apply H15; auto.
            assert (δ · (1 + 1) = δ + δ).
            { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
            assert (δ' < δ · (1 + 1)).
            { assert (δ' + 0 < δ + δ).
              { apply OrderPM_Co4; auto with real. destruct H20; auto. }
              rewrite H24. rewrite Plus_P1 in H25; auto. }
            apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H25; auto with real.
            rewrite <-Mult_P3, Divide_P1, Mult_P1 in H25; auto.
            split; auto. apply (RTrans_Lt _ (δ' / (1 + 1)) _); auto with real.
         ++ exists δ; split; auto; split; auto; split; auto. intros.
            apply AxiomII in H21 as [_[H21]]. apply H15; auto.
         ++ exists (δ' / (1 + 1)); split; auto with real.
            split; auto; split; auto. intros.
            apply AxiomII in H21 as [_[H21 [H22]]]. apply H15; auto.
            rewrite <-H20. split; auto. apply (RTrans_Lt _ (δ' / (1 + 1)) _);
            auto with real.
      -- destruct (Order_Co1 δ1' δ) as [H17 | [H17 | H17]]; auto.
         ++ destruct H14, H17. elim H19. apply Leq_P2; auto.
         ++ assert (δ < δ'). { apply (Order_Co2 _ δ1' _); auto. }
            exists δ; split; auto; split; auto; split; auto. intros.
            apply AxiomII in H19 as [_[H19]]. apply H15; auto.
         ++ destruct H14. symmetry in H17; contradiction. }
    destruct H13 as [δ [H13 [H14 []]]]. exists δ; split; auto; split; auto.
    split; auto. intros. pose proof H17; pose proof H18.
    apply AxiomII in H19 as [_[H19 [H21]]], H20 as [_[H20 [H23]]].
    assert (f[x'] ∈ ℝ /\ f[x''] ∈ ℝ) as [].
    { split; [apply Hj, (@ Property_ran x'), Property_Value; auto;
      rewrite Hi; auto|apply Hj, (@ Property_ran x''), Property_Value; auto;
      rewrite Hi; auto]. }
    assert (f [x'] - A - (f [x''] - A) ∈ ℝ). { auto with real. }
    assert (f[x'] - f[x''] = (f[x'] - A) - (f[x''] - A)).
    { rewrite Minus_P3, Minus_P4, <-Plus_P3, (Plus_P4 (-A)), <-Plus_P3, 
      Minus_P1, Plus_P1; auto with real. }
    assert (｜((f[x'] - A) - (f[x''] - A))｜ ≤ ｜(f[x'] - A)｜ + ｜(f[x''] - A)｜).
    { apply Abs_P5; auto with real. }
    apply H16 in H17, H18. assert (ε / (1 + 1) + ε / (1 + 1) = ε).
    { assert (ε / (1 + 1) + ε / (1 + 1) = ((ε + ε) / (1 + 1))).
      { rewrite <-Mult_P5; auto. }
      assert (ε + ε = ε · (1 + 1)).
      { rewrite Mult_P4, Mult_P5, Mult_P4, Mult_P1; auto with real. }
      rewrite H31, <-Mult_P3, Divide_P1, Mult_P1 in H30; auto. }
    assert (｜(f[x'] - A)｜ + ｜(f[x''] - A)｜ < ε).
    { rewrite <-H30. destruct H17. apply OrderPM_Co4; auto with real. }
    rewrite H28. apply (Order_Co2 _ (｜(f[x'] - A)｜ + ｜(f[x''] - A)｜) _);
    auto with real. 
  - assert (∀ x, Seq x -> ran(x) ⊂ Uº(x0 ; δ') -> Limit_Seq x x0
      -> Conv_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\).
    { intros. assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\).
      { repeat split; intros.
        -- unfold Relation; intros. apply AxiomII in H8 as [_ [x1 [y]]].
           exists x1, y; tauto.
        -- apply AxiomII' in H8 as [H8 [H10 []]], H9 as [H13 [H14 []]].
           rewrite H12; auto.
        -- apply AxiomI; split; intros.
           ++ apply AxiomII in H8 as [_ []]. apply AxiomII' in H8; tauto.
           ++ assert (f[x[z]] ∈ ℝ).
              { apply Hj, (@ Property_ran x[z]), Property_Value; auto.
                rewrite Hi. destruct H5 as [H5 []].
                apply H10, (@ Property_ran z), Property_Value; auto.
                rewrite H9; auto. }
              apply AxiomII; split; eauto. exists f[x[z]].
              apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
        -- unfold Included; intros. apply AxiomII in H8 as [_ [x1]].
           apply AxiomII' in H8; tauto. }
       unfold Conv_Seq. admit. }
  Admitted.


(* 3.5 无穷小量与无穷大量 *)
(* 无穷小量 *)

Definition InfSmall_Fun f x0 := Limit_x0 f x0 0.

Corollary InfSmall_Fun_a : ∀ f g x0, InfSmall_Fun f x0
  -> InfSmall_Fun g x0 -> InfSmall_Fun (f \+ g) x0.
Proof.
Admitted.


Print Bounded.

(* 4.1 连续性的概念 *)
(* 函数在一点的连续性 *)

Definition Continuous f x0 := x0 ∈ dom(f) /\ Limit_x0 f x0 f[x0].

Definition Continuous' f x0 := x0 ∈ dom(f)
  /\ Limit_x0 \{\ λ Δx Δy, Δx ∈ ℝ /\ Δy ∈ ℝ /\ Δy = f[x0 + Δx] - f[x0] \}\ 0 0.

(* 两种定义等价 *)
Corollary Continuous_Equal : ∀ f x0, Continuous f x0 -> Continuous' f x0.
Proof.
  intros. destruct H. red; split; auto. unfold Limit_x0 in *.
  destruct H0 as [H0[H1[H2[δ'[H3[H4[H5]]]]]]], H0 as [H0 []].
  assert (Function \{\ λ Δx Δy, Δx ∈ ℝ /\ Δy ∈ ℝ
    /\ Δy = f[x0 + Δx] - f[x0] \}\).
  { split.
    -- red; intros. apply AxiomII in H9 as [H9[x[y[]]]]. exists x, y; auto.
    -- intros. apply AxiomII' in H9 as [H9[H11[H12]]], H10 as [H10[H14[H15]]].
       rewrite H13; auto. } 
  assert (FunctionR_R \{\ λ Δx Δy, Δx ∈ ℝ /\ Δy ∈ ℝ
    /\ Δy = f[x0 + Δx] - f[x0] \}\).
  { split; auto; split.
    -- apply AxiomI; split; intros.
       ++ apply AxiomII in H10 as [H10[y]].
          apply AxiomII' in H11 as [H11[]]; auto.
       ++ apply AxiomII; split; eauto. exists (f[x0 + z] - f[x0]).
          assert (f[x0 + z] ∈ ℝ).
          { apply H8,(@ Property_ran (x0 + z)),Property_Value; auto;
            rewrite H7; auto with real. }
          apply AxiomII'; repeat split; auto with real.
          apply MKT49a; eauto with real.
    -- red; intros. apply AxiomII in H10 as [H10[x]].
       apply AxiomII' in H11 as [H11[H12[]]]; auto. }
  split; auto. repeat split; auto with real.
  exists δ'; split; auto; split; auto; split.
  - red; intros. apply AxiomII in H11 as [H11[H12[]]].
    apply AxiomII; split; auto. exists (f[x0 + z] - f[x0]).
    assert (f[x0 + z] ∈ ℝ).
    { apply H8,(@ Property_ran (x0 + z)),Property_Value; auto;
      rewrite H7; auto with real. }
    apply AxiomII'; repeat split; auto with real.
    apply MKT49a; eauto with real.
  - intros. apply H6 in H11 as [δ[H11[H12[H13]]]].
    exists δ; do 3 (split; auto). intros.
    assert (f[x0 + x] ∈ ℝ).
    { apply H8,(@ Property_ran (x0 + x)),Property_Value; auto;
      rewrite H7; auto with real. }
    assert (f[x0 + x] - f[x0] = \{\ λ Δx Δy, Δx ∈ ℝ /\ Δy ∈ ℝ
      /\ Δy = f[x0 + Δx] - f[x0] \}\ [x]).
    { apply Property_Fun; auto. apply AxiomII'; split; auto with real.
      apply MKT49a; eauto with real. }
    rewrite <-H18. pose proof (H14 (x0 + x)).
    assert (x0 + x - x0 = x).
    { rewrite (Plus_P4 x0),<-Plus_P3,Minus_P1,Plus_P1; auto with real. }
    rewrite H20 in H19. rewrite Minus_P2 in H16; auto.
    rewrite Minus_P2; auto with real.
Qed.

(* 左连续 *)
Definition Continuous_Left f x0 := x0 ∈ dom(f) /\ Limit_Left f x0 f[x0].

(* 右连续 *)
Definition Continuous_Right f x0 := x0 ∈ dom(f) /\ Limit_Right f x0 f[x0].

(* f在一点连续的充要条件 *)
Theorem Theorem4_1 : ∀ f x0, Continuous f x0
  <-> Continuous_Left f x0 /\ Continuous_Right f x0.
Proof.
  split; intros.
  - destruct H. split.
    + split; auto. apply Theorem3_1 in H0 as []; auto.
    + split; auto. apply Theorem3_1 in H0 as []; auto.
  - destruct H as [[][]]. split; auto. apply Theorem3_1; auto.
Qed.

(* 可去间断点 *)
Definition Discontinuity_Remove f x0 := ∃ A, Limit_x0 f x0 A
  /\ (x0 ∉ dom(f) \/ (x0 ∈ dom(f) /\ f[x0] ≠ A)).

(* 跳跃间断点 *)
Definition Discontinuity_Jump f x0 := ∃ A B, Limit_Left f x0 A
  /\ Limit_Right f x0 B /\ A ≠ B.

(* 第一类间断点 *)
Definition Discontinuity_First f x0 := Discontinuity_Remove f x0
  \/ Discontinuity_Jump f x0.

(* 第二类间断点 *)
Definition Discontinuity_Second f x0 := (∀ A, ~ Limit_Left f x0 A)
\/ (∀ B, ~ Limit_Right f x0 B).

(* 函数在开区间上连续 *)
Definition Continuous_Open f a b := ∀ x, x ∈ ］a, b［ -> Continuous f x.

(* 函数在闭区间上连续 *)
Definition Continuous_Close f a b := Continuous_Open f a b
  /\ Continuous_Right f a /\ Continuous_Left f b.

(* 函数在左开右闭区间上连续 *)
Definition Continuous_LORC f a b := Continuous_Open f a b 
  /\ Continuous_Left f b.

(* 函数在左闭右开区间上连续 *)
Definition Continuous_LCRO f a b := Continuous_Open f a b
  /\ Continuous_Right f a.

(* 函数在闭区间上分段连续 *)
Definition Continuous_Close_Piece f a b :=
  Finite \{ λ u, u ∈［a, b］/\ Discontinuity_First f u \}
  /\ ∀ x, x ∈ (［a, b］~ \{ λ u, u ∈［a, b］/\ Discontinuity_First f u \})
  -> Continuous f x.

(* DBoundedFun : Function f /\ D ⊂ dom( f) /\ 
  (∃ M, M ∈ ]-∞ , +∞[ /\ (∀x : Class,x ∈ D -> ｜(f[x])｜ ≤ M)) *)

(* 4.2 连续函数的性质 *)
(* 局部有界性 *)
Theorem Theorem4_2 : ∀ f x0, Continuous f x0 
  -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ DBoundedFun f U(x0; δ)).
Proof.
  intros. destruct H as [H H0]. New H0. destruct H1 as [H1[H2[H3 _]]].
  assert (∃ A, A ∈ ℝ /\ Limit_x0 f x0 A). { exists f[x0]; split; auto. }
  apply Theorem3_3a in H4 as [δ[H4[H5]]]. exists δ; split; auto; split; auto.
  destruct H6 as [_[H6[M[H7[H8]]]]],H1 as [H1[]].
  assert (∀ z, z ∈ U(x0; δ) -> z ∈ Uº(x0; δ) \/ z = x0).
  { intros. destruct (classic (z = x0)); auto. apply AxiomII in H12 as [H12[]].
    left; apply AxiomII; do 3 (split; auto). split.
    - apply Abs_P1; auto with real.
    - intro. elim H13. apply Abs_P6; auto. }
  assert (U(x0; δ) ⊂ dom(f)).
  { unfold Included; intros. apply H12 in H13 as [H13|H13]; auto.
    rewrite H13; auto. }
  split; auto; split; auto. destruct (Leq_P4 M f[x0]); auto.
  - assert (0 < f[x0]). { apply (Order_Co2 _ M _); auto with real. }
    exists f[x0]; split; auto; split; auto. intros. assert (f[x] ∈ ℝ).
    { apply H11,(@ Property_ran x),Property_Value; auto. }
    apply H12 in H16 as [H16|H16].
    + apply (Leq_P3 _ M _); auto with real.
    + destruct H15. rewrite H16,me_zero_Abs; auto. apply Leq_P1; auto.
  - destruct (Leq_P4 (-M) f[x0]); auto with real.
    + exists M; split; auto; split; auto. intros.
      apply H12 in H16 as [H16|H16]; auto. rewrite H16. destruct H8.
      apply Abs_P4; auto.
    + assert (-(1) ≤ 0).
      { pose proof OrderPM_Co9 as []. apply OrderPM_Co2b; auto with real. }
      assert (M ≤ -f[x0]).
      { apply (OrderPM_Co8b _ _ (-(1))) in H15; auto with real.
        rewrite Mult_P4,<-PlusMult_Co3,Minus_P4,Mult_P4,<-PlusMult_Co3 in H15;
        auto with real. }
      assert (0 < -f[x0]). { apply (Order_Co2 _ M _); auto with real. }
      exists (-f[x0]); split; auto with real; split; auto. intros.
      assert (f[x] ∈ ℝ).
      { apply H11,(@ Property_ran x),Property_Value; auto. }
      apply H12 in H19 as [H19|H19].
      * apply (Leq_P3 _ M _); auto with real.
      * destruct H18. rewrite H19 in *. apply Abs_P4; auto with real.
        split; [rewrite Minus_P4; auto; apply Leq_P1; auto
        |apply (Leq_P3 _ M _); auto with real].
Qed.

(* 4.3 局部保号性 *)
Theorem Theorem4_3a : ∀ f x0, Continuous f x0 -> 0 < f[x0]
  -> (∀ r, r ∈ ℝ -> 0 < r -> r < f[x0]
  -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ (∀ x, x ∈ U(x0; δ) -> 0 < r /\ r < f[x]))).
Proof.
  intros. destruct H. New H4. destruct H4 as [H4[H6[H7 _]]].
  apply Theorem3_4a with (r:= r) in H5 as [δ[H5[]]]; auto.
  exists δ; split; auto; split; auto. intros.
  assert (x ∈ Uº(x0; δ) \/ x = x0).
  { destruct (classic (x = x0)); auto. left; apply AxiomII in H10 as [H10[]].
    apply AxiomII; do 3 (split; auto). split.
    apply Abs_P1; auto with real. intro. elim H11. apply Abs_P6; auto. }
  destruct H11 as [H11|H11]; auto. rewrite H11; auto.
Qed.

Theorem Theorem4_3a1 : ∀ f x0, Continuous_Right f x0 -> 0 < f[x0]
  -> (∀ r, r ∈ ℝ -> 0 < r -> r < f[x0]
  -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ (∀ x, x ∈ U+(x0; δ) -> 0 < r /\ r < f[x]))).
Proof.
  intros. destruct H,H4 as [H4[H5[H6[δ'[H7[H8[H9]]]]]]].
  assert (f[x0] - r ∈ ℝ /\ 0 < f[x0] - r).
  { split; auto with real. apply (OrderPM_Co1 _ _ (-r)) in H3; auto with real.
    rewrite Minus_P1 in H3; auto. }
  apply H10 in H11 as [δ[H11[H12[H13]]]]. exists δ; split; auto; split; auto.
  intros; split; auto.
  assert (x ∈ U+º(x0; δ) \/ x = x0).
  { destruct (classic (x = x0)); auto.
    left; apply AxiomII in H15 as [H15[H17[H18]]].
    assert (x0 < x). { split; auto. } apply AxiomII; auto. }
  destruct H16 as [H16|H16].
  - apply AxiomII in H16 as [_[H16]]. apply H14 in H17 as []; auto.
    assert (f[x] ∈ ℝ).
    { destruct H4 as [H4[]]. apply H20,(@ Property_ran x),Property_Value; auto.
      rewrite H19; auto. }
    assert (0 < f[x0] - r) as [].
    { apply (OrderPM_Co1 _ _ (-r)) in H3; auto with real.
      rewrite Minus_P1 in H3; auto. }
    apply Abs_P4 in H17 as []; auto with real.
    rewrite Minus_P3,Minus_P4,Plus_P4 in H17; auto with real.
    apply (Plus_Leq _ _ f[x0]) in H17; auto with real.
    rewrite <-Plus_P3,<-Plus_P3,(Plus_P4 (-f[x0])),Minus_P1,Plus_P1,Plus_P1
    in H17; auto with real. split; auto. intro. elim H18. rewrite H23 in *.
    assert (-(1) ≤ 0).
    { pose proof OrderPM_Co9 as []. apply OrderPM_Co2b; auto with real. }
    assert (f[x] - f[x0] ≤ 0).
    { apply (OrderPM_Co8b _ _ (-(1))) in H20; auto with real.
      rewrite Mult_P4,<-PlusMult_Co3,Minus_P3,Minus_P4,Plus_P4,
      Mult_P4,PlusMult_Co1 in H20; auto with real. }
    rewrite le_zero_Abs,Minus_P3,Minus_P4,Plus_P4; auto with real.
  - rewrite H16 in *; auto.
Qed.
    
Theorem Theorem4_3a2 : ∀ f x0, Continuous_Left f x0 -> 0 < f[x0]
  -> (∀ r, r ∈ ℝ -> 0 < r -> r < f[x0]
  -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ (∀ x, x ∈ U-(x0; δ) -> 0 < r /\ r < f[x]))).
Proof.
  intros. destruct H,H4 as [H4[H5[H6[δ'[H7[H8[H9]]]]]]].
  assert (f[x0] - r ∈ ℝ /\ 0 < f[x0] - r).
  { split; auto with real. apply (OrderPM_Co1 _ _ (-r)) in H3; auto with real.
    rewrite Minus_P1 in H3; auto. }
  apply H10 in H11 as [δ[H11[H12[H13]]]]. exists δ; split; auto; split; auto.
  intros; split; auto.
  assert (x ∈ U-º(x0; δ) \/ x = x0).
  { destruct (classic (x = x0)); auto.
    left; apply AxiomII in H15 as [H15[H17[H18]]].
    assert (x < x0). { split; auto. } apply AxiomII; auto. }
  destruct H16 as [H16|H16].
  - apply AxiomII in H16 as [_[H16]]. apply H14 in H17 as []; auto.
    assert (f[x] ∈ ℝ).
    { destruct H4 as [H4[]]. apply H20,(@ Property_ran x),Property_Value; auto.
      rewrite H19; auto. }
    assert (0 < f[x0] - r) as [].
    { apply (OrderPM_Co1 _ _ (-r)) in H3; auto with real.
      rewrite Minus_P1 in H3; auto. }
    apply Abs_P4 in H17 as []; auto with real.
    rewrite Minus_P3,Minus_P4,Plus_P4 in H17; auto with real.
    apply (Plus_Leq _ _ f[x0]) in H17; auto with real.
    rewrite <-Plus_P3,<-Plus_P3,(Plus_P4 (-f[x0])),Minus_P1,Plus_P1,Plus_P1
    in H17; auto with real. split; auto. intro. elim H18. rewrite H23 in *.
    assert (-(1) ≤ 0).
    { pose proof OrderPM_Co9 as []. apply OrderPM_Co2b; auto with real. }
    assert (f[x] - f[x0] ≤ 0).
    { apply (OrderPM_Co8b _ _ (-(1))) in H20; auto with real.
      rewrite Mult_P4,<-PlusMult_Co3,Minus_P3,Minus_P4,Plus_P4,
      Mult_P4,PlusMult_Co1 in H20; auto with real. }
    rewrite le_zero_Abs,Minus_P3,Minus_P4,Plus_P4; auto with real.
  - rewrite H16 in *; auto.
Qed.

Theorem Theorem4_3b : ∀ f x0, Continuous f x0 -> f[x0] < 0
  -> (∀ r, r ∈ ℝ -> 0 < r -> r < -f[x0]
  -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ (∀ x, x ∈ U(x0; δ) -> f[x] < -r /\ -r < 0))).
Proof.
  intros. destruct H. New H4. destruct H4 as [H4[H6[H7 _]]].
  apply Theorem3_4b with (r:= r) in H5 as [δ[H5[]]]; auto.
  exists δ; split; auto; split; auto. intros.
  assert (x ∈ Uº(x0; δ) \/ x = x0).
  { destruct (classic (x = x0)); auto. left; apply AxiomII in H10 as [H10[]].
    apply AxiomII; do 3 (split; auto). split.
    apply Abs_P1; auto with real. intro. elim H11. apply Abs_P6; auto. }
  destruct H11 as [H11|H11]; auto.
  assert (-(1) < 0).
  { pose proof OrderPM_Co9. apply OrderPM_Co2a; auto with real. }
  apply (OrderPM_Co8a _ _ (-(1))) in H2,H3; auto with real.
  rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,PlusMult_Co1 in H2; auto with real.
  rewrite Mult_P4,<-PlusMult_Co3,Minus_P4,Mult_P4,<-PlusMult_Co3 in H3;
  auto with real. rewrite H11; auto.
Qed.

Theorem Theorem4_3b1 : ∀ f x0, Continuous_Right f x0 -> f[x0] < 0
  -> (∀ r, r ∈ ℝ -> 0 < r -> r < -f[x0]
  -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ (∀ x, x ∈ U+(x0; δ) -> f[x] < -r /\ -r < 0))).
Proof.
  intros. destruct H,H4 as [H4[H5[H6[δ'[H7[H8[H9]]]]]]].
  assert (-f[x0] - r ∈ ℝ /\ 0 < -f[x0] - r).
  { split; auto with real. apply (OrderPM_Co1 _ _ (-r)) in H3; auto with real.
    rewrite Minus_P1 in H3; auto. }
  apply H10 in H11 as H12. destruct H12 as [δ[H12[H13[H14]]]].
  exists δ; split; auto; split; auto. intros.
  assert (x ∈ U+º(x0; δ) \/ x = x0).
  { destruct (classic (x = x0)); auto.
    left; apply AxiomII in H16 as [H16[H18[]]].
    assert (x0 < x). { split; auto. } apply AxiomII; auto. }
  assert (-(1) < 0).
  { pose proof OrderPM_Co9. apply OrderPM_Co2a; auto with real. }
  assert (-r < 0).
  { apply (OrderPM_Co8a _ _ (-(1))) in H2; auto with real.
    rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,PlusMult_Co1 in H2; auto with real. }
  split; auto. destruct H17 as [H17|H17].
  - apply AxiomII in H17 as [_[H17]]. apply H15 in H20 as []; auto.
    assert (f[x] ∈ ℝ).
    { destruct H4 as [H4[]]. apply H23,(@ Property_ran x),Property_Value; auto.
      rewrite H22; auto. }
    destruct H11 as [_ []]. apply Abs_P4 in H20 as []; auto with real.
    apply (Plus_Leq _ _ f[x0]) in H24; auto with real.
    rewrite <-Plus_P3,(Plus_P4 (-f[x0])),Minus_P1,Plus_P1,
    Plus_P4,Plus_P3,Minus_P1,Plus_P4,Plus_P1 in H24; auto with real.
    split; auto. intro. elim H21. rewrite H25,Plus_P4,me_zero_Abs;
    auto with real.
  - apply (OrderPM_Co8a _ _ (-(1))) in H3; auto with real.
    rewrite Mult_P4,<-PlusMult_Co3,Minus_P4,Mult_P4,<-PlusMult_Co3 in H3;
    auto with real. rewrite H17; auto.
Qed.

Theorem Theorem4_3b2 : ∀ f x0, Continuous_Left f x0 -> f[x0] < 0
  -> (∀ r, r ∈ ℝ -> 0 < r -> r < -f[x0]
  -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ (∀ x, x ∈ U-(x0; δ) -> f[x] < -r /\ -r < 0))).
Proof.
  intros. destruct H,H4 as [H4[H5[H6[δ'[H7[H8[H9]]]]]]].
  assert (-f[x0] - r ∈ ℝ /\ 0 < -f[x0] - r).
  { split; auto with real. apply (OrderPM_Co1 _ _ (-r)) in H3; auto with real.
    rewrite Minus_P1 in H3; auto. }
  apply H10 in H11 as H12. destruct H12 as [δ[H12[H13[H14]]]].
  exists δ; split; auto; split; auto. intros.
  assert (x ∈ U-º(x0; δ) \/ x = x0).
  { destruct (classic (x = x0)); auto.
    left; apply AxiomII in H16 as [H16[H18[]]].
    assert (x < x0). { split; auto. } apply AxiomII; auto. }
  assert (-(1) < 0).
  { pose proof OrderPM_Co9. apply OrderPM_Co2a; auto with real. }
  assert (-r < 0).
  { apply (OrderPM_Co8a _ _ (-(1))) in H2; auto with real.
    rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,PlusMult_Co1 in H2; auto with real. }
  split; auto. destruct H17 as [H17|H17].
  - apply AxiomII in H17 as [_[H17]]. apply H15 in H20 as []; auto.
    assert (f[x] ∈ ℝ).
    { destruct H4 as [H4[]]. apply H23,(@ Property_ran x),Property_Value; auto.
      rewrite H22; auto. }
    destruct H11 as [_ []]. apply Abs_P4 in H20 as []; auto with real.
    apply (Plus_Leq _ _ f[x0]) in H24; auto with real.
    rewrite <-Plus_P3,(Plus_P4 (-f[x0])),Minus_P1,Plus_P1,
    Plus_P4,Plus_P3,Minus_P1,Plus_P4,Plus_P1 in H24; auto with real.
    split; auto. intro. elim H21. rewrite H25,Plus_P4,me_zero_Abs;
    auto with real.
  - apply (OrderPM_Co8a _ _ (-(1))) in H3; auto with real.
    rewrite Mult_P4,<-PlusMult_Co3,Minus_P4,Mult_P4,<-PlusMult_Co3 in H3;
    auto with real. rewrite H17; auto.
Qed.

(* Theorem Theorem4_5 : ∀ f g x0 u0, Continuous f x0 -> Continuous g u0
  -> u0 = f[x0] -> Continuous (g ∘ f) x0.

Theorem Theorem4_4a : ∀ f g x0, Continuous f x0 -> Continuous g x0 
  -> Continuous (f \+ g) x0.


Theorem Theorem4_4b : ∀ f g x0, Continuous f x0 -> Continuous g x0
  -> Continuous (f \- g) x0.

Theorem Theorem4_4c : ∀ f g x0, Continuous f x0 -> Continuous g x0
  -> Continuous (f \· g) x0.
  
Theorem Theorem4_4d : ∀ f g x0, Continuous f x0 -> Continuous g x0
  -> g[x0] <> 0 -> Continuous (f // g) x0.  *)

(* via Arch_9 solve *)
Theorem Archimedes : ∀ a b, a ∈ ℝ -> b ∈ ℝ -> 0 < a -> 0 < b 
  -> ∃ n, n ∈ ℕ /\ b < n · a.
Proof.
Admitted.
(*   intros. apply NNPP; intro.
  assert (∀ n, n ∈ ℕ -> ~(b < n · a)).
  { intros. intro. elim H3. exists n; auto. }
  assert (∀ n, n ∈ ℕ -> ~ b < n · a <-> n · a ≤ b).
  { intros. pose proof H5; apply N_Subset_R in H6.
    apply RNot_Lt_Ge; auto with real. } 
  set (E:= \{ λ r, r ∈ ℝ /\ n ∈ ℕ /\ r = n · a \}). *)

(* Definition ChoiceFunction c := Function c /\ (∀ x, x ∈ dom(c) -> c[x] ∈ x). *)

Proposition or_to_imply : ∀ P Q, (~ P \/ Q) -> (P -> Q).
Proof.
  intros. destruct H as [H|H]; auto. contradiction.
Qed.

(* 有界性定理 *)
Lemma Lemma4_6 : ∀ f a b, Continuous_Close f a b -> DBoundedFun f (［a, b］).
Proof.
  pose proof OrderPM_Co9 as Hz. assert (-(1) < 0) as Hy.
  { apply OrderPM_Co2a in Hz; auto with real. }
  pose proof Hy as [Hx Hw].
  intros. destruct H as [Ha [Hb Hc]]. unfold Continuous_Open in Ha.
  destruct Hb as [Hb[Hd[He[Hf[δ1'[Hg[Hh[Hi]]]]]]]],
  Hc as [Hc[Hj[Hk[Hl[δ2'[Hm[Hn[Ho]]]]]]]], Hj as [Hj[Hp Hq]].
  assert (［a, b］ ⊂ dom(f)).
  { unfold Included; intros. apply AxiomII in H1 as [H1[H2[H3]]].
    assert ((z ∈ ］a, b［) \/ z = a \/ z = b) as [H5|[H5|H5]].
    { destruct (classic (z = a)).
      - right; left; auto.
      - destruct (classic (z = b)).
        + right; right; auto.
        + assert (a < z /\ z < b). { repeat split; auto. }
          left; apply AxiomII; split; auto. }
    - apply Ha in H5. destruct H5 as []; auto.
    - rewrite <-H5 in Hb; auto.
    - rewrite <-H5 in Hc; auto. }
  split; auto; split; auto. apply NNPP; intro.
  assert ((∀ M, M ∈ ℝ -> (∃ x, x ∈ ［a, b］/\ M < f[x]))
    \/ (∀ M, M ∈ ℝ -> (∃ x, x ∈ ［a, b］/\ f[x] < -M))).
  { apply NNPP; intro. apply notandor in H3 as [].
    assert (∃ M, M ∈ ℝ /\ ~ (∃ x, x ∈ ［a, b］/\ M < f[x])).
    { apply NNPP; intro. elim H3. intros. apply NNPP; intro.
      elim H5. exists M. split; auto. }
    assert (∃ M, M ∈ ℝ /\ ~ (∃ x, x ∈［a, b］/\ f[x] < -M)).
    { apply NNPP; intro. elim H4. intros. apply NNPP; intro.
      elim H6. exists M; split; auto. }
    destruct H5 as [M1[]], H6 as [M2[]].
    assert (∀ x, x ∈［a, b］-> f[x] ≤ M1).
    { intros. assert (f[x] ∈ ℝ).
      { apply Hq,(@ Property_ran x),Property_Value; auto. }
      generalize H9; apply or_to_imply.
      assert (∀ x, ~ (x ∈［a, b］/\ M1 < f[x])).
      { apply not_ex_all_not. auto. }
      pose proof (H11 x). apply notandor in H12. destruct H12 as [H12|H12];
      auto. right. apply RNot_Lt_Ge in H12; auto. }
    assert (∀ x, x ∈［a, b］ -> -M2 ≤ f[x]).
    { intros. assert (f[x] ∈ ℝ).
      { apply Hq,(@ Property_ran x),Property_Value; auto. }
      generalize H10; apply or_to_imply.
      assert (∀ x, ~ (x ∈［a, b］/\ f[x] < -M2)).
      { apply not_ex_all_not; auto. }
      pose proof (H12 x). apply notandor in H13. destruct H13 as [H13|H13];
      auto. apply RNot_Lt_Ge in H13; auto with real. }
    assert (∃ M, M ∈ ℝ /\ ｜M1｜< M /\ ｜(-M2)｜< M) as [M[H11[]]].
    { destruct (Leq_P4 ｜M1｜ ｜(-M2)｜) as [H11|H11]; auto with real.
      - exists (｜(-M2)｜ + 1); split; auto with real.
        assert (｜(-M2)｜ < ｜(-M2)｜ + 1).
        { assert (｜(-M2)｜ + 0 < ｜(-M2)｜ + 1).
          { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
          rewrite Plus_P1 in H12; auto with real. }
        split; auto. apply (Order_Co2 _ ｜(-M2)｜ _); auto with real.
      - exists (｜M1｜ + 1); split; auto with real.
        assert (｜(M1)｜ < ｜(M1)｜ + 1).
        { assert (｜(M1)｜ + 0 < ｜(M1)｜ + 1).
          { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
          rewrite Plus_P1 in H12; auto with real. }
        split; auto. apply (Order_Co2 _ ｜(M1)｜ _); auto with real. }
    assert (0 < M).
    { apply (Order_Co2 _ ｜M1｜ _); auto with real.
      right; split; auto. apply Abs_P1; auto. }
    apply H2. exists M; split; auto; split; auto. intros.
    assert (f[x] ∈ ℝ).
    { apply Hq,(@ Property_ran x),Property_Value; auto. }
    destruct (Leq_P4 f[x] 0); auto with real.
    - assert (｜(f[x])｜ = -f[x]). { apply le_zero_Abs; auto. }
      assert (-M ≤ f[x] <-> - f[x] ≤ M).
      { split; intros.
        - apply (OrderPM_Co8b _ _ (-(1))) in H19; auto with real.
          rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3,Minus_P4
          in H19; auto with real.
        - apply (OrderPM_Co8b _ _ (-(1))) in H19; auto with real.
          rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3,Minus_P4
          in H19; auto with real. }
      rewrite H18. apply H19. apply H10 in H15.
      assert (-M2 ≤ 0). { apply (Leq_P3 _ f[x] _); auto with real. }
      rewrite le_zero_Abs,Minus_P4 in H13; auto with real.
      assert (-M < -M2).
      { apply (OrderPM_Co8a _ _ (-(1))) in H13; auto with real.
        rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3 in H13;
        auto with real. }
      apply (Order_Co2 _ (-M2) _); auto with real.
    - assert (｜(f[x])｜ = f[x]). { apply me_zero_Abs; auto. }
      rewrite H18. apply H9 in H15.
      assert (0 ≤ M1). { apply (Leq_P3 _ f[x] _); auto with real. }
      rewrite me_zero_Abs in H12; auto. apply (Order_Co2 _ M1 _); auto. }
  destruct (AxiomIX) as [c[H4]]. destruct H3 as [H3|H3].
  - set (F:= \{\ λ x y, x ∈ ℕ /\ y ∈ ℝ /\
      y = c[\{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ x < f[xn]\}] \}\).
    assert (Function F).
    { split; intros.
      - unfold Relation; intros. apply AxiomII in H6 as [H6[x[y[]]]].
        exists x,y; auto.
      - apply AxiomII in H6 as [H6[x1[y1[H8[H9[H10]]]]]],
        H7 as [H7[x2[y2[H12[H13[H14]]]]]]. apply MKT49b in H6 as [], H7 as [_].
        apply MKT55 in H8 as [], H12 as []; auto.
        rewrite <-H8 in H11; rewrite <-H12 in H15. rewrite H17,H18,H15; auto. }
    assert (∀ n, n ∈ ℕ -> \{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ n < f[xn]\} ≠ Φ).
    { intros. apply N_Subset_R in H7 as H8. apply H3 in H8 as [xn[H8]].
      New H8. apply AxiomII in H10 as [_[H10[]]].
      apply NEexE. exists xn. apply AxiomII; split; eauto. }
    assert (∀ n, n ∈ ℕ -> \{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ n < f[xn]\} ⊂ ℝ).
    { unfold Included; intros. apply AxiomII in H9; tauto. }
    assert (∀ n, n ∈ ℕ
      -> Ensemble \{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ n < f[xn]\}).
    { intros. apply H8 in H9. apply MKT33 in H9; auto. apply Ensemble_R. }
    assert (∀ n, n ∈ ℕ -> c[\{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ n < f[xn] \}]
      ∈ \{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ n < f[xn]\}).
    { intros. red in H4. apply H4. rewrite H5. apply MKT4'; split; auto.
      apply AxiomII; split; auto. intro. apply MKT41 in H11; auto.
      apply H7 in H10; auto. }
    assert (Seq F).
    { split; auto; split; intros.
      - apply AxiomI; split; intros.
        + apply AxiomII in H11 as [H11[y]].
          apply AxiomII' in H12 as [H12[]]; auto.
        + apply AxiomII; split; eauto.
          exists (c[\{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ z < f[xn]\}]).
          apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
          apply H8 in H11 as H12; apply H10 in H11 as H13; auto.
      - unfold Included; intros. apply AxiomII in H11 as [_[x]].
        apply AxiomII' in H11; tauto. }
    assert (∀ n, n ∈ ℕ -> F[n] ∈［a, b］/\ n < f[F[n]]).
    { intros. assert ([n,F[n]] ∈ F).
      { destruct H11 as [_[H11]]. apply Property_Value; auto.
        rewrite H11; auto. }
      apply H10 in H12 as H14. apply AxiomII' in H13 as [_[_[H13]]].
      rewrite <-H15 in H14. apply AxiomII in H14 as [_[_[H14]]]; auto. }
    assert (BoundedSeq F).
    { split; auto. assert (∃ M, M ∈ ℝ /\ ｜a｜< M /\ ｜b｜< M) as [M[H13[]]].
      { destruct (Leq_P4 ｜a｜ ｜b｜) as [H13|H13]; auto with real.
        - exists (｜b｜ + 1); split; auto with real.
          assert (｜b｜ < ｜b｜ + 1).
          { assert (｜b｜ + 0 < ｜b｜ + 1).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
            rewrite Plus_P1 in H14; auto with real. }
          split; auto. apply (Order_Co2 _ ｜b｜ _); auto with real.
        - exists (｜a｜ + 1); split; auto with real.
          assert (｜a｜ < ｜a｜ + 1).
          { assert (｜a｜ + 0 < ｜a｜ + 1).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
            rewrite Plus_P1 in H14; auto with real. }
          split; auto. apply (Order_Co2 _ ｜a｜ _); auto with real. }
      exists M; split; auto. intros.
      assert (F[n] ∈ ℝ).
      { destruct H11 as [_[]]. apply H17,(@ Property_ran n),Property_Value;
        auto. rewrite H11; auto. }
      apply H12 in H16 as H18; destruct H18 as [].
      apply AxiomII in H18 as [_[_[H18]]]. 
      destruct (Leq_P4 F[n] 0) as [H21|H21]; auto with real.
      - assert (｜(F[n])｜ = -F[n]). { apply le_zero_Abs; auto. }
        assert (- F[n] ≤ M <-> -M ≤ F[n]).
        { split; intro.
          - apply (OrderPM_Co8b _ _ (-(1))) in H23; auto with real.
            rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3,Minus_P4
            in H23; auto with real.
          - apply (OrderPM_Co8b _ _ (-(1))) in H23; auto with real.
            rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3,Minus_P4
            in H23; auto with real. }
        assert (｜a｜ = -a).
        { assert (a ≤ 0). { apply (Leq_P3 _ F[n] _); auto with real. }
          apply le_zero_Abs; auto. }
        rewrite H24 in H14. apply (OrderPM_Co8a _ _ (-(1))) in H14;
        auto with real. rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3,
        Minus_P4 in H14; auto with real. destruct H14.
        rewrite H22; apply H23. apply (Leq_P3 _ a _); auto with real.
      - assert (｜(F[n])｜ = F[n]). { apply me_zero_Abs; auto. }
        assert (｜b｜ = b).
        { assert (0 ≤ b). { apply (Leq_P3 _ F[n] _); auto with real. }
          apply me_zero_Abs; auto. }
        rewrite H23 in H15. destruct H15. rewrite H22.
        apply (Leq_P3 _ b _); auto. }
    apply Theorem2_10 in H13 as H14. destruct H14 as [p[]].
    red in H14. destruct H14 as [H14[H16[k[H17[H18[H19]]]]]].
    destruct H14 as [_[]],H17 as [],H15 as [ξ[]].
    set (fp:= \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[p[n]] \}\).
    assert (a ≤ ξ /\ ξ ≤ b) as [].
    { split.
      - apply Corollary2_5a with (x:= p); auto. exists 1; split; auto with real.
        intros. assert (k[n] ∈ ℕ).
        { apply H19,(@ Property_ran n),Property_Value; auto; rewrite H18; auto. }
        rewrite H20; auto. apply H12 in H26 as H27; destruct H27 as [].
        apply AxiomII in H27 as [_[_[H27]]]; auto.
      - apply Corollary2_5b with (x:= p); auto. exists 1; split; auto with real.
        intros. assert (k[n] ∈ ℕ).
        { apply H19,(@ Property_ran n),Property_Value; auto; rewrite H18; auto. }
        rewrite H20; auto. apply H12 in H26 as H27; destruct H27 as [].
        apply AxiomII in H27 as [_[_[H27]]]; auto. }
    assert (Limit_Seq fp f[ξ]).
    { assert ((ξ ∈ ］a, b［) \/ ξ = a \/ ξ = b).
      { destruct (classic (ξ = a)); auto. destruct (classic (ξ = b)); auto.
        left; apply AxiomII; repeat split; eauto. }
      destruct H16 as [H16[]],H26 as [H26|[H26|H26]].
      - apply Ha in H26 as []. apply (Theorem3_8' f ξ f[ξ]); auto.
        unfold Included; intros. apply H1. apply AxiomII in H30 as [H30[n]].
        assert (n ∈ ℕ). { apply Property_dom in H31. rewrite H27 in H31; auto. }
        assert (k[n] ∈ ℕ).
        { apply H19,(@ Property_ran n),Property_Value; auto;
          rewrite H18; auto. }
        apply Property_Fun in H31; auto. rewrite H20 in H31; auto.
        rewrite H31. apply H12; auto.
      - rewrite H26 in *. apply (Corollary3_8a' f a f[a]); auto.
        + do 3 (split; auto). exists δ1'; auto.
        + unfold Included; intros. apply H1. apply AxiomII in H29 as [H29[n]].
          assert (n ∈ ℕ).
          { apply Property_dom in H30. rewrite H27 in H30; auto. }
          assert (k[n] ∈ ℕ).
          { apply H19,(@ Property_ran n),Property_Value; auto.
            rewrite H18; auto. }
          apply Property_Fun in H30; auto. rewrite H20 in H30; auto.
          rewrite H30. apply H12; auto.
        + intros. assert (k[n] ∈ ℕ).
          { apply H19,(@ Property_ran n),Property_Value; auto.
            rewrite H18; auto. }
          assert (F[k[n]] ∈ ［a, b］). { apply H12; auto. }
          rewrite H20; auto. apply AxiomII in H31; tauto. 
      - rewrite H26 in *. apply (Corollary3_8b' f b f[b]); auto.
        + do 3 (split; auto). exists δ2'; auto.
        + unfold Included; intros. apply H1. apply AxiomII in H29 as [H29[n]].
          assert (n ∈ ℕ).
          { apply Property_dom in H30. rewrite H27 in H30; auto. }
          assert (k[n] ∈ ℕ).
          { apply H19,(@ Property_ran n),Property_Value; auto.
            rewrite H18; auto. }
          apply Property_Fun in H30; auto. rewrite H20 in H30; auto.
          rewrite H30. apply H12; auto.
        + intros. assert (k[n] ∈ ℕ).
          { apply H19,(@ Property_ran n),Property_Value; auto.
            rewrite H18; auto. }
          assert (F[k[n]] ∈［a, b］). { apply H12; auto. }
          rewrite H20; auto. apply AxiomII in H31; tauto. }
    assert (∀ n, n ∈ ℕ -> n < f[p[n]]).
    { intros. assert (k[n] ∈ ℕ).
      { apply H19,(@ Property_ran n),Property_Value; auto; rewrite H18; auto. }
      assert (n ≤ k[n]).
      { apply K_Leq_Fk ; auto. rewrite H18; auto. split; auto. }
      assert (f[F[k[n]]] ∈ ℝ).
      { apply Hq,(@ Property_ran F[k[n]]),Property_Value; auto; rewrite Hp.
        apply H21,(@ Property_ran k[n]),Property_Value; auto; rewrite H14; auto. }
      rewrite H20; auto. apply (Order_Co2 _ k[n] _); auto with real.
      right; split; auto. apply H12; auto. }
    assert (f[ξ] ∈ ℝ).
    { apply Hq,(@ Property_ran ξ),Property_Value; auto; rewrite Hp; auto. }
    assert (Conv_Seq fp). { red. exists f[ξ]; auto. }
    destruct H26 as []. apply Theorem2_3 in H29 as [M[H29[H31]]]; auto.
    assert (∃ A, A ∈ ℕ /\ M < A).
    { assert (∃ A, A ∈ ℕ /\ M < A · 1). { apply Archimedes; auto with real. }
      destruct H33 as [A[]]. rewrite Mult_P1 in H34; auto with real.
      exists A; auto. }
    destruct H33 as [A[]]. apply H27 in H33 as H35.
    assert (f[p[A]] ∈ ℝ).
    { destruct H16 as [H16[]]. apply Hq,(@ Property_ran p[A]),Property_Value;
      auto; rewrite Hp. apply H37,(@ Property_ran A),Property_Value; auto;
      rewrite H36; auto. }
    assert (f[p[A]] = fp[A]).
    { destruct H26 as [H26[]]. apply Property_Fun; auto.
      apply AxiomII'; repeat split; auto. apply MKT49a; eauto. }
    assert (M < f[p[A]]). { apply (RTrans_Lt _ A _); auto with real. }
    apply H32 in H33 as H39. rewrite <-H37 in H39. destruct H31.
    apply Abs_P4 in H39 as []; auto. destruct H38. elim H42. apply Leq_P2; auto.
  - set (F:= \{\ λ x y, x ∈ ℕ /\ y ∈ ℝ
      /\ y = c[\{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ f[xn] < -x \}] \}\).
    assert (Function F).
    { split; intros.
      - unfold Relation; intros. apply AxiomII in H6 as [_[x[y[]]]].
        exists x, y; auto.
      - apply AxiomII' in H6 as [_[H6[H8]]], H7 as [_[H7[H10]]].
        rewrite H11; auto. }
    assert (∀ n, n ∈ ℕ -> \{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ f[xn] < -n \} ≠ Φ).
    { intros. apply N_Subset_R in H7. apply H3 in H7 as [xn[]]. New H7.
      apply AxiomII in H7 as [_[H7[_]]]. apply NEexE. exists xn.
      apply AxiomII; split; eauto. }
    assert (∀ n, n ∈ ℕ
      -> \{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ f[xn] < -n \} ⊂ ℝ).
    { intros. unfold Included; intros. apply AxiomII in H9 as [_[H9]]; auto. }
    assert (∀ n, n ∈ ℕ 
      -> Ensemble \{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ f[xn] < -n \}).
    { intros. apply H8 in H9. apply MKT33 in H9; auto. apply Ensemble_R. }
    assert (∀ n, n ∈ ℕ -> c[\{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ f[xn] < -n \}] 
      ∈ \{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ f[xn] < -n \}).
    { intros. apply H7 in H10 as H11; apply H9 in H10 as H12. apply H4.
      rewrite H5. apply MKT4'; split; auto. apply AxiomII; split; auto.
      intro. apply MKT41 in H13; auto. }
    assert (Seq F).
    { split; auto; split.
      - apply AxiomI; split; intros.
        + apply AxiomII in H11 as [_[y]]. apply AxiomII' in H11 as [_[]]; auto.
        + apply AxiomII; split; eauto.
          exists (c[\{ λ xn, xn ∈ ℝ /\ xn ∈［a, b］/\ f[xn] < -z \}]).
          apply AxiomII'; repeat split; auto. apply MKT49a; eauto.
          apply H8 in H11 as H12; apply H10 in H11 as H13; auto.
      - unfold Included; intros. apply AxiomII in H11 as [_[x]].
        apply AxiomII' in H11; tauto. }
    assert (∀ n, n ∈ ℕ -> F[n] ∈［a, b］/\ f[F[n]] < -n).
    { intros. assert ([n,F[n]] ∈ F).
      { destruct H11 as [_[H11]]. apply Property_Value; auto.
        rewrite H11; auto. }
      apply H10 in H12 as H14. apply AxiomII' in H13 as [_[_[H13]]].
      rewrite <-H15 in H14. apply AxiomII in H14 as [_[_[H14]]]; auto. }
    assert (BoundedSeq F).
    { split; auto. assert (∃ M, M ∈ ℝ /\ ｜a｜< M /\ ｜b｜< M) as [M[H13[]]].
      { destruct (Leq_P4 ｜a｜ ｜b｜) as [H13|H13]; auto with real.
        - exists (｜b｜ + 1); split; auto with real.
          assert (｜b｜ < ｜b｜ + 1).
          { assert (｜b｜ + 0 < ｜b｜ + 1).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
            rewrite Plus_P1 in H14; auto with real. }
          split; auto. apply (Order_Co2 _ ｜b｜ _); auto with real.
        - exists (｜a｜ + 1); split; auto with real.
          assert (｜a｜ < ｜a｜ + 1).
          { assert (｜a｜ + 0 < ｜a｜ + 1).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
            rewrite Plus_P1 in H14; auto with real. }
          split; auto. apply (Order_Co2 _ ｜a｜ _); auto with real. }
      exists M; split; auto. intros.
      assert (F[n] ∈ ℝ).
      { destruct H11 as [_[]]. apply H17,(@ Property_ran n),Property_Value;
        auto. rewrite H11; auto. }
      apply H12 in H16 as H18; destruct H18 as [].
      apply AxiomII in H18 as [_[_[H18]]]. 
      destruct (Leq_P4 F[n] 0) as [H21|H21]; auto with real.
      - assert (｜(F[n])｜ = -F[n]). { apply le_zero_Abs; auto. }
        assert (- F[n] ≤ M <-> -M ≤ F[n]).
        { split; intro.
          - apply (OrderPM_Co8b _ _ (-(1))) in H23; auto with real.
            rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3,Minus_P4
            in H23; auto with real.
          - apply (OrderPM_Co8b _ _ (-(1))) in H23; auto with real.
            rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3,Minus_P4
            in H23; auto with real. }
        assert (｜a｜ = -a).
        { assert (a ≤ 0). { apply (Leq_P3 _ F[n] _); auto with real. }
          apply le_zero_Abs; auto. }
        rewrite H24 in H14. apply (OrderPM_Co8a _ _ (-(1))) in H14;
        auto with real. rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3,
        Minus_P4 in H14; auto with real. destruct H14.
        rewrite H22; apply H23. apply (Leq_P3 _ a _); auto with real.
      - assert (｜(F[n])｜ = F[n]). { apply me_zero_Abs; auto. }
        assert (｜b｜ = b).
        { assert (0 ≤ b). { apply (Leq_P3 _ F[n] _); auto with real. }
          apply me_zero_Abs; auto. }
        rewrite H23 in H15. destruct H15. rewrite H22.
        apply (Leq_P3 _ b _); auto. }
    apply Theorem2_10 in H13 as H14. destruct H14 as [p[]].
    red in H14. destruct H14 as [H14[H16[k[H17[H18[H19]]]]]].
    destruct H14 as [_[]],H17 as [],H15 as [ξ[]].
    set (fp:= \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[p[n]] \}\).
    assert (a ≤ ξ /\ ξ ≤ b) as [].
    { split.
      - apply Corollary2_5a with (x:= p); auto. exists 1; split; auto with real.
        intros. assert (k[n] ∈ ℕ).
        { apply H19,(@ Property_ran n),Property_Value; auto; rewrite H18; auto. }
        rewrite H20; auto. apply H12 in H26 as H27; destruct H27 as [].
        apply AxiomII in H27 as [_[_[H27]]]; auto.
      - apply Corollary2_5b with (x:= p); auto. exists 1; split; auto with real.
        intros. assert (k[n] ∈ ℕ).
        { apply H19,(@ Property_ran n),Property_Value; auto; rewrite H18; auto. }
        rewrite H20; auto. apply H12 in H26 as H27; destruct H27 as [].
        apply AxiomII in H27 as [_[_[H27]]]; auto. }
    assert (Limit_Seq fp f[ξ]).
    { assert (ξ ∈ ］a, b［ \/ ξ = a \/ ξ = b).
      { destruct (classic (ξ = a)); auto. destruct (classic (ξ = b)); auto.
        left; apply AxiomII; repeat split; eauto. }
      destruct H16 as [H16[]]. destruct H26 as [H26|[H26|H26]].
      - apply Ha in H26 as []. apply (Theorem3_8' f ξ f[ξ]); auto.
        unfold Included; intros. apply AxiomII in H30 as [H30[n]].
        assert (n ∈ ℕ). { apply Property_dom in H31. rewrite H27 in H31; auto. }
        assert (k[n] ∈ ℕ).
        { apply H19,(@ Property_ran n),Property_Value; auto; rewrite H18; auto. }
        apply Property_Fun in H31; auto. rewrite H20 in H31; auto.
        rewrite H31. apply H1,H12; auto.
      - rewrite H26 in *. apply (Corollary3_8a' f a f[a]); auto.
        + do 3 (split; auto). exists δ1'; auto.
        + unfold Included; intros. apply AxiomII in H29 as [_[n]].
          assert (n ∈ ℕ).
          { apply Property_dom in H29; rewrite H27 in H29; auto. }
          assert (k[n] ∈ ℕ).
          { apply H19,(@ Property_ran n),Property_Value; auto;
            rewrite H18; auto. }
          apply Property_Fun in H29; auto. rewrite H20 in H29; auto.
          rewrite H29. apply H1,H12; auto.
        + intros. assert (k[n] ∈ ℕ).
          { apply H19,(@ Property_ran n),Property_Value; auto;
            rewrite H18; auto. }
          apply H12 in H30 as H31. destruct H31 as [H31 _].
          apply AxiomII in H31 as [_[_[H31]]]. rewrite H20; auto.
      - rewrite H26 in *. apply (Corollary3_8b' f b f[b]); auto.
        + do 3 (split; auto). exists δ2'; auto.
        + unfold Included; intros. apply AxiomII in H29 as [_[n]].
          assert (n ∈ ℕ).
          { apply Property_dom in H29. rewrite H27 in H29; auto. }
          assert (k[n] ∈ ℕ).
          { apply H19,(@ Property_ran n),Property_Value; auto;
            rewrite H18; auto. }
          apply Property_Fun in H29; auto. rewrite H20 in H29; auto.
          rewrite H29. apply H1,H12; auto.
        + intros. assert (k[n] ∈ ℕ).
          { apply H19,(@ Property_ran n),Property_Value; auto;
            rewrite H18; auto. }
          apply H12 in H30 as H31. destruct H31 as [H31 _].
          apply AxiomII in H31 as [_[_[H31]]]. rewrite H20; auto. }
    assert (∀ n, n ∈ ℕ -> f[p[n]] < -n).
    { intros. assert (k[n] ∈ ℕ).
      { apply H19,(@ Property_ran n),Property_Value; auto; rewrite H18; auto. }
      assert (n ≤ k[n]).
      { apply K_Leq_Fk ; auto. rewrite H18; auto. split; auto. }
      assert (-k[n] ≤ -n).
      { apply (OrderPM_Co8b _ _ (-(1))) in H29; auto with real.
        rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3 in H29;
        auto with real. }
      assert (f[p[n]] ∈ ℝ).
      { destruct H16 as [H16[]]. apply Hq,(@ Property_ran p[n]),Property_Value;
        auto; rewrite Hp. apply H32,(@ Property_ran n),Property_Value; auto;
        rewrite H31; auto. }
      apply (Order_Co2 _ (-k[n]) _); auto with real.
      left; split; auto. rewrite H20; auto. apply H12; auto. }
    assert (f[ξ] ∈ ℝ).
    { apply Hq,(@ Property_ran ξ),Property_Value; auto; rewrite Hp; auto. }
    assert (Conv_Seq fp). { exists f[ξ]; auto. }
    destruct H26. apply Theorem2_3 in H29 as [M[H29[]]]; auto.
    assert (∃ A, A ∈ ℕ /\ M < A).
    { assert (∃ A, A ∈ ℕ /\ M < A · 1). { apply Archimedes; auto with real. }
      destruct H33 as [A[]]. rewrite Mult_P1 in H34; auto with real.
      exists A; auto. }
    destruct H33 as [A[]]. apply H27 in H33 as H35.
    assert (-A < -M).
    { apply (OrderPM_Co8a _ _ (-(1))) in H34; auto with real.
      rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3 in H34;
      auto with real. }
    assert (f[p[A]] ∈ ℝ).
    { destruct H16 as [H16[]]. apply Hq,(@ Property_ran p[A]),Property_Value;
      auto; rewrite Hp. apply H38,(@ Property_ran A),Property_Value; auto;
      rewrite H37; auto. }
    assert (f[p[A]] < -M). { apply (RTrans_Lt _ (-A) _); auto with real. }
    assert (f[p[A]] = fp[A]).
    { destruct H26 as [H26[]]. apply Property_Fun; auto.
      apply AxiomII'; split; auto. apply MKT49a; eauto. }
    New H37; rewrite H39 in H40. destruct H31.
    apply H32 in H33 as H42. apply Abs_P4 in H42 as [H42 _]; auto.
    rewrite <-H39 in H42. destruct H38. elim H43. apply Leq_P2; auto with real.
Qed.

(* 区间D上的最大值 *)
Definition DMaxValue f D m := Function f -> D ⊂ dom(f) -> m ∈ ℝ
  -> (∀ x, x ∈ D -> f[x] ≤ m) /\ (∃ x0, x0 ∈ D /\ f[x0] = m).

(* 区间D上的最小值 *)
Definition DMinValue f D m := Function f -> D ⊂ dom(f) -> m ∈ ℝ
  -> (∀ x, x ∈ D -> m ≤ f[x]) /\ (∃ x0, x0 ∈ D /\ f[x0] = m).

(* 最大、最小值定理 *)
Theorem Theorem4_6 : ∀ f a b, a < b -> Continuous_Close f a b
  -> ((∃ m, m ∈ ℝ /\ DMaxValue f (［a, b］) m)
    /\ (∃ m, m ∈ ℝ /\ DMinValue f (［a, b］) m)).
Proof.
  pose proof OrderPM_Co9 as Ha. pose proof Ha as [Hb Hc].
  assert (1 + 1 ∈ ℝ) as Hd. { auto with real. }
  assert (0 < 1 + 1) as He.
  { assert (0 + 0 < 1 + 1).
    { apply OrderPM_Co4; auto with real. }
    rewrite Plus_P1 in H; auto with real. }
  assert (0 < (1 + 1)⁻) as Hf. { apply OrderPM_Co10; auto. }
  assert (1 + 1 ∈ (ℝ ~ [0])) as Hg.
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto.
    intro. apply MKT41 in H; eauto with real. destruct He; auto. }
  apply Mult_inv1 in Hg as Hh; apply MKT4' in Hh as [Hh _].
  assert ((-(1)) < 0) as Hi. { apply OrderPM_Co2a; auto with real. }
  pose proof Hi as [Hj _]. intros. apply Lemma4_6 in H0 as H1.
  destruct H0 as [H0[]],H1 as [_[H1[M[H4[H5]]]]].
  set (F:= \{ λ y, y ∈ ℝ /\ ∃ x, x ∈［a, b］/\ [x, y] ∈ f \}). 
  destruct H2,H7 as [H7[H8[H9]]],H3,H11 as [H11[H12[H13]]],H11 as [H11[]].
  assert (F ≠ Φ).
  { apply NEexE. exists f[a]. apply AxiomII; split; eauto; split; auto.
    exists a; split.
    - destruct H. apply AxiomII; repeat split; eauto. apply Leq_P1; auto.
    - apply Property_Value; auto. }
  assert (F ⊂ ℝ).
  { unfold Included; intros. apply AxiomII in H18; tauto. }
  apply Sup_Inf_Principle in H18 as H19; auto. destruct H19 as[]; auto.
  assert (∀ x, x ∈［a, b］-> -M ≤ f[x] /\ f[x] ≤ M).
  { intros. apply H6 in H21 as H22. apply AxiomII in H21 as [_[H21 _]].
    assert (f[x] ∈ ℝ).
    { apply H16,(@ Property_ran x),Property_Value; auto; rewrite H15; auto. }
    destruct H5. apply Abs_P4 in H22; auto. }
  assert (exists ! η, Sup F η).
  { apply H19. exists M. repeat split; auto; intros z H22.
    apply AxiomII in H22 as [_[H22[x[]]]]. apply Property_Fun in H24; auto.
    rewrite H24. apply H21; auto. }
  assert (exists ! ξ, Inf F ξ).
  { apply H20. exists (-M). repeat split; auto with real; intros z H23.
    apply AxiomII in H23 as [_[H23[x[]]]]. apply Property_Fun in H25; auto.
    rewrite H25. apply H21; auto. }
  destruct H22 as [η[]],H23 as [ξ[]]. split.
  - destruct H22 as []. destruct H22 as [_[H22]]. exists η; split; auto. split; intros.
    assert (f[x] ∈ ℝ).
    { apply H16,(@ Property_ran x),Property_Value; auto; rewrite H15; auto. }
    + apply H27. apply AxiomII; repeat split; eauto.
      exists x; split; auto. apply Property_Value; auto.
    + apply NNPP; intro.
      assert (∀ x, ~(x ∈［a, b］/\ f[x] = η)). { apply not_ex_all_not; auto. }
      assert (∀ x, x ∈［a, b］-> f[x] < η).
      { intros. pose proof (H32 x). apply notandor in H34.
        assert (f[x] ∈ ℝ).
        { apply H16,(@ Property_ran x),Property_Value; auto; rewrite H15; auto. }
        assert (f[x] ≠ η). { destruct H34; auto. }
        destruct (Order_Co1 f[x] η) as [H37|[H37|H37]]; auto.
        * assert (f[x] ≤ η).
          { apply H27. apply AxiomII; repeat split; eauto.
            exists x; split; auto; apply Property_Value; auto. }
          destruct H37. elim H39. apply Leq_P2; auto.
        * contradiction. }
      set (g:= \{\ λ x y, x ∈ ℝ /\ y ∈ ℝ /\ x ∈［a, b］/\ y = (η - f[x])⁻ \}\).
      assert (Function g).
      { split; intros.
        * unfold Relation; intros. apply AxiomII in H34 as [_[x[y[]]]].
          exists x, y; auto.
        * apply AxiomII in H34 as [H34[x1[y1[H36[H37[H38[H39]]]]]]],
          H35 as [H35[x2[y2[H41[H42[H43[H44]]]]]]].
          apply MKT49b in H34 as [],H35 as [_ ].
          apply MKT55 in H36 as [],H41 as []; auto. rewrite <-H36 in H40;
          rewrite <-H41 in H45. rewrite H47,H48,H45; auto. }
      assert (［a, b］⊂ dom(g)).
      { red; intros. New H35. apply AxiomII in H36 as [H36[H37[H38]]].
        apply AxiomII; split; auto. exists ((η - f[z])⁻).
        assert (f[z] ∈ ℝ).
        { apply H16,(@ Property_ran z),Property_Value; auto;
          rewrite H15; auto. }
        assert (η - f [z] ∈ (ℝ ~ [0])).
        { assert (η - f [z] ∈ ℝ); auto with real.
          apply MKT4'; split; auto. apply AxiomII; split; eauto.
          intro. apply MKT41 in H42; eauto with real. apply H33 in H35.
          apply (OrderPM_Co1 _ _ (-f[z])) in H35; auto with real.
          rewrite Minus_P1 in H35; auto. destruct H35. elim H43; auto. }
        apply Mult_inv1 in H41; apply MKT4' in H41 as [H41 _].
        apply AxiomII'. repeat split; auto. apply MKT49a; eauto. }
      assert (FunctionR_R g) as Hz.
      { split;[auto|split].
        * apply AxiomI; split; intros.
          -- apply AxiomII in H36 as [_[y]]. apply AxiomII' in H36; tauto.
          -- apply H35. apply AxiomII; repeat split; eauto. admit. admit.
        * unfold Included; intros. apply AxiomII in H36 as [_[x]].
          apply AxiomII' in H36; tauto. }
      assert (∀ x, x ∈［a, b］-> η - f[x] ∈ (ℝ ~ [0])).
      { intros z H36. New H36. apply AxiomII in H37 as [_[H37 _]].
        assert (f[z] ∈ ℝ).
        { apply H16,(@ Property_ran z),Property_Value; auto. }
        assert (η - f[z] ∈ ℝ); auto with real.
        apply MKT4'; split; auto. apply AxiomII; split; eauto.
        intro. apply MKT41 in H40; eauto with real. apply H33 in H36.
        apply (OrderPM_Co1 _ _ (-f[z])) in H36; auto with real.
        rewrite Minus_P1 in H36; auto. destruct H36. elim H41; auto. }
      assert (∀ x, x ∈［a, b］-> (η - f[x])⁻ = g[x]).
      { intros z H37. apply Property_Fun; auto. apply H36 in H37 as H38.
        apply Mult_inv1 in H38; apply MKT4' in H38 as [H38 _].
        New H37. apply AxiomII in H39 as [_[H39[H40]]].
        apply AxiomII'; repeat split; auto with real. apply MKT49a; eauto. }
      assert (Continuous_Close g a b).
      { split; [|split].
        * red; intros. assert (x ∈ dom(g)).
          { apply H35. apply AxiomII in H38 as [H38[H39[H40]]].
            destruct H40,H41. apply AxiomII; auto. }
          assert (g[x] ∈ ℝ).
          { destruct Hz as [Hz[]]. apply H41,(@ Property_ran x),
            Property_Value; auto. }
          New H38. apply AxiomII in H41 as [_[H41[H42]]].
          do 4 (split; auto). pose proof (H0 _ H38) as [].
          red in H45. destruct H45 as [_[_[H45[δ'[H46[H47[H48]]]]]]].
          assert (0 < x - a).
          { apply (OrderPM_Co1 _ _ (-a)) in H42; auto with real.
            rewrite Minus_P1 in H42; auto. }
          assert (0 < b - x).
          { apply (OrderPM_Co1 _ _ (-x)) in H43; auto with real.
            rewrite Minus_P1 in H43; auto. }
          assert (∃ δ0', δ0' ∈ ℝ /\ 0 < δ0' /\ δ0' < x - a /\ δ0' < b - x).
          { destruct (Leq_P4 (x - a) (b - x)) as [H52|H52]; auto with real.
            -- exists ((x - a) / (1 + 1)).
               assert ((x - a) + (x - a) = (x - a) · (1 + 1)).
               { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
               assert ((x - a) < (x - a) + (x - a)).
               { assert ((x - a) + 0 < (x - a) + (x - a)).
                 { apply OrderPM_Co4; auto with real.
                   apply Leq_P1; auto with real. }
                 rewrite Plus_P1 in H54; auto with real. }
               rewrite H53 in H54. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H54;
               auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H54;
               auto with real. split; auto with real.
               split. apply OrderPM_Co5; auto with real. split; auto.
               apply (Order_Co2 _ (x - a) _); auto with real.
            -- exists ((b - x) / (1 + 1)).
               assert ((b - x) + (b - x) = (b - x) · (1 + 1)).
               { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
               assert ((b - x) < (b - x) + (b - x)).
               { assert ((b - x) + 0 < (b - x) + (b - x)).
                 { apply OrderPM_Co4; auto with real.
                   apply Leq_P1; auto with real. }
                 rewrite Plus_P1 in H54; auto with real. }
               rewrite H53 in H54. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H54;
               auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H54;
               auto with real. split; auto with real.
               split. apply OrderPM_Co5; auto with real. split; auto.
               apply (Order_Co2 _ (b - x) _); auto with real. }
          destruct H52 as [δ0'[H53[H54[H55]]]].
          exists δ0'; split; auto; split; auto.
          assert (a < -δ0' + x).
          { apply (OrderPM_Co8a _ _ (-(1))) in H55; auto with real.
            rewrite Mult_P4,<-PlusMult_Co3,Minus_P3,Minus_P4,Plus_P4,
            Mult_P4,<-PlusMult_Co3 in H55; auto with real.
            apply (OrderPM_Co1 _ _ x) in H55; auto with real.
            rewrite <-Plus_P3,(Plus_P4 (-x)),Minus_P1,Plus_P1 in H55;
            auto with real. }
          assert (δ0' + x < b).
          { apply (OrderPM_Co1 _ _ x) in H52; auto with real.
            rewrite <-Plus_P3,(Plus_P4 (-x)),Minus_P1,Plus_P1 in H52;
            auto with real. }
          assert (Uº(x; δ0') ⊂ dom(g)).
          { unfold Included; intros. apply AxiomII in H58 as [H58[H59[H60]]].
            destruct H54,H61. apply Abs_P4 in H61 as []; auto with real.
            apply (Plus_Leq _ _ x) in H61; auto with real.
            rewrite <-Plus_P3,(Plus_P4 (-x)),Minus_P1,Plus_P1 in H61;
            auto with real.
            apply (Plus_Leq _ _ x) in H64; auto with real.
            rewrite <-Plus_P3,(Plus_P4 (-x)),Minus_P1,Plus_P1 in H64;
            auto with real.
            apply H35. apply AxiomII; split; auto; split; auto. split;
            [apply (Order_Co2 _ (- δ0' + x) _); auto with real
            |apply (Order_Co2 _ (δ0' + x) _); auto with real]. }
          split; auto. intros. assert (f[x] < η).
          { apply H33. destruct H42,H43. apply AxiomII; split; eauto. }
          assert (0 < η - f[x]).
          { apply (OrderPM_Co1 _ _ (-f[x])) in H60; auto with real.
            rewrite Minus_P1 in H60; auto with real. }
          assert (0 < (η - f[x]) / (1 + 1)).
          { apply OrderPM_Co5; auto with real. }
          assert ((η - f[x]) / (1 + 1) ∈ ℝ /\ 0 < (η - f[x]) / (1 + 1)).
          { split; auto with real. }
          apply H49 in H63 as [δ0[H63[H64[H65]]]]. pose proof H59 as [].
          assert (0 < ε · (η - f[x]) · ((η - f[x]) / (1 + 1))).
          { apply OrderPM_Co5; auto with real. left; split; auto.
            apply OrderPM_Co5; auto with real. }
          assert (ε · (η - f[x]) · ((η - f[x]) / (1 + 1)) ∈ ℝ
            /\ 0 < ε · (η - f[x]) · ((η - f[x]) / (1 + 1))).
          { split; auto with real. }
          apply H49 in H70 as [δ1[H70[H71[H72]]]].
          assert (δ1 + δ1 = δ1 · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert (δ1 < δ1 + δ1).
          { assert (δ1 + 0 < δ1 + δ1).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
            rewrite Plus_P1 in H75; auto. } rewrite H74 in H75.
          apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H75; auto with real.
          rewrite <-Mult_P3,Divide_P1,Mult_P1 in H75; auto with real.
          assert (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < δ0' /\ δ < δ0 /\ δ < δ1).
          { destruct (Leq_P4 δ0' δ0) as [H76|H76]; auto.
            -- destruct (Leq_P4 δ0' δ1) as [H77|H77]; auto.
               ++ exists (δ0' / (1 + 1)).
                  assert (δ0' + δ0' = δ0' · (1 + 1)).
                  { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
                  assert (δ0' < δ0' + δ0').
                  { assert (δ0' + 0 < δ0' + δ0').
                    { apply OrderPM_Co4; auto with real.
                      apply Leq_P1; auto with real. }
                    rewrite Plus_P1 in H79; auto. }
                  rewrite H78 in H79.
                  apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H79; auto with real.
                  rewrite <-Mult_P3,Divide_P1,Mult_P1 in H79; auto with real.
                  split; auto with real. split. apply OrderPM_Co5; auto.
                  split; auto. split; apply (Order_Co2 _ δ0' _); auto with real.
               ++ exists (δ1 / (1 + 1)).
                  split; auto with real. split. apply OrderPM_Co5; auto.
                  split. apply (Order_Co2 _ δ1 _); auto with real.
                  split; apply (Order_Co2 _ δ1 _); auto with real.
                  left; split; auto. apply (Leq_P3 _ δ0' _); auto.
                  left; split; auto. apply Leq_P1; auto.
            -- destruct (Leq_P4 δ0 δ1) as [H77|H77]; auto.
               ++ exists (δ0 / (1 + 1)).
                  assert (δ0 + δ0 = δ0 · (1 + 1)).
                  { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
                  assert (δ0 < δ0 + δ0).
                  { assert (δ0 + 0 < δ0 + δ0).
                    { apply OrderPM_Co4; auto with real.
                      apply Leq_P1; auto with real. }
                    rewrite Plus_P1 in H79; auto. }
                  rewrite H78 in H79.
                  apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H79; auto with real.
                  rewrite <-Mult_P3,Divide_P1,Mult_P1 in H79; auto with real.
                  split; auto with real. split. apply OrderPM_Co5; auto.
                  split. apply (Order_Co2 _ δ0 _); auto with real.
                  split; auto. apply (Order_Co2 _ δ0 _); auto with real.
               ++ exists (δ1 / (1 + 1)).
                  split; auto with real. split. apply OrderPM_Co5; auto.
                  split. apply (Order_Co2 _ δ1 _); auto with real.
                  left; split; auto. apply (Leq_P3 _ δ0 _); auto.
                  split; auto. apply (Order_Co2 _ δ1 _); auto with real. }
          destruct H76 as [δ[H76[H77[H78[H79]]]]].
          exists δ; do 3 (split; auto). intros. destruct H82 as [].
          assert (-δ0' + x < -δ + x).
          { apply (OrderPM_Co8a _ _ (-(1))) in H78; auto with real.
            rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3 in H78;
            auto with real.
            apply (OrderPM_Co1 _ _ x) in H78; auto with real. }
          assert (δ + x < δ0' + x).
          { apply (OrderPM_Co1 _ _ x) in H78; auto. }
          assert (a < -δ + x).
          { apply (RTrans_Lt _ (-δ0' + x) _); auto with real. }
          assert (δ + x < b).
          { apply (RTrans_Lt _ (δ0' + x) _); auto with real. }
          assert (x0 ∈［a, b］).
          { destruct H77,H83. apply Abs_P4 in H83 as []; auto with real.
            apply (Plus_Leq _ _ x) in H83; auto with real.
            rewrite <-Plus_P3,(Plus_P4 (-x)),Minus_P1,Plus_P1 in H83;
            auto with real.
            apply (Plus_Leq _ _ x) in H90; auto with real.
            rewrite <-Plus_P3,(Plus_P4 (-x)),Minus_P1,Plus_P1 in H90;
            auto with real.
            apply AxiomII; repeat split; eauto.
            -- apply (Order_Co2 _ (-δ + x) _); auto with real.
            -- apply (Order_Co2 _ (δ + x) _); auto with real. }
          New H88. apply AxiomII in H89 as [H89[H90[H91]]].
          assert (x ∈［a, b］).
          { destruct H42,H43; auto. apply AxiomII; repeat split; eauto. }
          assert (f[x0] < η). { apply H33; auto. }
          assert (η - f[x] ∈ ℝ /\ η - f[x0] ∈ ℝ) as [].
          { split; [apply H36 in H93; apply MKT4' in H93 as [H93 _]; auto
            |apply H36 in H88; apply MKT4' in H88 as [H88 _]; auto]. }
          assert (((η - f[x])⁻) ∈ ℝ /\ ((η - f[x0])⁻) ∈ ℝ) as [].
          { split; [apply H36 in H93; apply Mult_inv1 in H93; 
            apply MKT4' in H93 as [H93 _]; auto|apply H36 in H88;
            apply Mult_inv1 in H88; apply MKT4' in H88 as [H88 _]; auto]. }
          assert (f[x0] ∈ ℝ).
          { apply H16,(@ Property_ran x0),Property_Value; auto. }
          assert (0 < η - f[x0]).
          { apply (OrderPM_Co1 _ _ (-f[x0])) in H94; auto with real.
            rewrite Minus_P1 in H94; auto. }
          assert (0 < ((η - f[x0]) · (η - f[x]))).
          { apply (OrderPM_Co7a _ _ (η - f[x])) in H100; auto with real.
            rewrite Mult_P4,PlusMult_Co1 in H100; auto with real. }
          assert ((η - f[x0])⁻ - (η - f [x])⁻
            = (f[x0] - f[x]) / ((η - f[x0]) · (η - f[x]))).
          { assert (1 / (η - f[x0])
              = 1 · (η - f[x]) / ((η - f[x0]) · (η - f[x]))).
            { apply Frac_P1; auto with real. }
            assert ((-(1)) / (η - f[x])
              = (-(1)) · (η - f[x0]) / ((η - f[x]) · (η - f[x0]))).
            { apply Frac_P1; auto with real. }
            rewrite Mult_P4,Mult_P1,(Mult_P4 1),Mult_P1 in H102; auto with real.
            rewrite <-PlusMult_Co3,<-PlusMult_Co3,Minus_P3,Minus_P4,
            (Mult_P4 (η - f[x])) in H103; auto with real.
            assert (-(η - f[x])⁻ = (- η + f[x0]) / ((η - f[x0]) · (η - f[x])));
            auto. clear H103. rewrite H102,H104.
            assert (((η - f [x0]) · (η - f [x])) ∈ (ℝ ~ [0])).
            { apply MKT4'; split; eauto with real.
              apply AxiomII; split; eauto with real. intro.
              apply MKT41 in H103; eauto with real. destruct H101; auto. }
            apply Mult_inv1 in H103; apply MKT4' in H103 as [H103 _].
            rewrite <-Mult_P5; auto with real. apply RMult_Eq; auto with real.
            rewrite Plus_P4,(Plus_P4 (-η)),<-Plus_P3,(Plus_P3 (-η)),
            (Plus_P4 (-η)),Minus_P1,(Plus_P4 0),Plus_P1; auto with real. }
          assert (0 < ｜(x0 - x)｜/\｜(x0 - x)｜ < δ0).
          { split; auto. apply (RTrans_Lt _ δ _); auto with real. }
          assert (0 < ｜(x0 - x)｜/\｜(x0 - x)｜ < δ1).
          { split; auto. apply (RTrans_Lt _ δ _); auto with real. }
          apply H66 in H103 as H105; auto; apply H73 in H104 as H106; auto.
          pose proof H61 as []; pose proof H62 as []; pose proof H100 as []. 
          destruct H105. apply Abs_P4 in H105 as []; auto with real.
          assert ((η - f[x]) / (1 + 1) ≤ η - f[x0]).
          { apply (OrderPM_Co8b _ _ (-(1))) in H114; auto with real.
            rewrite Mult_P4,Mult_P3,<-PlusMult_Co3,Minus_P3,Minus_P4,
            (Mult_P4 (f[x0] - f[x])),<-PlusMult_Co3,Minus_P3,Minus_P4 in H114;
            auto with real.
            assert (-f[x] = (-f[x] -f[x]) / (1 + 1)).
            { apply (RMult_Eq' _ _ (1 + 1)); auto with real.
              rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1, <-Mult_P3,
              (Mult_P4 ((1 + 1)⁻)),Divide_P1,Mult_P1; auto with real. }
            apply (Plus_Leq _ _ (-f[x])) in H114; auto with real.
            rewrite <-Plus_P3,Minus_P1,Plus_P1 in H114; auto with real.
            rewrite H115 in H114. rewrite <-Mult_P5,Plus_P3,
            <-(Plus_P3 (-η)),Minus_P1,Plus_P1,(Plus_P4 (-η)) in H114;
            auto with real.
            assert (η = (η + η) / (1 + 1)).
            { apply (RMult_Eq' _ _ (1 + 1)); auto with real.
              rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1, <-Mult_P3,
              (Mult_P4 ((1 + 1)⁻)),Divide_P1,Mult_P1; auto with real. }
            apply (Plus_Leq _ _ η) in H114; auto with real.
            pattern η at 2 in H114; rewrite H116 in H114.
            rewrite <-Mult_P5,Plus_P3,<-(Plus_P3 (-f[x])),(Plus_P4 (-η)),
            Minus_P1,Plus_P1,(Plus_P4 (-f[x])),(Plus_P4 (-f[x0])) in H114;
            auto with real. }
          apply H37 in H88 as H116; apply H37 in H93 as H117.
          pose proof H101 as [].
          rewrite <-H116,<-H117,H102,Abs_Div; auto with real.
          assert ((｜((η - f[x0]) · (η - f[x]))｜) = ((η - f[x0]) · (η - f[x]))).
          { apply me_zero_Abs; auto with real. }
          assert ((η - f[x0]) · (η - f[x]) ∈ (ℝ ~ [0])).
          { apply MKT4'; split; auto with real. apply AxiomII; split;
            eauto with real. intro. apply MKT41 in H121; eauto with real. }
          apply Mult_inv1 in H121 as H122; apply MKT4' in H122 as [H122 _].
          assert (0 < (((η - f[x0]) · (η - f[x]))⁻)).
          { apply OrderPM_Co10; auto with real. }
          assert (｜(f[x0] - f[x])｜ < ε · ((η - f[x0]) · (η - f[x]))
            -> ｜(f[x0] - f[x])｜ / ((η - f[x0]) · (η - f[x])) < ε).
          { intros. apply (OrderPM_Co7a _ _ ((η - f[x0]) · (η - f[x]))⁻) in H124;
            auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H124;
            auto with real. }
          assert (((η - f[x]) / (1 + 1)) · (ε · (η - f[x])) 
            ≤ (η - f[x0]) · (ε · (η - f[x]))).
          { assert (0 < (ε · (η - f[x]))) as [].
            { apply OrderPM_Co5; auto with real. }
            apply (OrderPM_Co7b _ _ ((ε · (η - f[x])))) in H115;
            auto with real. }
          rewrite H120. apply H124. rewrite Mult_P4 in H106; auto with real.
          rewrite Mult_P3,(Mult_P4 ε),<-Mult_P3; auto with real.
          apply (Order_Co2 _ (((η - f[x]) / (1 + 1)) · (ε · (η - f[x]))) _);
          auto with real.
        * red. assert (a ∈［a, b］).
          { destruct H. apply AxiomII; repeat split; eauto. apply Leq_P1; auto. }
          apply H36 in H38 as H39; apply H37 in H38 as H40.
          New H39. apply MKT4' in H41 as [H41 _].
          apply Mult_inv1 in H39 as H42; apply MKT4' in H42 as [H42 _].
          assert (a ∈ dom(g)).
          { apply AxiomII; split; eauto. exists ((η - f[a])⁻).
            apply AxiomII'; repeat split; auto. apply MKT49a; eauto. }
          assert (g[a] ∈ ℝ).
          { destruct Hz as [Hz[]]. apply H45,(@ Property_ran a),
            Property_Value; auto. }
          do 4 (split; auto). assert (0 < b - a).
          { apply (OrderPM_Co1 _ _ (-a)) in H; auto with real.
            rewrite Minus_P1 in H; auto. }
          assert (U+º(a; (b - a)) ⊂ dom(g)).
          { unfold Included; intros. apply AxiomII in H46 as [H46[H47[H48]]].
            rewrite Plus_P4,<-Plus_P3,(Plus_P4 (-a)),Minus_P1,Plus_P1 in H49;
            auto with real. destruct H48,H49. apply H35,AxiomII; auto. }
          exists (b - a). split; auto with real; split; auto; split; auto.
          intros. destruct H10 as [δ'[H48[H49[H50]]]].
          assert (f[a] < η). { apply H33; auto. }
          assert (0 < η - f[a]).
          { apply (OrderPM_Co1 _ _ (-f[a])) in H51; auto with real.
            rewrite Minus_P1 in H51; auto. }
          assert ((η - f[a]) / (1 + 1) ∈ ℝ /\ 0 < (η - f[a]) / (1 + 1)).
          { split; auto with real; apply OrderPM_Co5; auto. }
          destruct H47 as []; pose proof H53 as [_ H55].
          assert (0 < (η - f[a]) / (1 + 1) · (ε · (η - f[a]))).
          { apply OrderPM_Co5; auto with real. left; split; auto.
            apply OrderPM_Co5; auto. }
          assert ((η - f[a]) / (1 + 1) · (ε · (η - f[a])) ∈ ℝ
            /\ 0 < (η - f[a]) / (1 + 1) · (ε · (η - f[a]))).
          { split; auto with real. }
          apply H10 in H53 as H58; apply H10 in H57 as H59.
          destruct H58 as [δ0[H58[H60[H61]]]],H59 as [δ1[H59[H63[H64]]]].
          assert (δ1 + δ1 = δ1 · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert (δ1 < δ1 + δ1).
          { assert (δ1 + 0 < δ1 + δ1).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
            rewrite Plus_P1 in H67; auto. } rewrite H66 in H67.
          apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H67; auto with real.
          rewrite <-Mult_P3,Divide_P1,Mult_P1 in H67; auto with real.
          assert (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < (b - a) /\ δ < δ0 /\ δ < δ1).
          { destruct (Leq_P4 (b - a) δ0) as [H68|H68]; auto with real.
            - destruct (Leq_P4 (b - a) δ1) as [H69|H69]; auto with real.
              + exists ((b - a) / (1 + 1)); split; auto with real.
                split. apply OrderPM_Co5; auto with real.
                assert ((b - a) + (b - a) = (b - a) · (1 + 1)).
                { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
                assert ((b - a) < (b - a) + (b - a)).
                { assert ((b - a) + 0 < (b - a) + (b - a)).
                  { apply OrderPM_Co4; auto with real.
                    apply Leq_P1; auto with real. }
                  rewrite Plus_P1 in H71; auto with real. }
                rewrite H70 in H71. apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H71;
                auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H71;
                auto with real. split; auto. 
                split; [apply (Order_Co2 _ (b - a) _); auto with real
                |apply (Order_Co2 _ (b - a) _); auto with real].
              + exists (δ1 / (1 + 1)); split; auto with real.
                split. apply OrderPM_Co5; auto.
                split. apply (Order_Co2 _ δ1 _); auto with real.
                split; auto. apply (Order_Co2 _ δ1 _); auto with real.
                left; split; auto; apply (Leq_P3 _ (b - a) _); auto with real.
            - destruct (Leq_P4 δ0 δ1) as [H69|H69]; auto.
              + exists (δ0 / (1 + 1)); split; auto with real.
                assert (δ0 + δ0 = δ0 · (1 + 1)).
                { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
                assert (δ0 < δ0 + δ0).
                { assert (δ0 + 0 < δ0 + δ0).
                  { apply OrderPM_Co4; auto with real.
                    apply Leq_P1; auto with real. }
                  rewrite Plus_P1 in H71; auto. } rewrite H70 in H71.
                apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H71; auto with real.
                rewrite <-Mult_P3,Divide_P1,Mult_P1 in H71; auto with real.
                split. apply OrderPM_Co5; auto.
                split. apply (Order_Co2 _ δ0 _); auto with real.
                split; auto. apply (Order_Co2 _ δ0 _); auto with real.
              + exists (δ1 / (1 + 1)); split; auto with real.
                split. apply OrderPM_Co5; auto.
                split. apply (Order_Co2 _ δ0 _); auto with real.
                left; split; auto. apply (Order_Co2 _ δ1 _); auto with real.
                split; auto. apply (Order_Co2 _ δ1 _); auto with real. }
          destruct H68 as [δ[H68[H69[H70[H71]]]]].
          exists δ; do 3 (split; auto); intros x H73 [].
          assert (x ∈［a, b］).
          { assert (x < b).
            { apply (OrderPM_Co1 _ _ a) in H70; auto with real.
              rewrite <-Plus_P3,(Plus_P4 (-a)),Minus_P1,Plus_P1,Plus_P4 in H70;
              auto with real. apply (RTrans_Lt _ (a + δ) _); auto with real. }
            destruct H74,H76. apply AxiomII; repeat split; eauto. }
          apply H36 in H76 as H77; apply H37 in H76 as H78.
          New H77. apply MKT4' in H79 as [H79 _].
          apply Mult_inv1 in H77 as H80; apply MKT4' in H80 as [H80 _].
          assert (f[x] ∈ ℝ).
          { apply H16,(@ Property_ran x),Property_Value; auto. }
          assert (f[x] < η). { apply H33 in H76; auto. }
          assert (0 < η - f[x]).
          { apply (OrderPM_Co1 _ _ (-f[x])) in H82; auto with real.
            rewrite Minus_P1 in H82; auto. }
          assert (0 < ((η - f[x]) · (η - f[a]))).
          { apply (OrderPM_Co7a _ _ (η - f[a])) in H83; auto with real.
            rewrite Mult_P4,PlusMult_Co1 in H83; auto with real. }
          assert ((η - f[x])⁻ - (η - f [a])⁻
            = (f[x] - f[a]) / ((η - f[x]) · (η - f[a]))).
          { assert (1 / (η - f[x])
              = 1 · (η - f[a]) / ((η - f[x]) · (η - f[a]))).
            { apply Frac_P1; auto with real. }
            assert ((-(1)) / (η - f[a])
              = (-(1)) · (η - f[x]) / ((η - f[a]) · (η - f[x]))).
            { apply Frac_P1; auto with real. }
            rewrite Mult_P4,Mult_P1,(Mult_P4 1),Mult_P1 in H85; auto with real.
            rewrite <-PlusMult_Co3,<-PlusMult_Co3,Minus_P3,Minus_P4,
            (Mult_P4 (η - f[a])) in H86; auto with real.
            assert (-(η - f[a])⁻ = (- η + f[x]) / ((η - f[x]) · (η - f[a])));
            auto. clear H86. rewrite H85,H87.
            assert (((η - f [x]) · (η - f [a])) ∈ (ℝ ~ [0])).
            { apply MKT4'; split; eauto with real.
              apply AxiomII; split; eauto with real. intro.
              apply MKT41 in H86; eauto with real. destruct H84; auto. }
            apply Mult_inv1 in H86; apply MKT4' in H86 as [H103 _].
            rewrite <-Mult_P5; auto with real. apply RMult_Eq; auto with real.
            rewrite Plus_P4,(Plus_P4 (-η)),<-Plus_P3,(Plus_P3 (-η)),
            (Plus_P4 (-η)),Minus_P1,(Plus_P4 0),Plus_P1; auto with real. }
          assert (a < x /\ x < a + δ0).
          { split; auto. apply (OrderPM_Co1 _ _ a) in H71; auto.
            rewrite Plus_P4,(Plus_P4 δ0) in H71; auto.
            apply (RTrans_Lt _ (a + δ) _); auto with real. }
          assert (a < x /\ x < a + δ1).
          { split; auto. apply (OrderPM_Co1 _ _ a) in H72; auto.
            rewrite Plus_P4,(Plus_P4 δ1) in H72; auto.
            apply (RTrans_Lt _ (a + δ) _); auto with real. }
          apply H62 in H86 as H88; auto. apply H65 in H87 as H89; auto.
          pose proof H52 as []; pose proof H55 as []; 
          pose proof H83 as []; pose proof H84 as [].
          destruct H88. apply Abs_P4 in H88 as []; auto with real.
          assert ((η - f[a]) / (1 + 1) ≤ η - f[x]).
          { apply (OrderPM_Co8b _ _ (-(1))) in H99; auto with real.
            rewrite Mult_P4,Mult_P3,<-PlusMult_Co3,Minus_P3,Minus_P4,
            (Mult_P4 (f[x] - f[a])),<-PlusMult_Co3,Minus_P3,Minus_P4 in H99;
            auto with real.
            assert (-f[a] = (-f[a] -f[a]) / (1 + 1)).
            { apply (RMult_Eq' _ _ (1 + 1)); auto with real.
              rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1, <-Mult_P3,
              (Mult_P4 ((1 + 1)⁻)),Divide_P1,Mult_P1; auto with real. }
            apply (Plus_Leq _ _ (-f[a])) in H99; auto with real.
            rewrite <-Plus_P3,Minus_P1,Plus_P1 in H99; auto with real.
            rewrite H100 in H99. rewrite <-Mult_P5,Plus_P3,
            <-(Plus_P3 (-η)),Minus_P1,Plus_P1,(Plus_P4 (-η)) in H99;
            auto with real.
            assert (η = (η + η) / (1 + 1)).
            { apply (RMult_Eq' _ _ (1 + 1)); auto with real.
              rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1, <-Mult_P3,
              (Mult_P4 ((1 + 1)⁻)),Divide_P1,Mult_P1; auto with real. }
            apply (Plus_Leq _ _ η) in H99; auto with real.
            pattern η at 2 in H99; rewrite H101 in H99.
            rewrite <-Mult_P5,Plus_P3,<-(Plus_P3 (-f[a])),(Plus_P4 (-η)),
            Minus_P1,Plus_P1,(Plus_P4 (-f[a])),(Plus_P4 (-f[x])) in H99;
            auto with real. }
          rewrite <-H40,<-H78,H85,Abs_Div; auto with real.
          assert ((｜((η - f[x]) · (η - f[a]))｜) = ((η - f[x]) · (η - f[a]))).
          { apply me_zero_Abs; auto with real. }
          assert ((η - f[x]) · (η - f[a]) ∈ (ℝ ~ [0])).
          { apply MKT4'; split; auto with real. apply AxiomII; split;
            eauto with real. intro. apply MKT41 in H102; eauto with real. }
          apply Mult_inv1 in H102 as H103; apply MKT4' in H103 as [H103 _].
          assert (0 < (((η - f[x]) · (η - f[a]))⁻)).
          { apply OrderPM_Co10; auto with real. }
          assert (｜(f[x] - f[a])｜ < ε · ((η - f[x]) · (η - f[a]))
            -> ｜(f[x] - f[a])｜ / ((η - f[x]) · (η - f[a])) < ε).
          { intros. apply (OrderPM_Co7a _ _ ((η - f[x]) · (η - f[a]))⁻) in H105;
            auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H105;
            auto with real. }
          assert (((η - f[a]) / (1 + 1)) · (ε · (η - f[a])) 
            ≤ (η - f[x]) · (ε · (η - f[a]))).
          { assert (0 < (ε · (η - f[a]))) as [].
            { apply OrderPM_Co5; auto with real. }
            apply (OrderPM_Co7b _ _ ((ε · (η - f[a])))) in H100;
            auto with real. }
          rewrite H101. apply H105. rewrite Mult_P3,(Mult_P4 ε),<-Mult_P3;
          auto with real.
          apply (Order_Co2 _ (((η - f[a]) / (1 + 1)) · (ε · (η - f[a]))) _);
          auto with real.
        * red. assert (b ∈［a, b］).
          { destruct H. apply AxiomII; repeat split; eauto. apply Leq_P1; auto. }
          apply H36 in H38 as H39; apply H37 in H38 as H40.
          New H39. apply MKT4' in H41 as [H41 _].
          apply Mult_inv1 in H39 as H42; apply MKT4' in H42 as [H42 _].
          assert (b ∈ dom(g)).
          { apply AxiomII; split; eauto. exists ((η - f[b])⁻).
            apply AxiomII'; repeat split; auto. apply MKT49a; eauto. }
          assert (g[b] ∈ ℝ).
          { destruct Hz as [Hz[]]. apply H45,(@ Property_ran b),
            Property_Value; auto. }
          do 4 (split; auto). assert (0 < b - a).
          { apply (OrderPM_Co1 _ _ (-a)) in H; auto with real.
            rewrite Minus_P1 in H; auto. }
          assert (U-º(b; (b - a)) ⊂ dom(g)).
          { unfold Included; intros. apply AxiomII in H46 as [H46[H47[H48]]].
            rewrite Minus_P3,Minus_P4,Plus_P3,Minus_P1,Plus_P4,Plus_P1 in H48;
            auto with real. destruct H48,H49. apply H35,AxiomII; auto. }
          exists (b - a). split; auto with real; split; auto; split; auto.
          intros. destruct H14 as [δ'[H48[H49[H50]]]].
          assert (f[b] < η). { apply H33; auto. }
          assert (0 < η - f[b]).
          { apply (OrderPM_Co1 _ _ (-f[b])) in H51; auto with real.
            rewrite Minus_P1 in H51; auto. }
          assert ((η - f[b]) / (1 + 1) ∈ ℝ /\ 0 < (η - f[b]) / (1 + 1)).
          { split; auto with real; apply OrderPM_Co5; auto. }
          destruct H47 as []; pose proof H53 as [_ H55].
          assert (0 < (η - f[b]) / (1 + 1) · (ε · (η - f[b]))).
          { apply OrderPM_Co5; auto with real. left; split; auto.
            apply OrderPM_Co5; auto. }
          assert ((η - f[b]) / (1 + 1) · (ε · (η - f[b])) ∈ ℝ
            /\ 0 < (η - f[b]) / (1 + 1) · (ε · (η - f[b]))).
          { split; auto with real. }
          apply H14 in H53 as H58; apply H14 in H57 as H59.
          destruct H58 as [δ0[H58[H60[H61]]]],H59 as [δ1[H59[H63[H64]]]].
          assert (δ1 + δ1 = δ1 · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert (δ1 < δ1 + δ1).
          { assert (δ1 + 0 < δ1 + δ1).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
            rewrite Plus_P1 in H67; auto. } rewrite H66 in H67.
          apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H67; auto with real.
          rewrite <-Mult_P3,Divide_P1,Mult_P1 in H67; auto with real.
          assert (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < (b - a) /\ δ < δ0 /\ δ < δ1).
          { destruct (Leq_P4 (b - a) δ0) as [H68|H68]; auto with real.
            - destruct (Leq_P4 (b - a) δ1) as [H69|H69]; auto with real.
              + exists ((b - a) / (1 + 1)); split; auto with real.
                split. apply OrderPM_Co5; auto with real.
                assert ((b - a) + (b - a) = (b - a) · (1 + 1)).
                { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
                assert ((b - a) < (b - a) + (b - a)).
                { assert ((b - a) + 0 < (b - a) + (b - a)).
                  { apply OrderPM_Co4; auto with real.
                    apply Leq_P1; auto with real. }
                  rewrite Plus_P1 in H71; auto with real. }
                rewrite H70 in H71. apply (OrderPM_Co7a _ _ (1 + 1)⁻) in H71;
                auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H71;
                auto with real. split; auto. 
                split; [apply (Order_Co2 _ (b - a) _); auto with real
                |apply (Order_Co2 _ (b - a) _); auto with real].
              + exists (δ1 / (1 + 1)); split; auto with real.
                split. apply OrderPM_Co5; auto.
                split. apply (Order_Co2 _ δ1 _); auto with real.
                split; auto. apply (Order_Co2 _ δ1 _); auto with real.
                left; split; auto; apply (Leq_P3 _ (b - a) _); auto with real.
            - destruct (Leq_P4 δ0 δ1) as [H69|H69]; auto.
              + exists (δ0 / (1 + 1)); split; auto with real.
                assert (δ0 + δ0 = δ0 · (1 + 1)).
                { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
                assert (δ0 < δ0 + δ0).
                { assert (δ0 + 0 < δ0 + δ0).
                  { apply OrderPM_Co4; auto with real.
                    apply Leq_P1; auto with real. }
                  rewrite Plus_P1 in H71; auto. } rewrite H70 in H71.
                apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H71; auto with real.
                rewrite <-Mult_P3,Divide_P1,Mult_P1 in H71; auto with real.
                split. apply OrderPM_Co5; auto.
                split. apply (Order_Co2 _ δ0 _); auto with real.
                split; auto. apply (Order_Co2 _ δ0 _); auto with real.
              + exists (δ1 / (1 + 1)); split; auto with real.
                split. apply OrderPM_Co5; auto.
                split. apply (Order_Co2 _ δ0 _); auto with real.
                left; split; auto. apply (Order_Co2 _ δ1 _); auto with real.
                split; auto. apply (Order_Co2 _ δ1 _); auto with real. }
          destruct H68 as [δ[H68[H69[H70[H71]]]]].
          exists δ; do 3 (split; auto); intros x H73 [].
          assert (x ∈［a, b］).
          { assert (a < x).
            { apply (OrderPM_Co8a _ _ (-(1))) in H70; auto with real.
              rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3,
              Minus_P3,Minus_P4,Plus_P4 in H70; auto with real.
              apply (OrderPM_Co1 _ _ b) in H70; auto with real.
              rewrite <-Plus_P3,(Plus_P4 (-b)),Minus_P1,Plus_P1,Plus_P4 in H70;
              auto with real. apply (RTrans_Lt _ (b - δ) _); auto with real. }
            destruct H75,H76. apply AxiomII; repeat split; eauto. }
          apply H36 in H76 as H77; apply H37 in H76 as H78.
          New H77. apply MKT4' in H79 as [H79 _].
          apply Mult_inv1 in H77 as H80; apply MKT4' in H80 as [H80 _].
          assert (f[x] ∈ ℝ).
          { apply H16,(@ Property_ran x),Property_Value; auto. }
          assert (f[x] < η). { apply H33 in H76; auto. }
          assert (0 < η - f[x]).
          { apply (OrderPM_Co1 _ _ (-f[x])) in H82; auto with real.
            rewrite Minus_P1 in H82; auto. }
          assert (0 < ((η - f[x]) · (η - f[b]))).
          { apply (OrderPM_Co7a _ _ (η - f[b])) in H83; auto with real.
            rewrite Mult_P4,PlusMult_Co1 in H83; auto with real. }
          assert ((η - f[x])⁻ - (η - f [b])⁻
            = (f[x] - f[b]) / ((η - f[x]) · (η - f[b]))).
          { assert (1 / (η - f[x])
              = 1 · (η - f[b]) / ((η - f[x]) · (η - f[b]))).
            { apply Frac_P1; auto with real. }
            assert ((-(1)) / (η - f[b])
              = (-(1)) · (η - f[x]) / ((η - f[b]) · (η - f[x]))).
            { apply Frac_P1; auto with real. }
            rewrite Mult_P4,Mult_P1,(Mult_P4 1),Mult_P1 in H85; auto with real.
            rewrite <-PlusMult_Co3,<-PlusMult_Co3,Minus_P3,Minus_P4,
            (Mult_P4 (η - f[b])) in H86; auto with real.
            assert (-(η - f[b])⁻ = (- η + f[x]) / ((η - f[x]) · (η - f[b])));
            auto. clear H86. rewrite H85,H87.
            assert (((η - f [x]) · (η - f [b])) ∈ (ℝ ~ [0])).
            { apply MKT4'; split; eauto with real.
              apply AxiomII; split; eauto with real. intro.
              apply MKT41 in H86; eauto with real. destruct H84; auto. }
            apply Mult_inv1 in H86; apply MKT4' in H86 as [H103 _].
            rewrite <-Mult_P5; auto with real. apply RMult_Eq; auto with real.
            rewrite Plus_P4,(Plus_P4 (-η)),<-Plus_P3,(Plus_P3 (-η)),
            (Plus_P4 (-η)),Minus_P1,(Plus_P4 0),Plus_P1; auto with real. }
          assert (b - δ0 < x /\ x < b).
          { split; auto. apply (OrderPM_Co8a _ _ (-(1))) in H71; auto with real.
            rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3 in H71;
            auto with real. apply (OrderPM_Co1 _ _ b) in H71; auto with real.
            rewrite Plus_P4,(Plus_P4 (-δ)) in H71; auto with real.
            apply (RTrans_Lt _ (b - δ) _); auto with real. }
          assert (b - δ1 < x /\ x < b).
          { split; auto. apply (OrderPM_Co8a _ _ (-(1))) in H72; auto with real.
            rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3 in H72;
            auto with real. apply (OrderPM_Co1 _ _ b) in H72; auto with real.
            rewrite Plus_P4,(Plus_P4 (-δ)) in H72; auto with real.
            apply (RTrans_Lt _ (b - δ) _); auto with real. }
          apply H62 in H86 as H88; auto. apply H65 in H87 as H89; auto.
          pose proof H52 as []; pose proof H55 as []; 
          pose proof H83 as []; pose proof H84 as [].
          destruct H88. apply Abs_P4 in H88 as []; auto with real.
          assert ((η - f[b]) / (1 + 1) ≤ η - f[x]).
          { apply (OrderPM_Co8b _ _ (-(1))) in H99; auto with real.
            rewrite Mult_P4,Mult_P3,<-PlusMult_Co3,Minus_P3,Minus_P4,
            (Mult_P4 (f[x] - f[b])),<-PlusMult_Co3,Minus_P3,Minus_P4 in H99;
            auto with real.
            assert (-f[b] = (-f[b] -f[b]) / (1 + 1)).
            { apply (RMult_Eq' _ _ (1 + 1)); auto with real.
              rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1, <-Mult_P3,
              (Mult_P4 ((1 + 1)⁻)),Divide_P1,Mult_P1; auto with real. }
            apply (Plus_Leq _ _ (-f[b])) in H99; auto with real.
            rewrite <-Plus_P3,Minus_P1,Plus_P1 in H99; auto with real.
            rewrite H100 in H99. rewrite <-Mult_P5,Plus_P3,
            <-(Plus_P3 (-η)),Minus_P1,Plus_P1,(Plus_P4 (-η)) in H99;
            auto with real.
            assert (η = (η + η) / (1 + 1)).
            { apply (RMult_Eq' _ _ (1 + 1)); auto with real.
              rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1, <-Mult_P3,
              (Mult_P4 ((1 + 1)⁻)),Divide_P1,Mult_P1; auto with real. }
            apply (Plus_Leq _ _ η) in H99; auto with real.
            pattern η at 2 in H99; rewrite H101 in H99.
            rewrite <-Mult_P5,Plus_P3,<-(Plus_P3 (-f[b])),(Plus_P4 (-η)),
            Minus_P1,Plus_P1,(Plus_P4 (-f[b])),(Plus_P4 (-f[x])) in H99;
            auto with real. }
          rewrite <-H40,<-H78,H85,Abs_Div; auto with real.
          assert ((｜((η - f[x]) · (η - f[b]))｜) = ((η - f[x]) · (η - f[b]))).
          { apply me_zero_Abs; auto with real. }
          assert ((η - f[x]) · (η - f[b]) ∈ (ℝ ~ [0])).
          { apply MKT4'; split; auto with real. apply AxiomII; split;
            eauto with real. intro. apply MKT41 in H102; eauto with real. }
          apply Mult_inv1 in H102 as H103; apply MKT4' in H103 as [H103 _].
          assert (0 < (((η - f[x]) · (η - f[b]))⁻)).
          { apply OrderPM_Co10; auto with real. }
          assert (｜(f[x] - f[b])｜ < ε · ((η - f[x]) · (η - f[b]))
            -> ｜(f[x] - f[b])｜ / ((η - f[x]) · (η - f[b])) < ε).
          { intros. apply (OrderPM_Co7a _ _ ((η - f[x]) · (η - f[b]))⁻) in H105;
            auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H105;
            auto with real. }
          assert (((η - f[b]) / (1 + 1)) · (ε · (η - f[b])) 
            ≤ (η - f[x]) · (ε · (η - f[b]))).
          { assert (0 < (ε · (η - f[b]))) as [].
            { apply OrderPM_Co5; auto with real. }
            apply (OrderPM_Co7b _ _ ((ε · (η - f[b])))) in H100;
            auto with real. }
          rewrite H101. apply H105. rewrite Mult_P3,(Mult_P4 ε),<-Mult_P3;
          auto with real.
          apply (Order_Co2 _ (((η - f[b]) / (1 + 1)) · (ε · (η - f[b]))) _);
          auto with real. }
      admit.
  - admit.
Admitted.

Theorem Theorem4_7 : ∀ f a b μ, a < b -> μ ∈ ℝ -> Continuous_Close f a b
  -> ((f[a] < μ /\ μ < f[b]) \/ (f[b] < μ /\ μ < f[a]))
  -> ∃ x0, x0 ∈ ］a, b［ /\ f[x0] = μ.
Proof.
  pose proof OrderPM_Co9 as HA. pose proof HA as [HB HC].
  assert (1 + 1 ∈ ℝ) as HD. { auto with real. }
  assert (0 < 1 + 1) as HE.
  { assert (0 + 0 < 1 + 1).
    { apply OrderPM_Co4; auto with real. }
    rewrite Plus_P1 in H; auto with real. }
  assert (0 < (1 + 1)⁻) as HF. { apply OrderPM_Co10; auto. }
  assert (1 + 1 ∈ (ℝ ~ [0])) as HG.
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto.
    intro. apply MKT41 in H; eauto with real. destruct HE; auto. }
  apply Mult_inv1 in HG as HH; apply MKT4' in HH as [HH _].
  assert ((-(1)) < 0) as HI. { apply OrderPM_Co2a; auto with real. }
  intros. pose proof H1 as [Ha[Hb Hc]]; pose proof Hb as [Hd[He[Hf[Hg _]]]];
  pose proof Hc as [Hh[Hi[Hj[Hk _]]]]. destruct Hi as [Hi[Hl Hm]].
  set (g := \{\ λ x y, x ∈ ℝ /\ y ∈ ℝ /\ y = f[x] - μ \}\).
  assert (Function g).
  { split; intros.
    - red; intros. apply AxiomII in H3 as [_[x[y[]]]]. exists x, y; auto.
    - apply AxiomII in H3 as [H3[x1[y1[H5[H6[]]]]]],
      H4 as [H4[x2[y2[H9[H10[]]]]]]. apply MKT49b in H3 as [],H4 as [_ ].
      apply MKT55 in H5 as [],H9 as []; auto.
      rewrite <-H5 in H8; rewrite <-H9 in H12. rewrite H14,H15,H8,H12; auto. }
  assert (∀ x, x ∈ ℝ -> f[x] ∈ ℝ).
  { intros. apply Hm,(@ Property_ran x),Property_Value; auto; rewrite Hl; auto. }
  assert (FunctionR_R g).
  { split;[auto|split].
    - apply AxiomI; split; intros.
      + apply AxiomII in H5 as [_[y]]. apply AxiomII' in H5; tauto.
      + assert (f[z] ∈ ℝ). { apply H4 in H5; auto. }
        apply AxiomII; split; eauto. exists (f[z] - μ).
        apply AxiomII'; repeat split; auto with real.
        apply MKT49a; eauto with real.
    - red; intros. apply AxiomII in H5 as [_[]]. apply AxiomII' in H5; tauto. }
  assert (∀ x, x ∈ ℝ -> f[x] - μ = g[x]).
  { intros. assert (f[x] ∈ ℝ). { apply H4 in H6; auto. }
    apply Property_Fun; auto. apply AxiomII'; repeat split; auto with real.
    apply MKT49a; eauto with real. }
  pose proof H5 as [H7[]].
  assert (∀ x, x ∈ ℝ -> g[x] ∈ ℝ).
  { intros. apply H9,(@ Property_ran x),Property_Value; auto; rewrite H8; auto. } 
  assert (Continuous_Close g a b).
  { split;[idtac|split].
    - red; intros. New H11. apply AxiomII in H11 as [H11[H13[]]].
      assert (f[x] ∈ ℝ /\ g[x] ∈ ℝ) as [].
      { split;[apply H4 in H13 as H16; auto|apply H10 in H13 as H17; auto]. }
      assert (x ∈ dom(g)).
      { apply AxiomII; split; eauto. exists (f[x] - μ).
        apply AxiomII'; repeat split; auto with real.
        apply MKT49a; eauto with real. }
      red. do 4 (split; auto).
      assert (0 < x - a).
      { apply (OrderPM_Co1 _ _ (-a)) in H14; auto with real.
        rewrite Minus_P1 in H14; auto. }
      assert (0 < b - x).
      { apply (OrderPM_Co1 _ _ (-x)) in H15; auto with real.
        rewrite Minus_P1 in H15; auto. }
      assert (∃ δ0', δ0' ∈ ℝ /\ 0 < δ0' /\ δ0' < x - a /\ δ0' < b - x).
      { destruct (Leq_P4 (x - a) (b - x)) as [H21|H21]; auto with real.
        + exists ((x - a) / (1 + 1)).
          assert ((x - a) + (x - a) = (x - a) · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert ((x - a) < (x - a) + (x - a)).
          { assert ((x - a) + 0 < (x - a) + (x - a)).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
            rewrite Plus_P1 in H23; auto with real. }
          rewrite H22 in H23. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H23;
          auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H23;
          auto with real. split; auto with real.
          split. apply OrderPM_Co5; auto with real. split; auto.
          apply (Order_Co2 _ (x - a) _); auto with real.
        + exists ((b - x) / (1 + 1)).
          assert ((b - x) + (b - x) = (b - x) · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert ((b - x) < (b - x) + (b - x)).
          { assert ((b - x) + 0 < (b - x) + (b - x)).
           { apply OrderPM_Co4; auto with real.
             apply Leq_P1; auto with real. }
           rewrite Plus_P1 in H23; auto with real. }
          rewrite H22 in H23. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H23;
          auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H23;
          auto with real. split; auto with real.
          split. apply OrderPM_Co5; auto with real. split; auto.
          apply (Order_Co2 _ (b - x) _); auto with real. }
      destruct H21 as [δ0'[H21[H22[]]]].
      assert (Uº(x; δ0') ⊂ dom(g)).
      { red; intros. apply AxiomII in H25 as [H25[H26[]]].
        apply H4 in H26 as H29; apply H10 in H26 as H30.
        apply AxiomII; split; auto. exists (f[z] - μ).
        apply AxiomII'; repeat split; auto with real.
        apply MKT49a; eauto with real. }
      exists δ0'; do 3 (split; auto). intros. apply Ha in H12 as H27.
      destruct H27 as [H27[_[H28[H29[δ'[H30[H31[]]]]]]]].
      apply H33 in H26 as H34. destruct H34 as [δ0[H34[H35[]]]].
      assert (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < δ0' /\ δ < δ0).
      { destruct (Leq_P4 δ0' δ0) as [H38|H38]; auto.
        + exists (δ0' / (1 + 1)).
          assert (δ0' + δ0' = δ0' · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert (δ0' < δ0' + δ0').
          { assert (δ0' + 0 < δ0' + δ0').
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
            rewrite Plus_P1 in H40; auto. }
          rewrite H39 in H40. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H40;
          auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H40; auto.
          split; auto with real. split. apply OrderPM_Co5; auto.
          split; auto. apply (Order_Co2 _ δ0' _); auto with real.
        + exists (δ0 / (1 + 1)).
          assert (δ0 + δ0 = δ0 · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert (δ0 < δ0 + δ0).
          { assert (δ0 + 0 < δ0 + δ0).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
            rewrite Plus_P1 in H40; auto. }
          rewrite H39 in H40. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H40;
          auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H40; auto.
          split; auto with real. split. apply OrderPM_Co5; auto.
          split; auto. apply (Order_Co2 _ δ0 _); auto with real. }
      destruct H38 as [δ[H38[H39[]]]]. exists δ; do 3 (split; auto).
      intros x0 H42 []. assert (｜(x0 - x)｜ < δ0).
      { apply (RTrans_Lt _ δ _); auto with real. }
      apply H6 in H28 as H46; apply H6 in H42 as H47.
      rewrite <-H46,<-H47. rewrite Minus_P3,Minus_P4,<-Plus_P3,
      (Plus_P4 (-μ)),<-Plus_P3,Minus_P1,Plus_P1; auto with real.
    - assert (a ∈ dom(g)).
      { apply AxiomII; split; eauto. exists (f[a] - μ).
        apply AxiomII'; repeat split; auto with real.
        apply MKT49a; eauto with real. }
      do 4 (split; auto). exists (b - a).
      assert (0 < b - a).
      { apply (OrderPM_Co1 _ _ (-a)) in H; auto with real.
        rewrite Minus_P1 in H; auto. }
      assert (U+º(a; (b - a)) ⊂ dom(g)).
      { red; intros. apply AxiomII in H13 as [H13[H14[]]].
        apply H4 in H14 as H17. apply AxiomII; split; auto. exists (f[z] - μ).
        apply AxiomII'; repeat split; auto with real.
        apply MKT49a; eauto with real. }
      split; auto with real. split; auto; split; auto. intros.
      destruct Hb as [_ [_[_[_[δ'[H15[H16[]]]]]]]].
      apply H18 in H14 as [δ0[H14[H19[]]]].
      assert (∃ δ, δ ∈ ℝ /\ 0 < δ /\ δ < (b - a) /\ δ < δ0).
      { destruct (Leq_P4 (b - a) δ0) as [H22|H22]; auto with real.
        + exists ((b - a) / (1 + 1)).
          assert ((b - a) + (b - a) = (b - a) · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert ((b - a) < (b - a) + (b - a)).
          { assert ((b - a) + 0 < (b - a) + (b - a)).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto with real. }
            rewrite Plus_P1 in H24; auto with real. }
          rewrite H23 in H24. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H24;
          auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H24;
          auto with real. split; auto with real. split. apply OrderPM_Co5;
          auto with real. split; auto. apply (Order_Co2 _ (b - a) _);
          auto with real.
        + exists (δ0 / (1 + 1)).
          assert (δ0 + δ0 = δ0 · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert (δ0 < δ0 + δ0).
          { assert (δ0 + 0 < δ0 + δ0).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
            rewrite Plus_P1 in H24; auto. }
          rewrite H23 in H24. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H24;
          auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H24; auto.
          split; auto with real. split. apply OrderPM_Co5; auto.
          split; auto. apply (Order_Co2 _ δ0 _); auto with real. }
      destruct H22 as [δ[H22[H23[]]]]. exists δ; do 3 (split; auto).
      intros x H26 []. assert (a + δ < a + δ0).
      { apply (OrderPM_Co1 _ _ a) in H25; auto.
        rewrite Plus_P4,(Plus_P4 δ0) in H25; auto. }
      assert (x < a + δ0). { apply (RTrans_Lt _ (a + δ) _); auto with real. }
      apply H6 in H26 as H31; apply H6 in Hf as H32.
      rewrite <-H31,<-H32. rewrite Minus_P3,Minus_P4,<-Plus_P3,
      (Plus_P4 (-μ)),<-Plus_P3,Minus_P1,Plus_P1; auto with real.
    - admit. }
  assert (a + a = a · (1 + 1) /\ b + b = b · (1 + 1)) as [HJ HK].
  { split; rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
  set (E:= \{ λ x, x ∈［a, b］/\ 0 < g[x] \}).
  assert (E ⊂ ℝ).
  { red; intros. apply AxiomII in H12 as [_[]],H12 as [_[]]; auto. }
  assert (E ≠ Φ).
  { apply NEexE. destruct H2 as [[]|[]].
    - assert (0 < f[b] - μ).
      { apply (OrderPM_Co1 _ _ (-μ)) in H13; auto with real.
        rewrite Minus_P1 in H13; auto. }
      assert (0 < g[b]). { apply H6 in Hj. rewrite Hj in H14; auto. }
      exists b. apply AxiomII; split; [eauto|split;auto]. destruct H.
      apply AxiomII; repeat split; eauto. apply Leq_P1; auto.
    - assert (0 < f[a] - μ).
      { apply (OrderPM_Co1 _ _ (-μ)) in H13; auto with real.
        rewrite Minus_P1 in H13; auto. }
      assert (0 < g[a]). { apply H6 in Hf. rewrite Hf in H14; auto. }
      exists a. apply AxiomII; split; [eauto|split;auto]. destruct H.
      apply AxiomII; repeat split; eauto. apply Leq_P1; auto. }
  pose proof (Sup_Inf_Principle _ H12 H13) as [H14 H15]. destruct H2 as [[]|[]].
  - assert (f[a] - μ < 0 /\ 0 < f[b] - μ) as [].
    { apply (OrderPM_Co1 _ _ (-μ)) in H2,H16; auto with real.
      rewrite Minus_P1 in H2,H16; auto. }
    assert (g[a] < 0 /\ 0 < g[b]) as []. { split; rewrite <-H6; auto. }
    assert (exists !ξ, Inf E ξ).
    { apply H15. exists a. red; intros. repeat split; auto. intros.
      apply AxiomII in H21 as [_[]]. apply AxiomII in H21; tauto. }
    destruct H21 as [x0 [[[H21[H22]] H23] H24]]. exists x0.
    assert (a ≤ x0 /\ x0 ≤ b) as [].
    { split.
      + apply NNPP; intro. apply RNot_Le_Gt in H26; auto.
        assert (x0 < (x0 + a) / (1 + 1)).
        { assert (x0 + x0 = x0 · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert (x0 + x0 < x0 + a).
          { apply OrderPM_Co4; auto; apply Leq_P1; auto. }
          rewrite H27 in H28. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H28;
          auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H28;
          auto with real. }
        apply H23 in H27; auto with real. destruct H27 as [x1[]].
        apply AxiomII in H27 as [_[]]. apply AxiomII in H27 as [_[H27[]]].
        assert ((x0 + a) / (1 + 1) < a).
        { assert (x0 + a < a + a).
          { rewrite Plus_P4; auto. apply OrderPM_Co4; auto; apply Leq_P1; auto. }
          rewrite HJ in H32. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H32;
          auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H32; auto. }
        assert (x1 < a).
        { apply (RTrans_Lt _ ((x0 + a) / (1 + 1)) _); auto with real. }
        destruct H33; elim H34. apply Leq_P2; auto.
      + apply H25. apply AxiomII; split; [eauto|split; auto].
        destruct H. apply AxiomII; repeat split; eauto. apply Leq_P1; auto. }
    assert (0 < - g[a]).
    { apply (OrderPM_Co8a _ _ (-(1))) in H19; auto with real.
      rewrite Mult_P4,PlusMult_Co1,Mult_P4,<-PlusMult_Co3 in H19;
      auto with real. }
    assert (0 < - g[a] / (1 + 1)). { apply OrderPM_Co5; auto with real. }
    assert (- g[a] - g[a] = (- g[a]) · (1 + 1)).
    { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
    assert (- g[a] < - g[a] - g[a]).
    { assert (- g[a] + 0 < - g[a] - g[a]).
      { apply OrderPM_Co4; auto with real; apply Leq_P1; auto with real. }
      rewrite Plus_P1 in H31; auto with real. }
    rewrite H30 in H31. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H31;
    auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H31; auto with real.
    destruct H11 as [H11[]]. apply Theorem4_3b1 with (r:= - g[a]/(1 + 1))
    in H32 as H34; auto with real. destruct H34 as [δ[H34[]]].
    assert (x0 ≠ a).
    { intro. assert (0 < δ / (1 + 1)). { apply OrderPM_Co5; auto. }
      assert (x0 < x0 + δ / (1 + 1)).
      { assert (x0 + 0 < x0 + δ / (1 + 1)).
        { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
        rewrite Plus_P1 in H39; auto. }
      apply H23 in H39 as H40; auto with real. destruct H40 as [x1[]].
      apply AxiomII in H40 as [_[]]. apply AxiomII in H40 as [H40[H43[]]].
      assert (x1 ∈ U+(a; δ)).
      { apply AxiomII; do 3 (split; auto). rewrite <-H37.
        assert (δ / (1 + 1) < δ).
        { assert (δ + δ = δ · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert (δ < δ + δ).
          { assert (δ + 0 < δ + δ).
            { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
            rewrite Plus_P1 in H47; auto. }
          rewrite H46 in H47. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H47;
          auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H47;
          auto with real. }
        apply (RTrans_Lt _ (x0 + δ / (1 + 1)) _); auto with real.
        apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
      apply H36 in H46 as H47. destruct H47.
      assert (g[x1] < 0).
      { apply (RTrans_Lt _ (- (- g[a] / (1 + 1))) _); auto with real. }
      destruct H42,H49. elim H51. apply Leq_P2; auto with real. }
    assert (0 < g[b] / (1 + 1)). { apply OrderPM_Co5; auto. }
    assert (g[b] + g[b] = g[b] · (1 + 1)).
    { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
    assert (g[b] < g[b] + g[b]).
    { assert (g[b] + 0 < g[b] + g[b]).
      { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
      rewrite Plus_P1 in H40; auto. }
    rewrite H39 in H40. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H40;
    auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H40;
    auto with real. pose proof H as [].
    assert (x0 < b).
    { apply Theorem4_3a2 with (r:= g[b]/(1 + 1)) in H33 as H43;
      auto with real. destruct H43 as [δ1[H43[]]].
      assert (∃ x1, x1 ∈ ℝ /\ a < x1 /\ (b - δ1) < x1 /\ x1 < b).
      { destruct (Leq_P4 (b - δ1) a) as [H46|H46]; auto with real.
        + exists ((a + b) / (1 + 1)).
          assert (a + a < a + b).
          { apply OrderPM_Co4; auto; apply Leq_P1; auto. }
          assert ((b - δ1) + (b - δ1) = (b - δ1) · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert ((b - δ1) + (b - δ1) < a + b).
          { apply OrderPM_Co4; auto with real. apply (Order_Co2 _ a _);
            auto with real. }
          assert (a + b < b + b).
          { rewrite Plus_P4; auto. apply OrderPM_Co4; auto;
            apply Leq_P1; auto. }
          rewrite HJ in H47; rewrite H48 in H49; rewrite HK in H50.
          apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H47,H49,H50; auto with real.
          rewrite <-Mult_P3,Divide_P1,Mult_P1 in H47,H49,H50; auto with real.
        + exists (b - δ1 / (1 + 1)).
          assert (-δ1 < 0). { apply OrderPM_Co2a in H44; auto. }
          assert ((- δ1) · ((1 + 1)⁻) < 0).
          { apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H47; auto with real.
            rewrite (Mult_P4 0),PlusMult_Co1 in H47; auto with real. }
          assert (- δ1 - δ1 = - δ1 · (1 + 1)).
          { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
          assert (- δ1 - δ1 < - δ1).
          { assert (- δ1 - δ1 < - δ1 + 0).
            { apply OrderPM_Co4; auto with real; apply Leq_P1; auto with real. }
            rewrite Plus_P1 in H50; auto with real. }
          rewrite H49 in H50. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H50;
          auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H50;
          auto with real. pattern (-δ1) at 2 in H50.
          rewrite PlusMult_Co3,<-Mult_P3,<-PlusMult_Co3 in H50; auto with real.
          assert (b - δ1 < b - δ1 / (1 + 1)).
          { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }          
          assert (a < b - δ1 / (1 + 1)).
          { apply (Order_Co2 _ (b - δ1) _); auto with real. }
          assert (b - δ1 / (1 + 1) < b).
          { assert (b - δ1 / (1 + 1) < b + 0).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto.
              rewrite PlusMult_Co3,Mult_P3,<-PlusMult_Co3; auto with real. }
            rewrite Plus_P1 in H53; auto. }
          split; auto with real. }
      destruct H46 as [x1[H46[H47[]]]].
      assert (x1 ∈ U-(b; δ1)). { destruct H49. apply AxiomII; split; eauto. }
      assert (0 < g[x1]).
      { apply H45 in H50 as []. apply (RTrans_Lt _ (g[b] / (1 + 1)) _);
        auto with real. }
      assert (x1 ∈ E).
      { destruct H47,H49. apply AxiomII; split; eauto.
        split; [apply AxiomII; split; eauto|auto]. }
      apply H25 in H52. apply (Order_Co2 _ x1 _); auto. }
    assert (a < x0 /\ x0 < b) as []. { split; [split; auto|auto]. }
    assert (g[x0] = 0).
    { apply NNPP; intro. destruct (Leq_P4 g[x0] 0); auto with real.
      + assert (g[x0] < 0). { split; auto. }
        assert (x0 ∈ ］a, b［). { apply AxiomII; split; eauto. }
        assert (- g[x0] - g[x0] = - g[x0] · (1 + 1)).
        { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
        assert (0 < - g[x0]).
        { apply (OrderPM_Co8a _ _ (-(1))) in H48; auto with real.
          rewrite Mult_P4,PlusMult_Co1,Mult_P4,<-PlusMult_Co3 in H48;
          auto with real. }
        assert (0 < - g[x0] / (1 + 1)).
        { apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H51; auto with real.
          rewrite Mult_P4,PlusMult_Co1 in H51; auto with real. }
        assert (- g[x0] < - g[x0] - g[x0]).
        { assert (- g[x0] + 0 < - g[x0] - g[x0]).
          { apply OrderPM_Co4; auto with real; apply Leq_P1; auto with real. }
          rewrite Plus_P1 in H53; auto with real. }
        rewrite H50 in H53. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H53;
        auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H53;
        auto with real. apply H11 in H49.
        apply Theorem4_3b with (r:= - g[x0] / (1 + 1)) in H49; auto with real.
        destruct H49 as [δ1[H49[]]]. pose proof H54 as [H56 _]. 
        assert (x0 < x0 + δ1).
        { assert (x0 + 0 < x0 + δ1).
          { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
          rewrite Plus_P1 in H57; auto. }
        apply H23 in H57 as H58; auto with real.
        destruct H58 as [x1[]]. apply H25 in H58 as H60.
        assert (- δ1 < 0). { apply OrderPM_Co2a in H54; auto. }
        assert (0 ≤ x1 - x0).
        { apply (Plus_Leq _ _ (-(x0))) in H60; auto with real.
          rewrite Minus_P1 in H60; auto. }
        assert (x1 - x0 < δ1).
        { apply (OrderPM_Co1 _ _ (-(x0))) in H59; auto with real.
          rewrite (Plus_P4 x0),<-Plus_P3,Minus_P1,Plus_P1 in H59;
          auto with real. }
        assert (x1 ∈ U(x0; δ1)).
        { apply AxiomII; split; eauto; split; auto. split.
          apply Abs_P4; auto with real. split.
          * apply (Order_Co2 _ 0 _); auto with real.
          * destruct H63; auto.
          * intro. rewrite me_zero_Abs in H64; auto with real.
            destruct H63; auto. }
         assert (g[x1] < 0).
         { apply H55 in H64 as []. apply (RTrans_Lt _ (-(- g[x0] / (1 + 1))) _);
           auto with real. }
         apply AxiomII in H58 as [_[]]. apply AxiomII in H58 as [_[]].
         destruct H65,H66. elim H68. apply Leq_P2; auto with real.
      + assert (0 < g[x0]). { split; auto. }
        assert (x0 ∈ ］a, b［). { apply AxiomII; split; eauto. }
        assert (0 < g[x0] / (1 + 1)).
        { apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H48; auto with real.
          rewrite Mult_P4,PlusMult_Co1 in H48; auto with real. }
        assert (g[x0] + g[x0] = g[x0] · (1 + 1)).
        { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
        assert (g[x0] / (1 + 1) < g [x0]).
        { assert (g[x0] < g[x0] + g[x0]).
          { assert (g[x0] + 0 < g[x0] + g[x0]).
            { apply OrderPM_Co4; auto with real; apply Leq_P1; auto. }
            rewrite Plus_P1 in H52; auto. }
          apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H52; auto with real.
          rewrite H51,<-Mult_P3,Divide_P1,Mult_P1 in H52; auto. }
        apply H11 in H49. apply Theorem4_3a with (r:= g[x0] / (1 + 1)) in H49;
        auto with real. destruct H49 as [δ2[H49[]]].
        assert (- δ2 < 0). { apply OrderPM_Co2a in H53; auto. }
        assert (- (δ2 / (1 + 1)) < 0).
        { apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H55; auto with real.
          rewrite (Mult_P4 0),PlusMult_Co1,PlusMult_Co3,<-Mult_P3,
          <-PlusMult_Co3 in H55; auto with real. }
        assert (- δ2 - δ2 = - δ2 · (1 + 1)).
        { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
        assert (- δ2 < - (δ2 / (1 + 1))).
        { assert (- δ2 - δ2 < - δ2).
          { assert (- δ2 - δ2 < - δ2 + 0).
            { apply OrderPM_Co4; auto with real; apply Leq_P1; auto with real. }
            rewrite Plus_P1 in H58; auto with real. }
          rewrite H57 in H58. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H58;
          auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H58;
          auto with real. pattern (- δ2) at 2 in H58.
          rewrite PlusMult_Co3,<-Mult_P3,<-PlusMult_Co3 in H58; auto with real. }
        assert (∃ x1, x1 ∈ ℝ /\ a < x1 /\ (x0 - δ2) < x1 /\ x1 < x0).
        { destruct (Leq_P4 a (x0 - δ2)) as [H59|H59]; auto with real.
          * exists (x0 - (δ2 / (1 + 1))).
            assert (x0 - δ2 < x0 - (δ2 / (1 + 1))).
            { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
            assert (x0 - (δ2 / (1 + 1)) < x0).
            { assert (x0 - (δ2 / (1 + 1)) < x0 + 0).
              { apply OrderPM_Co4; auto with real. apply Leq_P1; auto. }
              rewrite Plus_P1 in H61; auto. }
            split; auto with real. split; auto.
            apply (Order_Co2 _ (x0 - δ2) _); auto with real.
          * exists ((a + x0) / (1 + 1)).
            assert (x0 + x0 = x0 · (1 + 1)).
            { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
            assert ((x0 - δ2) + (x0 - δ2) = (x0 - δ2) · (1 + 1)).
            { rewrite Mult_P4,Mult_P5,Mult_P4,Mult_P1; auto with real. }
            assert (a < (a + x0) / (1 + 1)).
            { assert (a + a < a + x0).
              { apply OrderPM_Co4; auto; apply Leq_P1; auto. }
              rewrite HJ in H62. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H62;
              auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H62; auto. }
            assert (x0 - δ2 < x0). { apply (Order_Co2 _ a _); auto with real. }
            assert (x0 - δ2 < (a + x0) / (1 + 1)).
            { assert ((x0 - δ2) + (x0 - δ2) < a + x0).
              { apply OrderPM_Co4; auto with real. }
              rewrite H61 in H64. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H64;
              auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H64;
              auto with real. }
            assert ((a + x0) / (1 + 1) < x0).
            { assert (a + x0 < x0 + x0).
              { rewrite Plus_P4; auto. apply OrderPM_Co4; auto;
                apply Leq_P1; auto with real. }
              rewrite H60 in H65. apply (OrderPM_Co7a _ _ ((1 + 1)⁻)) in H65;
              auto with real. rewrite <-Mult_P3,Divide_P1,Mult_P1 in H65; auto. }
            split; auto with real. }
        destruct H59 as [x1[H59[H60[]]]].
        assert (- δ2 < x1 - x0).
        { apply (OrderPM_Co1 _ _ (-x0)) in H61; auto with real.
          rewrite (Plus_P4 x0),<-Plus_P3,Minus_P1,Plus_P1 in H61;
          auto with real. }
        assert (x1 - x0 < 0).
        { apply (OrderPM_Co1 _ _ (-x0)) in H62; auto with real.
          rewrite Minus_P1 in H62; auto. }
        assert (x1 ∈ U(x0; δ2)).
        { apply AxiomII; split; eauto; split; auto. split.
          * destruct H53. apply Abs_P4; auto with real. split.
            -- destruct H63; auto.
            -- apply (Order_Co2 _ 0 _); auto with real.
          * intro. destruct H64. rewrite le_zero_Abs in H65; auto with real.
            apply (OrderPM_Co8a _ _ (-(1))) in H63; auto with real.
            rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3,
            Minus_P4 in H63; auto with real. destruct H63; auto. }
        apply H54 in H65 as [].
        assert (0 < g[x1]).
        { apply (RTrans_Lt _ (g[x0] / (1 + 1)) _); auto with real. }
        assert (x1 ∈ E).
        { assert (x1 ≤ b). { apply (Order_Co2 _ (x0) _); auto. }
          apply AxiomII; split; [eauto|split;auto]. destruct H60.
          apply AxiomII; split; eauto. }
        apply H25 in H68. destruct H62. elim H69. apply Leq_P2; auto. }
    assert (f[x0] ∈ ℝ). { apply H4 in H22; auto. }
    assert (f[x0] = μ).
    { apply H6 in H22. rewrite <-H22 in H46. apply (RPlus_Eq _ _ μ) in H46;
      auto with real. rewrite <-Plus_P3,(Plus_P4 (-μ)),Minus_P1,Plus_P1,Plus_P4,
      Plus_P1 in H46; auto with real. }
    split; auto. apply AxiomII; split; eauto.
  - admit.
Admitted.

(*根的存在定理 介值定理的推论*)
Corollary Corollary4_7 : ∀ f a b, a < b -> Continuous_Close f a b
  -> ((f[a] < 0 /\ 0 < f[b]) \/ (f[b] < 0 /\ 0 < f[a]))
  -> ∃ x0, x0 ∈ ］a, b［ /\ f[x0] = 0.
Proof. intros. apply Theorem4_7; auto with real. Qed.

(* 反函数单调性 *)
Lemma Lemma4_8a : ∀ f g a b, Inverse_Fun f g -> a < b
  -> DStrictMonoInc_Fun f ［a, b］ -> Continuous_Close f a b
  -> DStrictMonoInc_Fun g ［(f[a]), (f[b])］.
Admitted.

Lemma Lemma4_8b : ∀ f g a b, Inverse_Fun f g -> a < b
  -> DStrictMonoDec_Fun f ［a, b］ -> Continuous_Close f a b
  -> DStrictMonoDec_Fun g ［(f[b]), (f[a])］.
Admitted.

Theorem Theorem4_8a : ∀ f g a b, Inverse_Fun f g -> a < b 
  -> Continuous_Close f a b -> DStrictMonoInc_Fun f ［a, b］
  -> Continuous_Close g f[a] f[b].
Admitted.

Theorem Theorem4_8b : ∀ f g a b, Inverse_Fun f g -> a < b 
  -> Continuous_Close f a b -> DStrictMonoDec_Fun f ［a, b］
  -> Continuous_Close g f[b] f[a].
Admitted.

Proposition not_all_ex_not :
  ∀(U : Type)(P : U -> Prop),~ (∀n : U,P n) -> ∃n : U,~ P n.
Proof.
  intros. apply NNPP; intro. elim H.
  intros. apply NNPP; intro. elim H0; eauto.
Qed. 

Proposition not_ex_not_all :
  ∀ U P, ~ (∃n : U,~ P n) -> ∀n : U,P n.
Proof.
  intros. apply NNPP; intro. elim H; eauto.
Qed.

(* 一致连续 *)
Definition UniCont f I := FunctionR_R f /\ I ⊂ dom(f) /\ (∀ ε, ε ∈ ℝ /\ 0 < ε
  -> (∃ δ, δ ∈ ℝ /\ 0 < δ /\ (∀ x1 x2, x1 ∈ I -> x2 ∈ I -> ｜(x1 - x2)｜ < δ
      -> ｜(f[x1] - f[x2])｜ < ε))).

(* 一致连续性定理 *)
Theorem Theorem4_9 : ∀ f a b, Continuous_Close f a b -> UniCont f ［a, b］.
Proof.
  pose proof OrderPM_Co9 as HA. pose proof HA as [HB HC].
  assert (1 + 1 ∈ ℝ) as HD. { auto with real. }
  assert (0 < 1 + 1) as HE.
  { assert (0 + 0 < 1 + 1).
    { apply OrderPM_Co4; auto with real. }
    rewrite Plus_P1 in H; auto with real. }
  assert (0 < (1 + 1)⁻) as HF. { apply OrderPM_Co10; auto. }
  assert (1 + 1 ∈ (ℝ ~ [0])) as HG.
  { apply MKT4'; split; auto with real. apply AxiomII; split; eauto.
    intro. apply MKT41 in H; eauto with real. destruct HE; auto. }
  apply Mult_inv1 in HG as HH; apply MKT4' in HH as [HH _].
  assert ((-(1)) < 0) as HI. { apply OrderPM_Co2a; auto with real. }
  intros f a b [Ha[[Hb Hc] [Hd He]]]. pose proof Hc as [Hf[Hg[Hh _]]];
  pose proof He as [Hi[Hj[Hk _]]]. destruct Hi as [Hi[Hl Hm]].
  assert (H0 : ［a, b］ ⊂ dom(f)).
  { red; intros. apply AxiomII in H as [H[H0[]]].
    destruct (classic (z = a)) as [I1|I1].
    - rewrite I1; auto.
    - destruct (classic (z = b)) as [I2|I2].
      + rewrite I2; auto.
      + assert (I3 : z ∈ ］a, b［). { apply AxiomII; repeat split; auto. }
        apply Ha in I3. apply I3. }
  split; auto; split; auto.
  destruct (Order_Co1 a b) as [H1|[H1|H1]]; auto.
  - apply NNPP; intro. apply not_all_ex_not in H as [ε0 H2].
    apply imply_to_and in H2 as [H2 H3].
    assert (H4 : ∀ δ, δ ∈ ℝ /\ 0 < δ -> (∃ x1 x2, x1 ∈ ［a, b］ /\ x2 ∈ ［a, b］
      /\ ｜(x1 - x2)｜ < δ /\ ε0 ≤ ｜(f[x1] - f[x2])｜)).
    { assert (I1 : ∀ δ, ~ (δ ∈ ℝ /\ 0 < δ /\ (∀x1 x2, x1 ∈ ［a, b］
        -> x2 ∈ ［a, b］ -> ｜(x1 - x2)｜ < δ -> ｜(f[x1] - f[x2])｜ < ε0))).
      { apply not_ex_all_not; auto. }
      intro δ. generalize (I1 δ); intros. destruct H4 as [H4 H5].
      apply notandor in H as [H6|H6]. contradiction.
      apply notandor in H6 as [H6|H6]. contradiction.
      apply not_all_ex_not in H6 as [x1 H6].
      apply not_all_ex_not in H6 as [x2 H6].
      apply imply_to_and in H6 as [H6 H7]. apply imply_to_and in H7 as [H7 H8].
      apply imply_to_and in H8 as [H8 H9]. destruct H2 as [H2 H10].
      pose proof H6 as H11; pose H7 as H12.
      apply AxiomII in H11 as [_[H11 _]],H12 as [_[H12 _]].
      assert (f[x1] ∈ ℝ /\ f[x2] ∈ ℝ) as [H13 H14].
      { split; [apply Hm,(@ Property_ran x1),Property_Value; auto|
        apply Hm,(@ Property_ran x2),Property_Value; auto]. }
      apply RNot_Lt_Ge in H9; auto with real. exists x1, x2; auto. }
    destruct AxiomIX as [c[Hn Ho]].
    assert (∃ δ, δ ∈ ℝ /\ δ = (b - a)) as [δ[H5 H6]].
    { exists (b - a); auto with real. }
    set (xy := \{\ λ n v, n ∈ ℕ /\ v = c[\{\ λ x y, x ∈ ℝ /\ y ∈ ℝ
      /\ x ∈ ［a, b］ /\ y ∈ ［a, b］ /\ ｜(x - y)｜ < δ / (n + 1) 
      /\ ε0 ≤ ｜(f[x] - f[y])｜ \}\] \}\).
    set (x := \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = First (xy[n]) \}\).
    set (y := \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = Second (xy[n]) \}\).
    assert (H7 : Function xy).
    { split; intros.
      + red; intros. apply AxiomII in H as [H[x1[y1[]]]]. exists x1, y1; tauto.
      + apply AxiomII in H as [H[x1[y1[H8[H9]]]]],H7 as [H7[x2[y2[H11[H12]]]]].
        apply MKT49b in H as [],H7 as [_ ]. apply MKT55 in H8 as [],H11 as [];
        auto. rewrite <-H8 in H10; rewrite <-H11 in H13.
        rewrite H15,H16,H10,H13; auto. }
    assert (∀ n, n ∈ ℕ -> \{\ λ x y, x ∈ ℝ /\ y ∈ ℝ /\ x ∈ ［a, b］/\ y ∈ ［a, b］
      /\ ｜(x - y)｜ < δ / (n + 1) /\ ε0 ≤ ｜(f[x] - f[y])｜ \}\ ⊂ ℝ × ℝ).
    { red; intros. apply AxiomII in H8 as [H8[x1[y1[H9[H10[]]]]]].
      rewrite H9. apply AxiomII'; split; auto. apply MKT49a; eauto. }
    assert (0 < b - a).
    { apply (OrderPM_Co1 _ _ (-a)) in H1; auto with real.
      rewrite Minus_P1 in H1; auto. }
    assert (0 < δ). { rewrite <-H6 in H8; auto. }
    assert (∀ n, n ∈ ℕ -> 0 < n + 1).
    { intros. pose proof one_is_min_in_N as [H12[]]. apply H13 in H11 as H14.
      assert (1 + 0 < n + 1). { apply OrderPM_Co4; auto with real. }
      rewrite Plus_P1 in H15; auto with real.
      apply (RTrans_Lt _ 1 _); auto with real. }
    assert (∀ n, n ∈ ℕ -> 0 < (n + 1)⁻).
    { intros. apply H10 in H11 as H12. apply OrderPM_Co10; auto with real. }
    assert (∀ n, n ∈ ℕ -> n + 1 ∈ (ℝ ~ [0])).
    { intros. apply MKT4'; split; auto with real. apply AxiomII; split;
      eauto with real. intro. apply MKT41 in H13; eauto with real.
      apply H10 in H12 as [ _]; auto. }
    assert (∀ n, n ∈ ℕ -> (n + 1)⁻ ∈ ℝ).
    { intros. apply H12 in H13 as H14. apply Mult_inv1 in H14.
      apply MKT4' in H14 as [H14 _]; auto. }
    assert (∀ n, n ∈ ℕ -> δ / (n + 1) ∈ ℝ /\ 0 < δ / (n + 1)).
    { intros. apply H11 in H14 as H15; apply H13 in H14 as H16.
      apply N_Subset_R in H14. split; auto with real. apply OrderPM_Co5; auto. }
    assert (∀ n, n ∈ ℕ -> \{\ λ x y, x ∈ ℝ /\ y ∈ ℝ /\ x ∈ ［a, b］/\ y ∈ ［a, b］
      /\ ｜(x - y)｜ < δ / (n + 1) /\ ε0 ≤ ｜(f[x] - f[y])｜ \}\ ≠ Φ).
    { intros. apply H14 in H15 as H16. apply H4 in H16 as [x1[y1[H16[H17[]]]]].
      apply NEexE. exists [x1, y1]. apply AxiomII in H16 as H20, H17 as H21.
      destruct H20 as [_[H20[_]]],H21 as [_[H21[_]]].
      apply AxiomII'; split; [idtac|split;auto]. apply MKT49a; eauto. }
    assert (∀ n, n ∈ ℕ -> Ensemble \{\ λ x y, x ∈ ℝ /\ y ∈ ℝ /\ x ∈ ［a, b］
      /\ y ∈ ［a, b］ /\ ｜(x - y)｜ < δ / (n + 1) /\ ε0 ≤ ｜(f[x] - f[y])｜ \}\).
    { intros. apply H in H16 as H17. apply MKT33 in H17; auto.
      apply MKT74; apply Ensemble_R. }
    assert (∀ n, n ∈ ℕ -> c[\{\ λ x y, x ∈ ℝ /\ y ∈ ℝ /\ x ∈ ［a, b］
      /\ y ∈ ［a, b］ /\ ｜(x - y)｜ < δ / (n + 1) /\ ε0 ≤ ｜(f[x] - f[y])｜ \}\]
      ∈ \{\ λ x y, x ∈ ℝ /\ y ∈ ℝ /\ x ∈ ［a, b］ /\ y ∈ ［a, b］
        /\ ｜(x - y)｜ < δ / (n + 1) /\ ε0 ≤ ｜(f[x] - f[y])｜ \}\).
    { intros. apply H in H17 as H18; apply H15 in H17 as H19;
      apply H16 in H17 as H20. apply Hn. rewrite Ho. apply MKT4'; split; auto.
      apply AxiomII; split; auto. intro. apply MKT41 in H21; auto. }
    assert (∀ n, n ∈ ℕ -> c [\{\ λ x y, x ∈ ℝ /\ y ∈ ℝ /\ x ∈ ［a, b］
      /\ y ∈ ［a, b］ /\ ｜(x - y)｜ < δ / (n + 1) /\ ε0 ≤ ｜(f[x] - f[y])｜ \}\]
      = xy[n]).
    { intros. apply Property_Fun; auto. apply AxiomII'; split; auto.
      apply MKT49a; eauto. }
    assert (∀ n, n ∈ ℕ -> xy[n] ∈ \{\ λ x y, x ∈ ℝ /\ y ∈ ℝ /\ x ∈ ［a, b］
      /\ y ∈ ［a, b］ /\ ｜(x - y)｜ < δ / (n + 1) /\ ε0 ≤ ｜(f[x] - f[y])｜ \}\).
    { intros. apply H17 in H19 as H20; apply H18 in H19 as H21.
      rewrite H21 in H20; auto. }
    assert (dom(xy) = ℕ).
    { apply AxiomI; split; intros.
      + apply AxiomII in H20 as [H20[y1]]. apply AxiomII' in H21; tauto.
      + apply H18 in H20 as H21; apply H19 in H20 as H22.
        apply AxiomII; split; eauto. exists xy[z].
        apply AxiomII'; split; auto. apply MKT49a; eauto. }
    assert (ran(xy) ⊂ (ℝ × ℝ)).
    { red; intros. apply AxiomII in H21 as [H21[n]]. apply AxiomII' in H22
      as [H22[]]. apply H18 in H23 as H25; apply H19 in H23 as H26.
      rewrite H24,H25. apply AxiomII in H26 as [H26[x1[y1[H27[H28[]]]]]].
      apply AxiomII; split; auto. exists x1, y1; auto. }
    assert (Function x /\ Function y) as [].
    { split; [split; intros|split; intros].
      + red; intros. apply AxiomII in H22 as [H22[x1[y1]]]. exists x1,y1; tauto.
      + apply AxiomII in H22 as [H22[x1[y1[H24[H25[]]]]]],H23 as
        [H23[x2[y2[H28[H29[]]]]]]. apply MKT49b in H22 as [],H23 as [_ ].
        apply MKT55 in H24 as [],H28 as []; auto.
        rewrite <-H24 in H27; rewrite <-H28 in H31. rewrite H33,H34,H27; auto.
      + red; intros. apply AxiomII in H22 as [H22[x1[y1]]]. exists x1,y1; tauto.
      + apply AxiomII in H22 as [H22[x1[y1[H24[H25[]]]]]],H23 as
        [H23[x2[y2[H28[H29[]]]]]]. apply MKT49b in H22 as [],H23 as [_ ].
        apply MKT55 in H24 as [],H28 as []; auto.
        rewrite <-H24 in H27; rewrite <-H28 in H31. rewrite H33,H34,H27; auto. }
    assert (∀ n, n ∈ ℕ -> First xy[n] = x[n]).
    { intros. apply Property_Fun; auto.
      assert (First xy[n] ∈ ℝ).
      { apply H19 in H24 as H25. apply AxiomII in H25 
        as [H25[x1[y1[H26[H27[H28 _]]]]]]. rewrite H26.
        assert (First ([x1, y1]) = x1). { apply MKT54a; eauto. }
        rewrite H29; auto. }
      apply AxiomII'; split; auto. apply MKT49a; eauto. }
    assert (∀ n, n ∈ ℕ -> Second xy[n] = y[n]).
    { intros. apply Property_Fun; auto.
      assert (Second xy[n] ∈ ℝ).
      { apply H19 in H25 as H26. apply AxiomII in H26 
        as [H26[x1[y1[H27[H28[H29 _]]]]]]. rewrite H27.
        assert (Second ([x1, y1]) = y1). { apply MKT54b; eauto. }
        rewrite H30; auto. }
      apply AxiomII'; split; auto. apply MKT49a; eauto. }
    assert (Seq x).
    { split; [auto|split].
      + apply AxiomI; split; intros.
        * apply AxiomII in H26 as [_[y1]]. apply AxiomII' in H26; tauto.
        * apply AxiomII; split; eauto. exists (First xy[z]).
          assert (First xy[z] ∈ ℝ).
          { apply H19 in H26 as H27. apply AxiomII in H27
            as [_[x1[y1[H27[H28[H29 _]]]]]]. rewrite H27.
            assert (First ([x1, y1]) = x1). { apply MKT54a; eauto. }
            rewrite H30; auto. }
          apply AxiomII'; split; auto. apply MKT49a; eauto.
      + red; intros. apply AxiomII in H26 as [_[x1]].
        apply AxiomII' in H26; tauto. }
    assert (Seq y).
    { split; [auto|split].
      + apply AxiomI; split; intros.
        * apply AxiomII in H27 as [_[y1]]. apply AxiomII' in H27; tauto.
        * apply AxiomII; split; eauto. exists (Second xy[z]).
          assert (Second xy[z] ∈ ℝ).
          { apply H19 in H27 as H28. apply AxiomII in H28 
            as [H28[x1[y1[H29[H30[H31]]]]]]. rewrite H29.
            assert (Second ([x1, y1]) = y1). { apply MKT54b; eauto. }
            rewrite H33; auto. }
          apply AxiomII'; split; auto. apply MKT49a; eauto.
      + red; intros. apply AxiomII in H27 as [_[x1]].
        apply AxiomII' in H27; tauto. }
    pose proof H26 as [H28[]]; pose proof H27 as [H31[]].
    assert (∀ n, n ∈ ℕ -> [x[n], y[n]] = xy[n]).
    { intros. apply H19 in H34 as H35. apply AxiomII in H35 
      as [H35[x1[y1[H36[H37[H38]]]]]]. rewrite H36. symmetry.
      apply MKT55; eauto. split.
      + assert (First (xy[n]) = x1). { rewrite H36. apply MKT54a; eauto. }
        rewrite H24 in H40; auto.
      + assert (Second (xy[n]) = y1). { rewrite H36. apply MKT54b; eauto. }
        rewrite H25 in H40; auto. }
    assert (∀ n, n ∈ ℕ -> [n, [x[n], y[n]]] ∈ xy).
    { intros. rewrite H34; auto. apply Property_Value; auto. rewrite H20; auto. }
    assert (∀ n, n ∈ ℕ -> x[n] ∈ ［a, b］ /\ y[n] ∈ ［a, b］
      /\ ｜(x[n] - y[n])｜ < δ / (n + 1) /\ ε0 ≤ ｜(f[x[n]] - f[y[n]])｜).
    { intros. apply H34 in H36 as H37; apply H19 in H36 as H38.
      rewrite <-H37 in H38. apply AxiomII in H38
      as [H38[x1[y1[H39[H40[H41[H42[H43[H44]]]]]]]]]. apply MKT49b in H38 as [].
      apply MKT55 in H39 as []; auto. subst x1; subst y1; auto. }
    clear H H15 H16 H17 H18 H19 H22 H23 H24 H25 H34 H35.
    assert (∀ n, n ∈ ℕ -> x[n] ∈ ℝ /\ y[n] ∈ ℝ).
    { intros. split; [apply H30,(@ Property_ran n),Property_Value; auto;
      rewrite H29; auto|apply H33,(@ Property_ran n),Property_Value; auto;
      rewrite H32; auto]. }
    assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] - y[n] \}\).
    { split; [idtac|split].
      + split; intros.
        * red; intros. apply AxiomII in H15 as [_[x1[y1]]]. exists x1, y1; tauto.
        * apply AxiomII' in H15 as [H15[H17[]]],H16 as [H16[H22[]]].
          rewrite H24; auto.
      + apply AxiomI; split; intros.
        * apply AxiomII in H15 as [_[y1]]. apply AxiomII' in H15; tauto.
        * apply H in H15 as H16; destruct H16 as [].
          assert (x[z] - y[z] ∈ ℝ). { auto with real. }
          apply AxiomII; split; eauto. exists (x[z] - y[z]).
          apply AxiomII'; split; auto. apply MKT49a; eauto.
      + red; intros. apply AxiomII in H15 as [_[x1]].
        apply AxiomII' in H15; tauto. }
    assert (∀ n, n ∈ ℕ 
      -> x[n] - y[n] = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] - y[n] \}\[n]).
    { intros. apply Property_Fun. apply H15.
      apply H in H16 as H17; destruct H17 as [].
      assert (x[n] - y[n] ∈ ℝ). { auto with real. }
      apply AxiomII; split. apply MKT49a; eauto. exists n, (x[n] - y[n]); auto. }
    assert (Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = x[n] - y[n] \}\ 0).
    { split; auto. intros ε [].
      pose proof (Archimedes _ _ H17 H5 H18 H9) as [N[]]. exists N; split; auto.
      intros. apply H in H23 as H25; destruct H25 as [].
      apply H16 in H23 as H35. rewrite <-H35,Minus_P2; auto with real.
      apply H36 in H23 as H37; destruct H37 as [H37[H38[]]].
      assert (n < n + 1). { apply Nat_P4b; auto. apply Leq_P1; auto with real. }
      apply (OrderPM_Co7a _ _ ε) in H24,H41; auto with real.
      assert (δ < (n + 1) · ε).
      { apply (RTrans_Lt _ (N · ε) _); auto with real.
        apply (RTrans_Lt _ (n · ε) _); auto with real. }
      apply H11 in H23 as H43; apply H12 in H23 as H44; apply H13 in H23 as H45.
      assert (｜(x[n] - y[n])｜ ∈ ℝ). { apply Abs_in_R; auto with real. }
      apply (OrderPM_Co7a _ _ (n + 1) ⁻) in H42; auto with real.
      rewrite (Mult_P4 (n + 1)),<-Mult_P3,Divide_P1,Mult_P1 in H42;
      auto with real. apply (RTrans_Lt _ (δ / (n + 1)) _); auto with real. }
    assert (BoundedSeq x).
    { split; auto. destruct (Leq_P4 a 0) as [H18|H18]; auto with real.
      + destruct (Leq_P4 b 0) as [H19|H19]; auto with real.
        * exists (-a); split; auto with real. intros.
          apply H36 in H22 as H23. destruct H23 as [H23 _].
          apply AxiomII in H23 as [H23[H24[]]].
          assert (x[n] ≤ 0). { apply (Leq_P3 _ b _); auto with real. }
          rewrite le_zero_Abs; auto. destruct HI.
          apply (OrderPM_Co8b _ _ (-(1))) in H25; auto with real.
          rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3 in H25;
          auto with real.
        * destruct (Leq_P4 (-a) b) as [H22|H22]; auto with real.
          -- exists b; split; auto. intros. destruct HI as [HI _].
             apply H36 in H23 as H24; destruct H24 as [H24 _].
             apply AxiomII in H24 as [H24[H25[]]]. apply Abs_P4; auto.
             split; auto. apply (OrderPM_Co8b _ _ (-(1))) in H22;
             auto with real. rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,
             <-PlusMult_Co3,Minus_P4 in H22; auto with real.
             apply (Leq_P3 _ a _); auto with real.
          -- exists (-a); split; auto with real. destruct HI as [HI _].
             assert (0 ≤ - a).
             { apply (OrderPM_Co8b _ _ (-(1))) in H18; auto with real.
               rewrite Mult_P4,PlusMult_Co1,Mult_P4,<-PlusMult_Co3 in H18;
               auto with real. }
             intros. apply H36 in H24 as H25; destruct H25 as [H25 _].
             apply AxiomII in H25 as [_[H25[]]]. apply Abs_P4; auto with real.
             split; [rewrite Minus_P4; auto|apply (Leq_P3 _ b _);
             auto with real].
      + exists b; split; auto. intros.
        apply H36 in H19 as H22; destruct H22 as [H22 _].
        apply AxiomII in H22 as [_[H22[]]].
        assert (0 ≤ x[n]). { apply (Leq_P3 _ a _); auto with real. }
        rewrite me_zero_Abs; auto. }
    apply Theorem2_10 in H18 as [xk[[H18[H19[F[H22[H23[H24]]]]]] [x0[]]]].
    set (yk := \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = y[F[n]] \}\).
    assert (Function yk).
    { split; intros.
      + red; intros. apply AxiomII in H37 as [_[x1[y1]]]. exists x1, y1; tauto.
      + apply AxiomII' in H37 as [H37[H39[]]],H38 as [H38[H42[]]].
        rewrite H44; auto. }
    assert (∀ n, n ∈ ℕ -> y[F[n]] ∈ ℝ).
    { intros. apply H33,(@ Property_ran F[n]),Property_Value; auto.
      rewrite H32. apply H24,(@ Property_ran n),Property_Value; auto.
      apply H22. rewrite H23; auto. }
    assert (Seq yk).
    { split; [auto|split].
      + apply AxiomI; split; intros.
        * apply AxiomII in H39 as [_[y1]]. apply AxiomII' in H39; tauto.
        * apply AxiomII; split; eauto. exists (y[F[z]]).
          apply H38 in H39 as H40. apply AxiomII'; split; auto.
          apply MKT49a; eauto.
      + red; intros. apply AxiomII in H39 as [_[x1]].
        apply AxiomII' in H39; tauto. }
    assert (∀ n, n ∈ ℕ -> y[F[n]] = yk[n]).
    { intros. apply Property_Fun; auto. apply H38 in H40 as H41.
      apply AxiomII'; split; auto. apply MKT49a; eauto. } 
    clear H3 H4. pose proof H19 as [H3[]]. pose proof H39 as [_[]].
    assert (∀ n, n ∈ ℕ -> F[n] ∈ ℕ).
    { intros. apply H24,(@ Property_ran n),Property_Value; auto. apply H22.
      rewrite H23; auto. }
    assert (∀ n, n ∈ ℕ -> x[F[n]] ∈ ℝ).
    { intros. apply H25 in H45 as H46. rewrite <-H46.
      apply H41,(@ Property_ran n),Property_Value; auto; rewrite H4; auto. }
    assert (Limit_Seq yk x0).
    { split; auto. intros ε [].
      assert (ε / (1 + 1) ∈ ℝ /\ 0 < ε / (1 + 1)).
      { split; auto with real; apply OrderPM_Co5; auto. }
      apply H17 in H48 as H49; apply H35 in H48 as H50.
      destruct H49 as [N1[H49]]; destruct H50 as [N2[]].
      pose proof (Max_nat_2 _ _ H49 H50) as [N[H53[]]].
      exists N; split; auto. intros. pose proof H22 as [H58 _].
      assert (N1 < n /\ N2 < n) as [].
      { split; apply (RTrans_Lt _ N _); auto with real. }
      assert (N1 < F[n]).
      { assert (n ≤ F[n]). { apply K_Leq_Fk; auto. rewrite H23; auto. }
        apply (Order_Co2 _ n _); auto with real. }
      apply H51 in H61 as H62; apply H52 in H60; auto.
      apply H44 in H56 as H63; apply H16 in H63 as H64.
      apply H25 in H56 as H65; apply H40 in H56 as H66.
      apply H38 in H56 as H67; apply H45 in H56 as H68.
      rewrite <-H64,Minus_P2 in H62; auto with real.
      assert (｜(y[F[n]] - x[F[n]])｜ = ｜(x[F[n]] - y[F[n]])｜).
      { apply Abs_P7; auto. }
      assert (｜(yk[n] - xk[n])｜ < ε / (1 + 1)).
      { rewrite H65,<-H66,H69; auto. }
      assert (xk[n] ∈ ℝ /\ yk[n] ∈ ℝ) as [].
      { rewrite H65,<-H66; auto. }
      assert (yk[n] - x0 = (yk[n] - xk[n]) + (xk[n] - x0)).
      { rewrite <-Plus_P3,(Plus_P3 (-xk[n])),(Plus_P4 (-xk[n])),
        Minus_P1,(Plus_P4 0),Plus_P1; auto with real. }
      assert (｜(yk[n] - x0)｜ ≤ ｜(yk[n] - xk[n])｜ + ｜(xk[n] - x0)｜).
      { rewrite H73. apply Abs_P5; auto with real. }
      assert (｜(yk[n] - xk[n]) ｜ + ｜(xk[n] - x0)｜ < ε / (1 + 1) + ε / (1 + 1)).
      { destruct H70. apply OrderPM_Co4; auto with real. }
      assert ((1 + 1) ⁻ + (1 + 1) ⁻ = 1).
      { assert ((1 + 1) ⁻ + (1 + 1) ⁻  = (1 + 1) · (1 + 1) ⁻).
        { rewrite Mult_P5,Mult_P4,Mult_P1; auto with real. }
        rewrite H76,Divide_P1; auto. }
      assert ((((1 + 1) ⁻) + ((1 + 1) ⁻)) · ε = ε).
      { rewrite H76,Mult_P4,Mult_P1; auto with real. }
      assert (ε / (1 + 1) + ε / (1 + 1) = ε).
      { rewrite Mult_P4,<-Mult_P5; auto. } rewrite <-H78.
      apply (Order_Co2 _ (｜(yk[n] - xk[n]) ｜ + ｜(xk[n] - x0)｜) _);
      auto with real. }
    assert (∀ n, n ∈ ℕ -> a ≤ xk[n] /\ xk[n] ≤ b).
    { intros. apply H25 in H47 as H48; rewrite H48. apply H44 in H47.
      apply H36 in H47 as [H47 _]. apply AxiomII in H47; tauto. }
    assert (a ≤ x0 /\ x0 ≤ b) as [].
    { split.
      + apply Corollary2_5a with (x:= xk); auto. exists 1; split; auto with real.
        intros. apply H47; auto.
      + apply Corollary2_5b with (x:= xk); auto; exists 1; split; auto with real;
        intros; apply H47; auto. }
    assert (Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[xk[n]] \}\ f[x0]
      /\ Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[yk[n]] \}\ f[x0]) as [].
    { assert (ran(xk) ⊂ dom(f)).
      { red; intros xn H50. apply AxiomII in H50 as [H50[n]]. apply H0.
        apply Property_dom in H51 as H52. rewrite H4 in H52.
        apply Property_Fun in H51; auto. apply H25 in H52 as H53.
        apply H44 in H52. apply H36 in H52 as H54; destruct H54 as [H54 _].
        rewrite H51,H53; auto. }
      assert (ran(yk) ⊂ dom(f)).
      { red; intros yn H51. apply AxiomII in H51 as [H51[n]]. apply H0.
        apply Property_dom in H52 as H53. rewrite H42 in H53.
        apply Property_Fun in H52; auto. apply H40 in H53 as H54.
        apply H44 in H53. apply H36 in H53 as H55; destruct H55 as [_[H55 _]].
        rewrite H52,<-H54; auto. }
      destruct (classic (a = x0)) as [H52|H52].
      + subst x0. split; apply Corollary3_8a' with (x0:= a); auto; intros.
        * apply H47 in H52 as [H52 _]; auto.
        * apply H44 in H52 as H53. pose proof (H36 _ H53) as [_[H54 _]].
          rewrite <-H40; auto. apply AxiomII in H54; tauto.
      + destruct (classic (b = x0)).
        * subst x0. split; apply Corollary3_8b' with (x0:= b); auto; intros.
          -- apply H47 in H53 as [_ H53]; auto.
          -- apply H40 in H53 as H54. apply H44 in H53.
             apply H36 in H53 as [_[H53 _]]. rewrite <-H54.
             apply AxiomII in H53; tauto.
        * assert (x0 ∈ ］a, b［). { apply AxiomII; repeat split; eauto. }
          apply Ha in H54 as []. split; apply Theorem3_8' with (x0:= x0); auto. }
    assert (∀ n, n ∈ ℕ -> f[xk[n]] ∈ ℝ /\ f[yk[n]] ∈ ℝ).
    { intros. split; [apply Hm,(@ Property_ran (xk[n])),Property_Value; auto;
      rewrite Hl; apply H41,(@ Property_ran n),Property_Value; auto;
      rewrite H4; auto|apply Hm,(@ Property_ran (yk[n])),Property_Value; auto;
      rewrite Hl; apply H43,(@ Property_ran n),Property_Value; auto;
      rewrite H42; auto]. }
    assert (∀ n, n ∈ ℕ -> f[xk[n]] 
      = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[xk[n]] \}\ [n]).
    { intros. apply H52 in H53 as H54; destruct H54 as [H54 _].
      apply Property_Fun. apply H50. apply AxiomII'; split; auto.
      apply MKT49a; eauto. }
    assert (∀ n, n ∈ ℕ -> f[yk[n]] 
      = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[yk[n]] \}\ [n]).
    { intros. apply H52 in H54 as H55; destruct H55 as [_ H55].
      apply Property_Fun. apply H51. apply AxiomII'; split; auto.
      apply MKT49a; eauto. }
    assert (Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = ｜(f[xk[n]] - f[yk[n]])｜\}\).
    { split; [idtac|split].
      + split; intros.
        * red; intros. apply AxiomII in H55 as [_[x1[y1]]]. exists x1, y1; tauto.
        * apply AxiomII' in H55 as [_[H55[]]],H56 as [_[H56[]]].
          rewrite H60; auto.
      + apply AxiomI; split; intros.
        * apply AxiomII in H55 as [_[y1]]. apply AxiomII' in H55; tauto.
        * apply AxiomII; split; eauto. exists (｜(f[xk[z]] - f[yk[z]])｜).
          apply H52 in H55 as H56; destruct H56 as [].
          assert (｜(f[xk[z]] - f[yk[z]])｜ ∈ ℝ).
          { apply Abs_in_R; auto with real. }
          apply AxiomII'; repeat split; auto with real. apply MKT49a; eauto.
      + red; intros. apply AxiomII in H55 as [_[x1]].
        apply AxiomII' in H55; tauto. }
    assert (∀ n, n ∈ ℕ ->｜(f[xk[n]] - f[yk[n]])｜
      = \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = ｜(f[xk[n]] - f[yk[n]])｜\}\ [n]).
    { intros. apply Property_Fun. apply H55.
      apply H52 in H56 as H57; destruct H57 as [].
      assert (｜(f[xk[n]] - f[yk[n]])｜ ∈ ℝ). { apply Abs_in_R; auto with real. }
      apply AxiomII'; split; auto. apply MKT49a; eauto. }
    assert (Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ 
      /\ v = ｜(f[xk[n]] - f[yk[n]])｜\}\ 0).
    { split; auto. intros ε [].
      assert (ε / (1 + 1) ∈ ℝ /\ 0 < ε / (1 + 1)).
      { split; auto with real; apply OrderPM_Co5; auto. }
      apply H50 in H59 as H60; apply H51 in H59 as H61.
      destruct H60 as [N1[]]; destruct H61 as [N2[]].
      pose proof (Max_nat_2 _ _ H60 H61) as [N[H64[]]].
      exists N; split; auto. intros.
      assert (N1 < n /\ N2 < n) as [].
      { split; apply (RTrans_Lt _ N _); auto with real. }
      apply H62 in H69; apply H63 in H70; auto. apply H52 in H67 as H71;
      apply H53 in H67 as H72; apply H54 in H67 as H73; destruct H71 as [].
      rewrite <-H72,<-H73 in *. apply H56 in H67 as H75.
      assert (｜(f[xk[n]] - f[yk[n]])｜ ∈ ℝ). { apply Abs_in_R; auto with real. }
      rewrite <-H75,Minus_P2; auto.
      assert (0 ≤ ｜(f[xk[n]] - f[yk[n]])｜). { apply Abs_P1; auto with real. }
      assert (｜(｜(f[xk[n]] - f[yk[n]])｜)｜ = ｜(f[xk[n]] - f[yk[n]])｜).
      { apply me_zero_Abs; auto. }
      assert (f[x0] ∈ ℝ).
      { apply Hm,(@ Property_ran x0),Property_Value; auto; rewrite Hl;auto. }
      assert (f[xk[n]] - f[yk[n]] = (f[xk[n]] - f[x0]) + (f[x0] - f[yk[n]])).
      { rewrite <-Plus_P3,(Plus_P3 (-f[x0])),(Plus_P4 (-f[x0])),Minus_P1,
        (Plus_P4 0),Plus_P1; auto with real. }
      assert (f[x0] - f[yk[n]] = (- (f[yk[n]] - f[x0]))).
      { rewrite Minus_P3,Minus_P4,Plus_P4; auto with real. }
      assert ((1 + 1) ⁻ + (1 + 1) ⁻ = 1).
      { assert ((1 + 1) ⁻ + (1 + 1) ⁻  = (1 + 1) · (1 + 1) ⁻).
        { rewrite Mult_P5,Mult_P4,Mult_P1; auto with real. }
        rewrite H82,Divide_P1; auto. }
      assert ((((1 + 1) ⁻) + ((1 + 1) ⁻)) · ε = ε).
      { rewrite H82,Mult_P4,Mult_P1; auto with real. }
      assert (ε / (1 + 1) + ε / (1 + 1) = ε).
      { rewrite Mult_P4,<-Mult_P5; auto. } destruct H69.
      assert (｜(f[xk[n]] - f[x0])｜ + ｜(f[yk[n]] - f[x0])｜
        < ε / (1 + 1) + ε / (1 + 1)).
      { apply OrderPM_Co4; auto with real. }
      assert (｜((f[xk[n]] - f[x0]) - (f[yk[n]] - f[x0]))｜
        ≤ ｜(f[xk[n]] - f[x0])｜ + ｜(f[yk[n]] - f[x0])｜).
      { apply Abs_P5; auto with real. }
      rewrite H78,H80,H81,<-H84.
      apply (Order_Co2 _ (｜(f[xk[n]] - f[x0])｜ + ｜(f[yk[n]] - f[x0])｜) _);
      auto with real. apply Abs_in_R; auto with real. }
    destruct H2. assert (ε0 ≤ 0).
    { apply Corollary2_5a with (x:= \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ 
        /\ v = ｜(f[xk[n]] - f[yk[n]])｜\}\); auto with real.
      exists 1; split; auto with real. intros. rewrite <-H56,H25,<-H40; auto.
      apply H36,H44; auto. }
    destruct H58. elim H60. apply Leq_P2; auto with real.
  - intros. exists 1; split; auto with real; split; auto. intros.
    apply AxiomII in H2 as [H2[H5[]]]. destruct H1.
    assert (a ≤ b). { apply (Leq_P3 _ x1 _); auto. }
    elim H8; apply Leq_P2; auto.
  - intros. exists 1; split; auto with real; split; auto. intros. subst b.
    apply AxiomII in H2 as [_[H2[]]]; apply AxiomII in H3 as [_[H3[]]].
    assert (x1 = a /\ x2 = a) as []. { split; apply Leq_P2; auto. }
    assert (｜(0)｜ = 0). { apply Abs_P1; auto with real. }
    assert (｜(0)｜ < ε). { destruct H as []. rewrite H10; auto. }
    rewrite H8,H9,Minus_P1; auto.
Qed.

(* Theorem Archimedes : ∀ a b, a ∈ ℝ -> b ∈ ℝ -> 0 < a -> 0 < b 
  -> ∃ n, n ∈ ℕ /\ b < n · a.

(* f在x0邻域内连续的归结原则 *)
Theorem Theorem3_8' : ∀ f x0 A, x0 ∈ dom(f) -> f[x0] = A
  -> Limit_x0 f x0 A -> ∀ x, Limit_Seq x x0 -> ran(x) ⊂ dom(f)
  -> Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\ A.
  
Corollary Corollary3_8a' :  ∀ f x0 A, x0 ∈ dom(f) -> f[x0] = A
  -> Limit_Right f x0 A -> ∀ x, Limit_Seq x x0 -> ran(x) ⊂ dom(f)
  -> (∀ n, n ∈ ℕ -> x0 ≤ x[n])
  -> Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\ A.
  
Corollary Corollary3_8b' :  ∀ f x0 A, x0 ∈ dom(f) -> f[x0] = A
  -> Limit_Left f x0 A -> ∀ x, Limit_Seq x x0 -> ran(x) ⊂ dom(f)
  -> (∀ n, n ∈ ℕ -> x[n] ≤ x0)
  -> Limit_Seq \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = f[x[n]] \}\ A. *)

Corollary MonoIn_Lim_Up : ∀ x η, η ∈ ℝ -> MonoInc_Seq x -> Limit_Seq x η
  -> (∀ n, n ∈ ℕ -> x[n] ≤ η).
Proof.
  intros. apply MonoInc_Seq_Equal in H0 as H3.
  destruct H3 as [],H1 as [[H1[]]].
  assert (x[n] ∈ ℝ).
  { apply H6,(@ Property_ran n),Property_Value; auto; rewrite H5; auto. }
  destruct (Order_Co1 x[n] η) as [H9|[H9|H9]]; auto.
  - destruct H9; auto.
  - assert (0 < x[n] - η).
    { apply (OrderPM_Co1 _ _ (- η)) in H9; auto with real.
    rewrite Minus_P1 in H9; auto. }
    assert (x[n] - η ∈ ℝ /\ 0 < x[n] - η). { split; auto with real. }
    apply H7 in H11 as [N[]]. assert (N < N + 1).
    { apply Nat_P4b; auto. apply Leq_P1; auto with real. }
    assert (x[N] ∈ ℝ /\ x[N + 1] ∈ ℝ) as [].
    { split; [apply H6,(@ Property_ran N),Property_Value; auto;
      rewrite H5; auto|apply H6,(@ Property_ran (N + 1)),Property_Value; auto;
      rewrite H5; auto with real]. }
    destruct (Order_Co1 n N) as [H16|[H16|H16]]; auto with real.
    + exfalso. apply H12 in H13 as H17; auto with real.
      apply H4 in H13 as H18; auto with real.
      assert (x[n] ≤ x[N + 1]). { apply (Leq_P3 _ x[N] _); auto. }
      assert (η < x[N + 1]). { apply (Order_Co2 _ x[n] _); auto. }
      assert (0 < x[N + 1] - η).
      { apply (OrderPM_Co1 _ _ (-η)) in H20; auto with real.
        rewrite Minus_P1 in H20; auto. }
      destruct H21. rewrite me_zero_Abs in H17; auto with real.
      apply (OrderPM_Co1 _ _ η) in H17; auto with real.
      rewrite <-Plus_P3,(Plus_P4 (-η)),Minus_P1,Plus_P1,
      <-Plus_P3,(Plus_P4 (-η)),Minus_P1,Plus_P1 in H17; auto with real.
      destruct H17. elim H23. apply Leq_P2; auto.
    + apply H12 in H16 as H17; auto. destruct H10.
      rewrite me_zero_Abs in H17; auto with real.
      apply (OrderPM_Co1 _ _ η) in H17; auto with real.
      rewrite <-Plus_P3,(Plus_P4 (-η)),Minus_P1,Plus_P1 in H17;
      auto with real. destruct H17. elim H19. apply Leq_P2; auto with real.
    + apply H12 in H13 as H17; auto with real.
      apply H4 in H13 as H18; auto with real. subst n.
      assert (η < x[N + 1]). { apply (Order_Co2 _ x[N] _); auto. }
      assert (0 < x[N + 1] - η).
      { apply (OrderPM_Co1 _ _ (-η)) in H16; auto with real.
        rewrite Minus_P1 in H16; auto. }
      destruct H19. rewrite me_zero_Abs in H17; auto with real.
      apply (OrderPM_Co1 _ _ η) in H17; auto with real.
      rewrite <-Plus_P3,(Plus_P4 (-η)),Minus_P1,Plus_P1,
      <-Plus_P3,(Plus_P4 (-η)),Minus_P1,Plus_P1 in H17; auto with real.
      destruct H17. elim H21. apply Leq_P2; auto.
  - rewrite H9; apply Leq_P1; auto.
Qed.

Corollary MonoDe_Lim_Down : ∀ x ξ, ξ ∈ ℝ -> MonoDec_Seq x -> Limit_Seq x ξ
  -> (∀ n, n ∈ ℕ -> ξ ≤ x[n]).
Proof.
  pose proof OrderPM_Co9 as Hz. pose proof Hz as [Hy Hx].
  assert ((-(1)) < 0) as Hw. { apply OrderPM_Co2a; auto with real. }
  intros. apply MonoDec_Seq_Equal in H0 as H3. destruct H3,H1 as [[H1[]]].
  assert (∀ n, n ∈ ℕ -> x[n] ∈ ℝ).
  { intros. apply H6,(@ Property_ran n0),Property_Value; auto;
    rewrite H5; auto. }
  apply H8 in H2 as H9. assert (Function (x \\· (-(1)))).
  { split.
    + red; intros. apply AxiomII in H10 as [_[x1[y[]]]]; exists x1, y; auto.
    + intros. apply AxiomII' in H10 as [H10[]],H11 as [H11[]].
      rewrite H15; auto. }
  assert (Seq (x \\· (-(1)))).
  { split;[idtac|split]; auto.
    - apply AxiomI; split; intros.
      + apply AxiomII in H11 as [_[y]]. apply AxiomII' in H11 as [H11[]].
        rewrite H5 in H12; auto.
      + assert (z ∈ dom(x)). { rewrite H5; auto. }
        assert (- x[z] = x[z] · - (1)).
        { rewrite Mult_P4,<-PlusMult_Co3; auto with real. }
        apply AxiomII; split; eauto. exists (-x[z]). apply H8 in H11 as H14.
        apply AxiomII'; split; auto. apply MKT49a; eauto with real.
    - red; intros. apply AxiomII in H11 as [H11[x1]].
      apply AxiomII' in H12 as [H12[]]. rewrite H5 in H13.
      apply H8 in H13 as H15. rewrite H14; auto with real. }
  assert (∀ n, n ∈ ℕ -> - x[n] = (x \\· (-(1)))[n]).
  { intros. apply Property_Fun; auto. apply H8 in H12 as H13.
    assert (n0 ∈ dom(x)). { rewrite H5; auto. }
    apply AxiomII'; repeat split; auto. apply MKT49a; eauto with real.
    rewrite Mult_P4,<-PlusMult_Co3; auto with real. }
  assert (MonoInc_Seq (x \\· (-(1)))).
  { apply MonoInc_Seq_Equal; split; auto. intros. apply H4 in H15; auto.
    apply H12 in H13 as H16; apply H12 in H14 as H17. rewrite <-H16,<-H17.
    apply H8 in H13 as H18; apply H8 in H14 as H19. destruct Hw.
    apply (OrderPM_Co8b _ _ (-(1))) in H15; auto with real.
    rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3 in H15;
    auto with real. }
  assert (Limit_Seq ((x \\· (-(1)))) (-ξ)).
  { split; auto. intros. apply H7 in H14 as [N[]]. exists N; split; auto.
    intros. apply H15 in H17; auto. apply H12 in H16 as H18. rewrite <-H18.
    rewrite Minus_P4; auto. assert (｜(x[n0] - ξ)｜ = ｜(-(x[n0] - ξ))｜).
    { apply Abs_P2; auto with real. }
    rewrite Minus_P3,Minus_P4 in H19; auto with real. rewrite <-H19; auto. }
  assert (-ξ ∈ ℝ). auto with real. pose proof (MonoIn_Lim_Up _ _ H15 H13 H14).
  apply H16 in H2 as H17; apply H12 in H2 as H18. rewrite <-H18 in H17.
  destruct Hw. apply (OrderPM_Co8b _ _ (-(1))) in H17; auto with real.
  rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3,Minus_P4,Minus_P4
  in H17; auto with real.
Qed.

(* 闭区间套定理 *)
(* 闭区间套 *)
Definition NestedIntervals a b := MonoInc_Seq a /\ MonoDec_Seq b
  /\ (∀ n, n ∈ ℕ -> a[n] ≤ b[n]) /\ Limit_Seq (b \- a) 0.

(* 无变量n引入 *)
(* Theorem NestedIntervals_Exist : ∀ a b, NestedIntervals a b
  -> ∃ ξ, ξ ∈ ℝ /\ (∀ n, n ∈ ℕ -> a[n] ≤ ξ /\ ξ ≤ b[n])
  /\ Limit_Seq a ξ /\ Limit_Seq b ξ. *)

(* 存在性 *)
Theorem NestedIntervals_Exist : ∀ a b, NestedIntervals a b
  -> ∀ n, n ∈ ℕ -> ∃ ξ, ξ ∈ ℝ /\ a[n] ≤ ξ /\ ξ ≤ b[n]
  /\ Limit_Seq a ξ /\ Limit_Seq b ξ.
Proof.
  pose proof OrderPM_Co9 as Hz. pose proof Hz as [Hy Hx].
  assert (-(1) < 0) as Hw. { apply OrderPM_Co2a; auto with real. }
  pose proof Hw as [Hv Hu]. intros. destruct H as [H[H1[H2]]].
  apply MonoInc_Seq_Equal in H as H4. destruct H4 as [].
  apply MonoDec_Seq_Equal in H1 as H6. destruct H6 as [].
  pose proof H4 as [H8[]]; pose proof H6 as [H11[]].
  assert (BoundedUp_Seq a).
  { assert (b[1] ∈ ℝ).
    { apply H13,(@ Property_ran 1),Property_Value; auto.
      rewrite H12; auto with real. }
    assert (a[1] ∈ ℝ).
    { apply H10,(@ Property_ran 1),Property_Value; auto;
      rewrite H9; auto with real. }
    red; split; auto. exists b[1]; split; auto. intros.
    destruct (Leq_P4 n0 1) as [H17|H17]; auto with real.
    - assert (n0 = 1).
      { apply Leq_P2; auto with real. apply one_is_min_in_N; auto. }
      pose proof (H2 _ H16). rewrite H18 in *; auto.
    - pose proof (H2 _ H16).
      assert (a[n0] ∈ ℝ /\ a[n0 + 1] ∈ ℝ) as [].
      { split; [apply H10,(@ Property_ran n0),Property_Value; auto;
        rewrite H9; auto|apply H10,(@ Property_ran (n0 + 1)),Property_Value;
        auto; rewrite H9; auto with real]. }
      assert (b[n0 + 1] ∈ ℝ).
      { apply H13,(@ Property_ran (n0 + 1)),Property_Value; auto;
        rewrite H12; auto with real. }
      assert (n0 < n0 + 1).
      { apply Nat_P4b; auto. apply Leq_P1; auto with real. }
      assert (1 < n0 + 1).
      { assert (1 + 0 < n0 + 1).
        { apply OrderPM_Co4; auto with real. }
        rewrite Plus_P1 in H23; auto with real. }
      assert (a[n0] ≤ b[n0 + 1]).
      { assert (a[n0] ≤ a[n0 + 1]). { apply H5; auto with real. }
        assert (a[n0 + 1] ≤ b[n0 + 1]). { apply H2; auto with real. }
        apply (Leq_P3 _ a[n0 + 1] _); auto with real. }
      assert (b[n0 + 1] ≤ b[1]). { apply H7; auto with real. }
      apply (Leq_P3 _ b[n0 + 1] _); auto with real. }
  apply Lemma2_9a in H14 as H15; auto. destruct H15 as [ξ[]].
  set (F:= \{\ λ n v, n ∈ ℕ /\ v ∈ ℝ /\ v = (b \- a)[n] + a[n] \}\).
  assert (Function (b \- a)).
  { split.
    + red; intros. apply AxiomII in H17 as [_[x[y[]]]]. exists x, y; auto.
    + intros. apply AxiomII' in H17 as [H17[H19[]]],H18 as [H18[_[_]]].
      rewrite H22; auto. }
  assert (Seq (b \- a)).
  { split;[|split]; auto.
    - apply AxiomI; split; intros.
      + apply AxiomII in H18 as [H18[y]]. apply AxiomII' in H19 as [_[H19[]]].
        rewrite <-H12; auto.
      + assert (b[z] ∈ ℝ /\ a[z] ∈ ℝ) as [].
        { split; [apply H13,(@ Property_ran z),Property_Value; auto;
          rewrite H12; auto|apply H10,(@ Property_ran z),Property_Value; auto;
          rewrite H9; auto]. }
        assert (z ∈ dom(b) /\ z ∈ dom(a)) as [].
        { split; [rewrite H12; auto|rewrite H9; auto]. }
        apply AxiomII; split; eauto. exists (b[z] - a[z]).
        apply AxiomII'; repeat split; auto. apply MKT49a; eauto with real.
    - red; intros. apply AxiomII in H18 as [_[x]].
      apply AxiomII' in H18 as [H18[H19[]]]. rewrite H12 in H19.
      assert (b[x] ∈ ℝ /\ a[x] ∈ ℝ) as [].
      { split; [apply H13,(@ Property_ran x),Property_Value; auto;
        rewrite H12; auto|apply H10,(@ Property_ran x),Property_Value; auto;
        rewrite H9; auto]. }
      rewrite H21; auto with real. }
  assert (Limit_Seq F (0 + ξ)). { apply Corollary2_7a; auto with real. }
  assert (Function F).
  { split.
    - red; intros. apply AxiomII in H20 as [_[x[y[]]]]. exists x, y; auto.
    - intros. apply AxiomII' in H20 as [H20[H22[]]],H21 as [H21[H25[]]].
      rewrite H27; auto. }
  assert (∀ n, n ∈ ℕ -> b[n] = F[n]).
  { intros. assert (b[n0] ∈ ℝ /\ a[n0] ∈ ℝ) as [].
    { split; [apply H13,(@ Property_ran n0),Property_Value; auto;
      rewrite H12; auto|apply H10,(@ Property_ran n0),Property_Value; auto;
      rewrite H9; auto]. }
    assert (n0 ∈ dom(b) /\ n0 ∈ dom(a)) as [].
    { split; [rewrite H12; auto|rewrite H9; auto]. }
    apply Property_Fun; auto. apply AxiomII'; repeat split; auto.
    - apply MKT49a; eauto.
    - assert (b[n0] - a[n0] = (b \- a) [n0]).
      { apply Property_Fun; auto. apply AxiomII'; split; auto.
        apply MKT49a; eauto with real. }
    rewrite <-H26,<-Plus_P3,(Plus_P4 (-a[n0])),Minus_P1,Plus_P1;
    auto with real. }
  assert (Limit_Seq b ξ).
  { destruct H19. split; auto; intros. apply H22 in H23 as [N[]].
    exists N; split; auto. intros. apply H21 in H25 as H27.
    apply H24 in H26; auto. rewrite <-H27,(Plus_P4 0),Plus_P1 in H26;
    auto with real. }
  pose proof (MonoIn_Lim_Up _ _ H15 H H16).
  pose proof (MonoDe_Lim_Down _ _ H15 H1 H22).
  apply H23 in H0 as H25. apply H24 in H0. exists ξ; split; auto.
Qed.

(* 唯一性 *) 
Theorem NestedIntervals_Union :
  ∀ a b ξ1 ξ2, ξ1 ∈ ℝ -> ξ2 ∈ ℝ -> NestedIntervals a b
  -> (∀ n, n ∈ ℕ -> a[n] ≤ ξ1 /\ ξ1 ≤ b[n]) /\ Limit_Seq a ξ1 /\ Limit_Seq b ξ1
  -> (∀ n, n ∈ ℕ -> a[n] ≤ ξ2 /\ ξ2 ≤ b[n]) /\ Limit_Seq a ξ2 /\ Limit_Seq b ξ2
  -> ξ1 = ξ2.
Proof.
  intros. destruct H2 as [H2[]],H3 as [H3[]].
  pose proof H4 as [H8 _]. apply Theorem2_2 with (x:= a); auto.
Qed.

Corollary NestedIntervals_Cor : ∀ a b, NestedIntervals a b
  -> (∀ m, m ∈ ℕ -> (∃ ξ, ξ ∈ ℝ /\ a[m] ≤ ξ /\ ξ ≤ b[m]
      /\ (∀ ε, ε ∈ ℝ /\ 0 < ε -> ∃ N, N ∈ ℕ /\ ∀ n, n ∈ ℕ -> N < n
        ->［(a[n]), (b[n])］⊂ U(ξ; ε)))).
Proof.
  pose proof OrderPM_Co9 as Hz. pose proof Hz as [Hy Hx].
  assert (-(1) < 0) as Hw. { apply OrderPM_Co2a; auto with real. }
  pose proof Hw as [Hv Hu]. intros.
  apply NestedIntervals_Exist with (n:= m) in H; auto.
  destruct H as [ξ[H1[H2[H3[H4]]]]]. exists ξ; do 3 (split; auto).
  intros. destruct H4,H. pose proof H4 as [H9[]]; pose proof H as [H12[]].
  apply H6 in H5 as H14; apply H7 in H5 as H15. destruct H5.
  destruct H14 as [N1[]],H15 as [N2[]]. pose proof H16 as [H19 _].
  pose proof (Max_nat_2 _ _ H14 H15) as [N[H20[]]]. exists N; split; auto.
  intros. assert (N1 < n /\ N2 < n) as [].
  { split; apply (RTrans_Lt _ N _); auto with real. }
  apply H17 in H25; auto; apply H18 in H26; auto.
  red; intros. apply AxiomII in H27 as [H27[H28[]]].
  assert (a[n] ∈ ℝ /\ b[n] ∈ ℝ) as [].
  { split; [apply H10,(@ Property_ran n),Property_Value; auto;rewrite H8;auto
    |apply H13,(@ Property_ran n),Property_Value; auto;rewrite H11;auto]. }
  destruct H25,H26. apply Abs_P4 in H25 as [],H26 as []; auto with real.
  apply (Plus_Leq _ _ (-ξ)) in H29,H30; auto with real.
  apply AxiomII; repeat split; auto with real.
  - apply Abs_P4; auto with real.
    split;[apply (Leq_P3 _ (a[n] - ξ) _); auto with real
    |apply (Leq_P3 _ (b[n] - ξ) _); auto with real].
  - intro. destruct (Leq_P4 (z - ξ) 0) as [H38|H38]; auto with real.
    + elim H33. assert (a[n] - ξ ≤ 0).
      { apply (Leq_P3 _ (z - ξ) _); auto with real. }
      rewrite le_zero_Abs,Minus_P3,Minus_P4 in H37; auto with real.
      rewrite le_zero_Abs,Minus_P3,Minus_P4; auto with real.
      rewrite <-H37,Minus_P3,Minus_P4 in H25; auto with real.
      apply (OrderPM_Co8b _ _ (-(1))) in H25,H29; auto with real.
      rewrite Mult_P4,<-PlusMult_Co3,Mult_P4,<-PlusMult_Co3,Minus_P3,Minus_P4,
      Minus_P3,Minus_P4 in H25,H29; auto with real. rewrite <-H37.
      apply Leq_P2; auto with real.
    + elim H34. assert (0 ≤ b[n] - ξ).
      { apply (Leq_P3 _ (z - ξ) _); auto with real. }
      rewrite me_zero_Abs in H37; auto with real.
      rewrite me_zero_Abs; auto with real. rewrite <-H37 in H36. rewrite <-H37.
      apply Leq_P2; auto with real.
Qed.
